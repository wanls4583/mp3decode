<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>mp3音频解析</title>
</head>
<body>
	<input value=0 type="range" id="myRange" >

	<p id="per"></p>

	<script type="text/javascript">
	var url = 'test.mp3';
	var mp3Info = null;
	var fileSize = 0;
	var audioContext = null;
	var fileBlocks = new Array(100); //音频数据分区
	var headerLength = 0;
	var cacheFrameSize = 10;//每次加载的帧数
	var indexSize = 100;//索引个数
	var playIntervalId = null;//播放计时器
	var hasPlayed = false;//是否已经开始播放
	var souceNodeQueue = [];//音频资源队列
	var stopDecode = false;//是否有数据正在解码中
	var nowSouceNode = null;//正在播放的资源节点

	promise = new Promise(loadHeaderInfo);
	promise.then(loadFirstFrame).then(getInfo).then(start);

	Array.prototype.indexOf = function(item){
		for(var i=0; i<this.length; i++){
			if(this[i]==item){
				return i;
			}
		}
		return -1;
	}
	//ajax获取音频头部标签头(32B)
	function loadHeaderInfo(resolve,reject){
		var request = new XMLHttpRequest();
	    request.open('GET', url, true);
	    request.responseType = 'arraybuffer';
	   
	    request.onload = function() {
	        var arrayBuffer = request.response;
	        var contentLength = request.getResponseHeader('Content-Length');
	        var contetnRange = request.getResponseHeader('Content-Range');
	        if(contentLength!=32*8){
	        	throw new Error('获取头部信息出错');
	        }
	        fileSize = parseInt(contetnRange.substr(contetnRange.indexOf('/')+1));
	        headerLength = getHeaderLength(arrayBuffer);
	        resolve();
	    }
	    request.setRequestHeader("Range","bytes=0-"+(32*8-1));
	    request.send();
	}
	//获取ID3V2|APEV2标签长度
	function getHeaderLength(arrayBuffer){
		var uint8Array = new Uint8Array(arrayBuffer);
		var headerLength =  0;
		var tag = '';
		var type = '';
		for(var i=0; i<8; i++){
			tag+=String.fromCharCode(uint8Array[i])
		}
		if(tag.substring(0,3)=='ID3'){
			headerLength = (((uint8Array[6]&0x7F)<<21) | ((uint8Array[7]&0x7F)<<14) | ((uint8Array[8]&0x7F)<<7) | (uint8Array[9]&0x7F))+10;
			type = 'ID3'
		}else if(tag=='APETAGEX'){
			headerLength = (((uint8Array[12]&0x7F)) | ((uint8Array[13]&0x7F)<<8) | ((uint8Array[14]&0x7F)<<16) | (uint8Array[15]&0x7F)<<24)+32;
			type = 'APETAGEX'
		}
		return headerLength;
	}
	//加载第一个数据帧
	function loadFirstFrame(){
		return new Promise(function(resolve,reject){
			var request = new XMLHttpRequest();
		    request.open('GET', url, true);
		    request.responseType = 'arraybuffer';
		   
		    request.onload = function() {
		        var arrayBuffer = request.response;
		        var contentLength = request.getResponseHeader('Content-Length');
		        var contetnRange = request.getResponseHeader('Content-Range');
		        if(contentLength!=156*8){
		        	throw new Error('获取第一帧数据帧出错');
		        }
		        resolve(arrayBuffer);
		    }
		    request.setRequestHeader("Range","bytes="+headerLength+'-'+(headerLength+156*8-1));
		    request.send();
		})
	}
	//获取VBR(OR CBR)信息
	function getInfo(arrayBuffer){
		var bufferStr = '';
		var uint8Array = null;
		var vbrDataBuffer = null;
		var samplingRate = getSamplingRate(arrayBuffer);

		uint8Array = new Uint8Array(arrayBuffer);

		//转换成16进制码
		for(var i=0; i<indexSize; i++){
			if(uint8Array[i]<=15){
				bufferStr += '0'+uint8Array[i].toString(16);
			}else{
				bufferStr += uint8Array[i].toString(16);
			}
			
		}
		bufferStr = bufferStr.toUpperCase();

		if(bufferStr.indexOf('496E666F')!=-1){//存在Info头
			vbrDataBuffer = arrayBuffer.slice(bufferStr.indexOf('496E666F')/2);
			return getInfo(vbrDataBuffer);
		}else if(bufferStr.indexOf('58696E67')!=-1){//存在Xing头
			vbrDataBuffer = arrayBuffer.slice(bufferStr.indexOf('58696E67')/2);
			return getInfo(vbrDataBuffer);
		}else {//纯CBR编码
			var frameSize = getFrameSize(arrayBuffer);
			var totalTime = (fileSize - getHeaderLength(arrayBuffer))/samplingRate;
			return {
				frameSize: frameSize
			};
		}

		//获取总帧数
		function getTotalFrame(vbrDataBuffer){
			vbrDataBuffer = vbrDataBuffer.slice(0,12);
			var vbrUint8Array = new Uint8Array(vbrDataBuffer);
			if(vbrUint8Array[7] & 1){
				return (vbrUint8Array[8]<<24)+(vbrUint8Array[9]<<16)+(vbrUint8Array[10]<<8)+(vbrUint8Array[11]);
			}else 
				return false;
		}

		//获取数据帧总大小(bit)
		function getTotalSize(vbrDataBuffer){
			vbrDataBuffer = vbrDataBuffer.slice(0,16);
			var vbrUint8Array = new Uint8Array(vbrDataBuffer);
			if(vbrUint8Array[7] & 2){
				if(vbrUint8Array[7] & 1 == 0){
					return (vbrUint8Array[8]<<24)+(vbrUint8Array[9]<<16)+(vbrUint8Array[10]<<8)+(vbrUint8Array[11]);
				}else{
					return (vbrUint8Array[12]<<24)+(vbrUint8Array[13]<<16)+(vbrUint8Array[14]<<8)+(vbrUint8Array[15]);
				}
			}else 
				return false;
		}

		//获取帧索引数组(100个)
		function getToc(vbrDataBuffer){
			var vbrUint8Array = new Uint8Array(vbrDataBuffer);
			if(vbrUint8Array[7] & 4){
				if(!(vbrUint8Array[7] & 1) && !(vbrUint8Array[7] & 2)){
					return _getToc(vbrDataBuffer.slice(8));
				}else if((vbrUint8Array[7] & 1) && !(vbrUint8Array[7] & 2) || !(vbrUint8Array[7] & 1) && (vbrUint8Array[7] & 2)){
					return _getToc(vbrDataBuffer.slice(12));
				}else{
					return _getToc(vbrDataBuffer.slice(16));
				}
			}

			function _getToc(docArrayBuffer){
				var indexArr = [];
				var docuUnit8Array = new Uint8Array(docArrayBuffer.slice(0,indexSize));
				for(var i=0; i<100; i++){
					indexArr[i] = docuUnit8Array[i];
				}
				return indexArr;
			}
		}

		function getInfo(vbrDataBuffer){
			var totalFrame = getTotalFrame(vbrDataBuffer);
			var totalTime = 1152*totalFrame/samplingRate;
			var totalSize = getTotalSize(vbrDataBuffer)+getHeaderLength(arrayBuffer);
			var toc = getToc(vbrDataBuffer);
			var info = {
				totalFrame: totalFrame,
				totalSize: totalSize,
				totalTime: totalTime,
				toc: toc
			};
			return info;
		}
	}
	//获取比特率
	function getBitRate(arrayBuffer){
		//比特率对应表(bit/s)
		var brMap = {
			'1':32000,
			'10':40000,
			'11':48000,
			'100':56000,
			'101':64000,
			'110':80000,
			'111':96000,
			'1000':112000,
			'1001':128000,
			'1010':160000,
			'1011':192000,
			'1100':224000,
			'1101':256000,
			'1110':320000
		}

		var uint8Array = new Uint8Array(arrayBuffer);
		var brCode = (uint8Array[2]&0xF0).toString(2).substring(0,4);
		return brMap[brCode];
	}
	//获取采样率
	function getSamplingRate(arrayBuffer){
		//比特率对应表(Hz)
		var srMap = {
			'0':44100,
			'1':48000,
			'10':32000,
		}

		var uint8Array = new Uint8Array(arrayBuffer);
		var srCode = (uint8Array[2]&0x0C).toString(2).substring(0,2);
		return srMap[srCode];
	}
	//获取第一帧填充数
	function getPadding(arrayBuffer){
		var uint8Array = new Uint8Array(arrayBuffer);
		var pdCode = (uint8Array[2]&0x02).toString(2);

		if(pdCode=='1'){
			return 1;
		}else{
			return 0;
		}
	}
	//获取帧大小(bit)
	function getFrameSize(arrayBuffer){
		var samplingRate = getSamplingRate(arrayBuffer);
		var bitRate = getBitRate(arrayBuffer);
		var padding = getPadding(arrayBuffer); 

		return 1152*bitRate/samplingRate+padding*8;
	}
	//开始播放 
	function start(_mp3Info){
		mp3Info = _mp3Info;
		decodeAudioData(0,cacheFrameSize,true);
	}
	//解码
	function decodeAudioData(index,minSize,negative){
		if(index >= indexSize){
			return;
		}
		stopDecode = true;
		if(audioContext && audioContext.state=='running' && (!nowSouceNode || nowSouceNode && nowSouceNode.finished)){
			//加载中
		}
		loadFrame(index,minSize,negative).then(function(result){
			if(!audioContext){
				audioContext = new AudioContext();
				audioContext.onstatechange = function() {
				  console.log(audioContext.state);
				}
			}else if(audioContext.state=='suspend'){
				audioContext.resume();
			}
			if(!nowSouceNode || nowSouceNode && nowSouceNode.finished){
				//解码中
			}
			audioContext.decodeAudioData(result.arrayBuffer, function(buffer) { //解码成功则调用此函数，参数buffer为解码后得到的结果
		    	var audioBufferSouceNode = audioContext.createBufferSource();
		    	audioBufferSouceNode.connect(audioContext.destination);
			    audioBufferSouceNode.buffer = buffer;
			    audioBufferSouceNode.beginIndex = result.beginIndex;
			    audioBufferSouceNode.endIndex = result.endIndex;
			    souceNodeQueue.push(audioBufferSouceNode);
			    stopDecode = false;
			    if(!hasPlayed){
			    	hasPlayed = true;
			    	audioBufferSouceNode.start(0);
			    	souceNodeQueue.shift();
			    	nowSouceNode = audioBufferSouceNode;
			    	startPlayInterval(buffer);
			    }
			    //解码接下来要播放的音频数据
		    	if(!stopDecode && audioBufferSouceNode.endIndex+1<indexSize){
		    		setTimeout(function(){
		    			decodeAudioData(audioBufferSouceNode.endIndex+1,minSize);
		    		},100);
		    	}
			    function startPlayInterval(buffer){
			    	clearInterval(playIntervalId);
			    	beginTime = audioContext.currentTime;
			    	playIntervalId = setInterval(function(){
				    	if(audioContext.state!='running')
				    		return;
				    	//该分区播放完前100ms，开始播放
				    	if((audioContext.currentTime-beginTime)*1000+500 >= buffer.duration*100){
				    		if(souceNodeQueue.length>0){
				    			var souceNode = souceNodeQueue.shift();
					    		var startTime = buffer.duration-(audioContext.currentTime-beginTime);
					    		startTime = startTime>0?startTime:0;
					    		souceNode.start(startTime);
					    		nowSouceNode = souceNode;
			    				startPlayInterval(souceNode.buffer,souceNode);
				    		}
				    	}
				    },20);
			    }
			    
				audioBufferSouceNode.onended =  (function(audioBufferSouceNode){
					return function(){
						audioBufferSouceNode.finished = true;
						audioBufferSouceNode.disconnect();
						clearInterval(playIntervalId);
						if(audioBufferSouceNode.endIndex == indexSize-1){
							audioContext.suspend();
							//释放资源
							souceNodeQueue = [];
							playedSouceNodeQueue = [];
						}
					}
			    })(audioBufferSouceNode);
		    }, function(e) { //这个是解码失败会调用的函数
		        console.log(index,"!哎玛，文件解码失败:(");
		    });
		});
	}
	//获取数据帧
	function loadFrame(index,minSize,negative){
		var begin = 0;
		var end = 0;
		var cached = true;
		index = index>=indexSize?indexSize-1:index;
		for(var i=index; i<index+minSize && i<indexSize; i++){
			if(!fileBlocks[i]){
				cached = false;
			}
		}
		//已经缓存偶
		if(cached){
			var arr = null;
			var result = null;
			var length = 0;
			result = joinNextCachedFileBlock(index,minSize,negative);
			return new Promise(function(resolve){
				resolve(result);
			})
		}

		if(mp3Info.toc!=null){
			begin = (mp3Info.toc[index]/256*fileSize)>>0;
			end = (mp3Info.toc[index+minSize]/256*fileSize)>>0;
			end = end>=fileSize ? fileSize : end;
		}else{
			begin = (mp3Info.frameSize*index+headerLength)>>0;
			end = (begin+mp3Info.frameSize*minSize)>>0;
			end = end>=fileSize ? fileSize : end;
		}

		return new Promise(function(resolve,reject){
			var request = new XMLHttpRequest();
		    request.open('GET', url, true);
		    request.responseType = 'arraybuffer';
		   
		    request.onload = function() {
		        var arrayBuffer = request.response;
		        var begin = 0;
		        var end = 0;
		        //缓存数据块
		        for(var i=index; i<index+minSize && i<indexSize; i++){
		        	if(mp3Info.toc){//VBR编码模式
		        		end = begin+(mp3Info.toc[i+1]/256*fileSize - mp3Info.toc[i]/256*fileSize)>>0;
		        		fileBlocks[i] = arrayBuffer.slice(begin,end);
		        		begin = end;
		        	}else{//CBR编码模式
		        		end = begin+mp3Info.frameSize;
		        		fileBlocks[i] = arrayBuffer.slice(begin,end);
		        		begin = end;
		        	}
		        }
		        resolve(joinNextCachedFileBlock(index,minSize,negative));
		        loadFrame(index+minSize,minSize);
		    }
		    request.setRequestHeader("Range","bytes="+begin+'-'+(end-1));
		    request.send();
		});

	}
	//合并index索引之后所有连续的已经缓存过的分区
	function joinNextCachedFileBlock(index,minSize,negative){
		var length = 0;
		var arr = null;
		var result = null;
		var endIndex = index;
		var indexLength = fileBlocks.length;

		//消极情况下只返回minSize个数据块
		if(negative){
			indexLength = index+minSize;
		}

		for(var i=index; i<indexLength && fileBlocks[i]; i++){
			length += fileBlocks[i].byteLength;
			endIndex = i;
		}

		result = new ArrayBuffer(length);
		arr = new Uint8Array(result);
		length = 0;

		for(i=index; i<=endIndex; i++){
			arr.set(new Uint8Array(fileBlocks[i]),length);
			length += fileBlocks[i].byteLength;
		}

		return {
			arrayBuffer: result,
			beginIndex: index,
			endIndex: endIndex
		}

	}

	//跳转某个索引
	function seek(index){
		clearInterval(playIntervalId);
		hasPlayed = false;
		if(nowSouceNode){
			nowSouceNode.disconnect();
			nowSouceNode = null;
		}
		souceNodeQueue = [];
		decodeAudioData(index,cacheFrameSize,true);
	}

	document.getElementById("myRange").onchange = function(){
		var percent = document.getElementById("myRange").value;
		document.getElementById("per").innerHTML = percent;
		seek(parseInt(percent));
	}
</script>
</body>
</html>