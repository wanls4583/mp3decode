<!DOCTYPE html>
<html>

<head>
    <title>test2</title>
</head>

<body>
    <script type="text/javascript">
    var audioContext = new(AudioContext || WebkitAudioContext)();
    var myArrayBuffer;
    
    	new Promise(function(resolve){
    		load(162582, 1657200, function(arrayBuffer) {
		    	console.log(1,arrayBuffer.byteLength);
		    	var endExtraLength = _getExtraLength(arrayBuffer,true);
		    	var extraBuffer = arrayBuffer.slice(arrayBuffer.byteLength - endExtraLength );
		    	arrayBuffer = arrayBuffer.slice(0, arrayBuffer.byteLength - endExtraLength)
		        // 音频二进制数据解码
		        audioContext.decodeAudioData(arrayBuffer, function(buffer) {

		            var data0 = buffer.getChannelData(0);
		            var data1 = buffer.getChannelData(1);
		            myArrayBuffer = audioContext.createBuffer(2, buffer.length * 3, buffer.sampleRate);
		            myArrayBuffer.copyToChannel(data0, 0, 0)
		            myArrayBuffer.copyToChannel(data1, 1, 0)

		            var length = buffer.length;
		            resolve({
		            	length: length,
		            	extraBuffer: extraBuffer
		            })
		            
		        });
		    })
    	}).then(function(obj){
    		load(1657201, 3161820, function(_arrayBuffer) {
            	console.log(3,_arrayBuffer.byteLength);
            	arrayBuffer = new ArrayBuffer(_arrayBuffer.byteLength+obj.extraBuffer.byteLength);
            	var uint8Array = new Uint8Array(arrayBuffer);
            	var extraUint8Array = new Uint8Array(obj.extraBuffer);
            	var _arr = new Uint8Array(_arrayBuffer);
                uint8Array.set(extraUint8Array, 0);
                uint8Array.set(_arr, obj.extraBuffer.byteLength);
                console.log(4,arrayBuffer.byteLength);

                audioContext.decodeAudioData(arrayBuffer, function(buffer) {
                    var data0 = buffer.getChannelData(0);
                    var data1 = buffer.getChannelData(1);
                    // 实现重复播放两遍
                    myArrayBuffer.copyToChannel(data0, 0, obj.length)
                    myArrayBuffer.copyToChannel(data1, 1, obj.length)
                    // 用于控制音频的播放
                    var bufferSourceNode = audioContext.createBufferSource();
                    // 将解码后PCM（设备可直接播放的数据流）流赋值给buffer属性
                    bufferSourceNode.buffer = myArrayBuffer;
                    // 将播放节点连接到播放设备
                    bufferSourceNode.connect(audioContext.destination);
                    // 播放
                    bufferSourceNode.start(0, 60);
                    var begin = new Date().getTime();
                    bufferSourceNode.onended = function() {
                        console.log('end', new Date().getTime() - begin);
                    }
                })
            })
    	})
    

    function load(begin, end, cb) {
        var request = new XMLHttpRequest();
        request.open('GET', 'cbr.mp3', true);
        request.responseType = 'arraybuffer';
        request.onload = function() {
            var arrayBuffer = request.response;
            cb(arrayBuffer);
        }
        request.setRequestHeader("Range", 'bytes=' + begin + '-' + end);
        request.send();
    }

    function _getExtraLength(arrayBuffer, reverse) {
        var frameHeaderFlag = 'FFFB';
        var i = 0;
        var count = 200;
        var bufferStr = '';
        var uint8Array = new Uint8Array(arrayBuffer);
        if (!reverse) {
            while (true) {
                for (; i < count && i < uint8Array.length; i++) {
                    if (uint8Array[i] <= 15) {
                        bufferStr += '0' + uint8Array[i].toString(16);
                    } else {
                        bufferStr += uint8Array[i].toString(16);
                    }
                }
                bufferStr = bufferStr.toUpperCase();
                if (bufferStr.indexOf(frameHeaderFlag) != -1) {
                    return bufferStr.indexOf(frameHeaderFlag) / 2;
                }
                if (i >= uint8Array.length) {
                    return 0;
                }
                count += 200;
            }
        } else {
            i = uint8Array.length - 1;
            count = uint8Array.length - 200;
            while (true) {
                for (; i > count && i > 0; i--) {
                    if (uint8Array[i] <= 15) {
                        bufferStr = '0' + uint8Array[i].toString(16) + bufferStr;
                    } else {
                        bufferStr = uint8Array[i].toString(16) + bufferStr;
                    }
                }
                bufferStr = bufferStr.toUpperCase();
                if (bufferStr.indexOf(frameHeaderFlag) != -1) {
                    return bufferStr.length / 2 - bufferStr.indexOf(frameHeaderFlag) / 2;
                }
                if (i == 0) {
                    return 0;
                }
                count -= 200;
            }
        }
    }

    </script>
</body>

</html>
