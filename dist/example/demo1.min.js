/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 23);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var Mad = {};

Mad.Error = {
    NONE: 0x0000, /* no error */

    BUFLEN: 0x0001, /* input buffer too small (or EOF) */
    BUFPTR: 0x0002, /* invalid (null) buffer pointer */

    NOMEM: 0x0031, /* not enough memory */

    LOSTSYNC: 0x0101, /* lost synchronization */
    BADLAYER: 0x0102, /* reserved header layer value */
    BADBITRATE: 0x0103, /* forbidden bitrate value */
    BADSAMPLERATE: 0x0104, /* reserved sample frequency value */
    BADEMPHASIS: 0x0105, /* reserved emphasis value */

    BADCRC: 0x0201, /* CRC check failed */
    BADBITALLOC: 0x0211, /* forbidden bit allocation value */
    BADSCALEFACTOR: 0x0221, /* bad scalefactor index */
    BADMODE: 0x0222, /* bad bitrate/mode combination */
    BADFRAMELEN: 0x0231, /* bad frame length */
    BADBIGVALUES: 0x0232, /* bad big_values count */
    BADBLOCKTYPE: 0x0233, /* reserved block_type */
    BADSCFSI: 0x0234, /* bad scalefactor selection info */
    BADDATAPTR: 0x0235, /* bad main_data_begin pointer */
    BADPART3LEN: 0x0236, /* bad audio data length */
    BADHUFFTABLE: 0x0237, /* bad Huffman table select */
    BADHUFFDATA: 0x0238, /* Huffman data overrun */
    BADSTEREO: 0x0239 /* incompatible block_type for JS */
};
Mad.BUFFER_GUARD = 8;
Mad.BUFFER_MDLEN = 511 + 2048 + Mad.BUFFER_GUARD;
Mad.Layer = {
    I: 1,
    II: 2,
    III: 3
};
Mad.Mode = {
    SINGLE_CHANNEL: 0,
    DUAL_CHANNEL: 1, /* dual channel */
    JOINT_STEREO: 2, /* joint (MS/intensity) stereo */
    STEREO: 3 /* normal LR stereo */
};
Mad.Emphasis = {
    NONE: 0, /* no emphasis */
    _50_15_US: 1, /* 50/15 microseconds emphasis */
    CCITT_J_17: 3, /* CCITT J.17 emphasis */
    RESERVED: 2 /* unknown emphasis */
};
Mad.Flag = {
    NPRIVATE_III: 0x0007, /* number of Layer III private bits */
    INCOMPLETE: 0x0008, /* header but not data is decoded */

    PROTECTION: 0x0010, /* frame has CRC protection */
    COPYRIGHT: 0x0020, /* frame is copyright */
    ORIGINAL: 0x0040, /* frame is original (else copy) */
    PADDING: 0x0080, /* frame has additional slot */

    I_STEREO: 0x0100, /* uses intensity joint stereo */
    MS_STEREO: 0x0200, /* uses middle/side joint stereo */
    FREEFORMAT: 0x0400, /* uses free format bitrate */

    LSF_EXT: 0x1000, /* lower sampling freq. extension */
    MC_EXT: 0x2000, /* multichannel audio extension */
    MPEG_2_5_EXT: 0x4000 /* MPEG 2.5 (unofficial) extension */
};
Mad.Private = {
    HEADER: 0x0100, /* header private bit */
    III: 0x001f /* Layer III private bits (up to 5) */
};
Mad.count1table_select = 0x01;
Mad.scalefac_scale = 0x02;
Mad.preflag = 0x04;
Mad.mixed_block_flag = 0x08;
Mad.I_STEREO = 0x1;
Mad.MS_STEREO = 0x2;

Mad.sbsampleIndex = function (i, j, k) {
    return i * 36 * 32 + j * 32 + k;
};

Mad.overlapIndex = function (i, j, k) {
    return i * 32 * 18 + j * 18 + k;
};

Mad.recoverable = function (error) {
    return (error & 0xff00) != 0;
};

// credit: http://blog.stevenlevithan.com/archives/fast-string-multiply
Mad.mul = function (str, num) {
    var i = Math.ceil(Math.log(num) / Math.LN2),
        res = str;
    do {
        res += res;
    } while (0 < --i);
    return res.slice(0, str.length * num);
};

Mad.memcpy = function (dst, dstOffset, src, srcOffset, length) {
    // this is a pretty weird memcpy actually - it constructs a new version of dst, because we have no other way to do it
    return dst.slice(0, dstOffset) + src.slice(srcOffset, srcOffset + length) + dst.slice(dstOffset + length);
};

Mad.rshift = function (num, bits) {
    return Math.floor(num / Math.pow(2, bits));
};

Mad.lshiftU32 = function (num, bits) {
    return Mad.bitwiseAnd(Mad.lshift(num, bits), 4294967295 /* 2^32 - 1 */);
};

Mad.lshift = function (num, bits) {
    return num * Math.pow(2, bits);
};

Mad.bitwiseOr = function (a, b) {
    var w = 2147483648; // 2^31

    var aHI = a / w << 0;
    var aLO = a % w;
    var bHI = b / w << 0;
    var bLO = b % w;

    return (aHI | bHI) * w + (aLO | bLO);
};

Mad.bitwiseAnd = function (a, b) {
    var w = 2147483648; // 2^31

    var aHI = a / w << 0;
    var aLO = a % w;
    var bHI = b / w << 0;
    var bLO = b % w;

    return (aHI & bHI) * w + (aLO & bLO);
};

/* harmony default export */ __webpack_exports__["a"] = (Mad);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * bit流模块
 */
function BitStream(arrayBuffer) {
    if (arrayBuffer instanceof ArrayBuffer) {
        this._uint8Array = new Uint8Array(arrayBuffer);
    } else if (typeof arrayBuffer == 'number') {
        arrayBuffer = new ArrayBuffer(arrayBuffer);
        this._uint8Array = new Uint8Array(arrayBuffer);
    } else {
        throw Error('参数错误');
    }
    this._bytePos = 0; //当前bit位置
    this._bitPos = 0; //当前字节位置
    this.buffer = arrayBuffer;
    this.end = 0;
}
var _proto_ = BitStream.prototype;
/**
 * 返回buffer
 * @return  arraybuffer
 */
_proto_.getBuffer = function () {
    return this._uint8Array.buffer;
},
/**
 * 获取len个bit位
 * @param  number len bit长度
 * @return  number 整数
 */
_proto_.getBits = function (len) {
    var sum = 0;
    var byte = 0;
    if (this._bytePos >= this._uint8Array.length) return false;
    for (var i = 0; i < len && this._bytePos < this._uint8Array.length; i++) {
        byte = this._uint8Array[this._bytePos];
        sum = sum << 1 | byte >> 7 - this._bitPos & 1;
        this._bitPos++;
        if (this._bitPos % 8 == 0) {
            this._bytePos++;
            this._bitPos = 0;
        }
    }
    return sum;
};
/**
 * 获取1个bit位
 * @return  number 0|1
 */
_proto_.getBits1 = function (len) {
    if (this._bytePos >= this._uint8Array.length) return false;
    var bit = this._uint8Array[this._bytePos] >> 7 - this._bitPos & 1;
    this._bitPos++;
    if (this._bitPos % 8 == 0) {
        this._bytePos++;
        this._bitPos = 0;
    }
    return bit;
};
/**
 * 获取1个字节
 * @return  number 0|1
 */
_proto_.getByte = function () {
    if (this._bytePos >= this._uint8Array.length) return false;
    var byte = this._uint8Array[this._bytePos];
    this._bytePos++;
    return byte;
};
/**
 * 获取len个bit位二进制字符串
 * @param  number len bit长度
 * @param  boolean zeroize 头部是否补0
 * @return  string 二进制字符串
 */
_proto_.getBitsStr = function (len, zeroize) {
    var str = this.getBits(len).toString(2);
    if (str.legnth < len) {
        var zeros = '';
        for (var i = 0; i < len - str.length; i++) {
            zeros += '0';
        }
        str = zeros + str;
    }
    return str;
};
/**
 * 返回字节位置
 * @retrun  number pos 位置
 */
_proto_.getBytePos = function (pos) {
    return this._bytePos;
};
/**
 * 返回bit位置
 * @retrun  number pos 位置
 */
_proto_.getBitPos = function (pos) {
    return this._bitPos;
};
/**
 * 设置字节位置
 * @param  number pos 位置
 */
_proto_.setBytePos = function (pos) {
    if (pos > this._uint8Array.length) {
        pos = this._uint8Array.length;
    }
    this._bytePos = pos;
};
/**
 * 设置bit位置
 * @param  number pos 位置
 */
_proto_.setBitPos = function (pos) {
    this._bitPos = pos % 8;
};
/**
 * 设置一位bit
 */
_proto_.setBit = function (bytePos, bitPos, bit) {
    var byte = bit << bitPos & 0xff;
    if (bytePos >= this._uint8Array.length) {
        return;
    }
    this._uint8Array[bytePos] = this._uint8Array[bytePos] & byte;
};
/**
 * 设置一位bit
 */
_proto_.setByte = function (bytePos, byte) {
    if (bytePos >= this._uint8Array.length) {
        return;
    }
    this._uint8Array[bytePos] = byte;
};
/**
 * 跳过len个bit
 */
_proto_.skipBits = function (len) {
    this._bytePos = this._bytePos + ((this._bitPos + len) / 8 >> 0);
    this._bitPos = (this._bitPos + len) % 8;
    if (this._bytePos > this._uint8Array.length) {
        this._bytePos = this._uint8Array.length;
    }
};
/**
 * 跳过len个byte
 */
_proto_.skipBytes = function (len) {
    this._bytePos = this._bytePos + len;
    if (this._bytePos > this._uint8Array.length) {
        this._bytePos = this._uint8Array.length;
    }
};
/**
 * 回退len个bit
 */
_proto_.rewindBits = function (len) {
    this._bitPos = this._bitPos - len;
    if (this._bitPos < 0) {
        this._bitPos = 0;
    }
};
/**
 * 回退len个byte
 */
_proto_.rewindBytes = function (len) {
    this._bytePos = this._bytePos - len;
    if (this._bytePos < 0) {
        this._bytePos = 0;
    }
};
/**
 * 在尾部添加字节
 * @return  返回新的buffer
 */
_proto_.append = function (arrayBuffer) {
    var newBuffer = new ArrayBuffer(this._uint8Array.length + arrayBuffer.length);
    this._uint8Array = new Uint8Array(newBuffer);
    this._uint8Array.set(arrayBuffer, this._uint8Array.length - arrayBuffer.length);
    return newBuffer;
};
/**
 * 在头部添加字节
 * @return  返回新的buffer
 */
_proto_.unshift = function (arrayBuffer) {
    var newBuffer = new ArrayBuffer(this._uint8Array.length + arrayBuffer.length);
    this._uint8Array = new Uint8Array(newBuffer);
    this._uint8Array.set(arrayBuffer, 0);
    return newBuffer;
};
/**
 * 是否已到达最后一个bit
 * @return  boolean
 */
_proto_.isEnd = function () {
    return this._bytePos >= this._uint8Array.length;
};
/**
 * 返回流字节个数
 * @return  number
 */
_proto_.getSize = function () {
    return this._uint8Array.length;
};
/**
 * 重头开始
 */
_proto_.reset = function () {
    this._bitPos = 0;
    this._bytePos = 0;
};
/**
 * 比特流数组截取
 * @param  {number} begin 开始索引
 * @param  {number} end   结束索引
 * @return {arrary}       比特流数组
 */
_proto_.slice = function (begin, end) {
    return this._uint8Array.slice(begin, end);
};
/**
 * 追加数据
 * @param  {object} byteArr 二进制数组
 */
_proto_.append = function (byteArr) {
    var tmp = new Uint8Array(this.getSize());
    if (this._bytePos > 0) {
        tmp.set(this._uint8Array.slice(this._bytePos), 0);
        tmp.set(byteArr, this.end);
    } else {
        tmp.set(byteArr, 0);
    }
    this.end = this._bytePos + byteArr.length; //有效数据尾
    this._uint8Array = tmp;
    this._bytePos = 0;
};

/* harmony default export */ __webpack_exports__["a"] = (BitStream);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * 分段下载
 * @param  {int}  begin  字节开始位置
 * @param  {int}  end  字节结束位置(包括)
 * @param  {Functio}  callback  成功回调
 */
function _loadRange(url, begin, end, opt) {
    var request = new XMLHttpRequest();
    var emptyCb = function () {};
    var onsuccess, onerror, onabort, ontimeout;
    onsuccess = onerror = onabort = ontimeout = emptyCb;
    begin = begin || 0;
    end = end || '';
    if (typeof opt == 'object') {
        opt.onsuccess && (onsuccess = opt.onsuccess);
        opt.onerror && (onerror = opt.onerror);
        opt.onabort && (onabort = opt.onabort);
        opt.ontimeout && (ontimeout = opt.ontimeout);
    }
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        var arrayBuffer = request.response;
        var contetnRange = request.getResponseHeader('Content-Range');

        if (contetnRange && contetnRange.split('/')[0].substr(6) != begin + '-' + end) {
            console.log(contetnRange.split('/')[0].substr(6), begin + '-' + end);
            console.error('获取头部信息出错');
            onerror('获取头部信息出错');
        } else {
            onsuccess(request);
        }
    };
    request.onerror = onerror;
    request.onabort = onabort;
    request.ontimeout = ontimeout;

    request.setRequestHeader("Range", 'bytes=' + begin + '-' + end);
    request.send();
    return request;
}

/* harmony default export */ __webpack_exports__["a"] = (_loadRange);

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var Util = {};

//ArrayBuffer转16进制字符串
Util.arrayBufferToHexChar = function (arrayBuffer) {
    var bufferStr = '';
    var uint8Array = new Uint8Array(arrayBuffer);
    for (var i = 0; i < uint8Array.length; i++) {
        if (uint8Array[i] <= 15) {
            bufferStr += '0' + uint8Array[i].toString(16);
        } else {
            bufferStr += uint8Array[i].toString(16);
        }
        bufferStr += ',';
    }
    return bufferStr.slice(0, bufferStr.length - 1);
};

/**
 * 根据同步标识返回相应数据长度
 * @param  {ArrayBuffer} arrayBuffer 音频源数据
 * @param  {String}      frameSync   16进制同步字符串标识
 * @param  {Number}      offset      正向查找时头部需要跳过的字节数
 * @param  {Boolean}     reverse     查找方向
 * @param  {Number}      frameSize   逆向查找时需要返回多少帧数据长度
 * @return {Number}                  数据长度
 */
Util.getLengthByFrameSync = function (arrayBuffer, frameSync, offset, reverse, frameSize) {
    var i = 0;
    var count = 200;
    var bufferStr = '';
    var uint8Array = new Uint8Array(arrayBuffer);
    offset = offset || 0;
    frameSize = frameSize || 1;
    if (!reverse) {
        while (true) {
            for (; i < count && i < uint8Array.length; i++) {
                if (uint8Array[i] <= 15) {
                    bufferStr += '0' + uint8Array[i].toString(16);
                } else {
                    bufferStr += uint8Array[i].toString(16);
                }
                bufferStr += ',';
            }
            bufferStr = bufferStr.toUpperCase();
            if (bufferStr.indexOf(frameSync, offset * 3) != -1) {
                return bufferStr.indexOf(frameSync, offset * 3) / 3;
            }
            if (i >= uint8Array.length) {
                return 0;
            }
            count += 200;
        }
    } else {
        var flagReg = new RegExp(frameSync, 'g');
        var match = null;
        i = uint8Array.length - 1;
        count = uint8Array.length - 200;
        while (true) {
            for (; i > count && i > 0; i--) {
                if (uint8Array[i] <= 15) {
                    bufferStr = '0' + uint8Array[i].toString(16) + ',' + bufferStr;
                } else {
                    bufferStr = uint8Array[i].toString(16) + ',' + bufferStr;
                }
            }
            bufferStr = bufferStr.toUpperCase();
            match = bufferStr.match(flagReg);
            if (match && match.length >= frameSize) {
                //找出多少帧
                return bufferStr.length / 3 - bufferStr.indexOf(frameSync) / 3;
            }
            if (i == 0) {
                return 0;
            }
            count -= 200;
        }
    }
};

Util.formatCountDown = function (seconds, noZero) {
    var date = new Date();
    date.setDate(0);
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setSeconds(seconds);
    var data = {
        date: Math.floor(seconds / (60 * 60 * 24)),
        hours: date.getHours(),
        minutes: date.getMinutes(),
        seconds: date.getSeconds()
    };
    if (!noZero) {
        data.date = data.date >= 10 ? data.date : '0' + data.date;
        data.hours = data.hours >= 10 ? data.hours : '0' + data.hours;
        data.minutes = data.minutes >= 10 ? data.minutes : '0' + data.minutes;
        data.seconds = data.seconds >= 10 ? data.seconds : '0' + data.seconds;
    }
    return data;
};

Util.ifDebug = function () {
    return location.href.indexOf('debug') > -1;
};

Util.log = function () {
    if (location.search.indexOf('audio-debug') > -1) {
        console.log.apply(window, arguments);
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Util);

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__stringstream__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__global__ = __webpack_require__(0);



// Well duh.
var CHAR_BIT = 8;

/*
 * NAME:    bit.init()
 * DESCRIPTION: initialize bit pointer struct
 */
var Bit = function (stream, offset) {
    if (typeof stream == 'string') {
        this.stream = new __WEBPACK_IMPORTED_MODULE_0__stringstream__["a" /* default */](stream);
    } else {
        this.stream = stream;
    }

    this.offset = offset;

    this.cache = 0;
    this.left = CHAR_BIT;
};

Bit.prototype.clone = function () {
    var c = new Bit(this.stream, this.offset);

    c.cache = this.cache;
    c.left = this.left;

    return c;
};

/*
 * NAME:    bit.length()
 * DESCRIPTION: return number of bits between start and end points
 */
Bit.prototype.length = function (end) {
    return this.left + CHAR_BIT * (end.offset - (this.offset + 1)) + (CHAR_BIT - end.left);
};

/*
 * NAME:    bit.nextbyte()
 * DESCRIPTION: return pointer to next unprocessed byte
 */
Bit.prototype.nextbyte = function () {
    return this.left == CHAR_BIT ? this.offset : this.offset + 1;
};

/*
 * NAME:    bit.skip()
 * DESCRIPTION: advance bit pointer
 */
Bit.prototype.skip = function (len) {
    this.offset += len / CHAR_BIT >> 0; // javascript trick to get integer divison
    this.left -= len % CHAR_BIT;

    if (this.left > CHAR_BIT) {
        this.offset++;
        this.left += CHAR_BIT;
    }

    if (this.left < CHAR_BIT) {
        this.cache = this.stream.getU8(this.offset);
    }
};

/*
 * NAME:    bit.read()
 * DESCRIPTION: read an arbitrary number of bits and return their UIMSBF value
 */
Bit.prototype.read = function (len) {
    if (len > 16) {
        return this.readBig(len);
    }

    var value = 0;

    if (this.left == CHAR_BIT) {
        this.cache = this.stream.getU8(this.offset);
    }

    if (len < this.left) {
        value = (this.cache & (1 << this.left) - 1) >> this.left - len;
        this.left -= len;

        return value;
    }

    /* remaining bits in current byte */
    value = this.cache & (1 << this.left) - 1;
    len -= this.left;

    this.offset++;
    this.left = CHAR_BIT;

    /* more bytes */
    while (len >= CHAR_BIT) {
        value = value << CHAR_BIT | this.stream.getU8(this.offset++);
        len -= CHAR_BIT;
    }

    if (len > 0) {
        this.cache = this.stream.getU8(this.offset);

        value = value << len | this.cache >> CHAR_BIT - len;
        this.left -= len;
    }

    return value;
};

Bit.prototype.readBig = function (len) {
    var value = 0;

    if (this.left == CHAR_BIT) {
        this.cache = this.stream.getU8(this.offset);
    }

    if (len < this.left) {
        value = (this.cache & (1 << this.left) - 1) >> this.left - len;
        this.left -= len;

        return value;
    }

    /* remaining bits in current byte */
    value = this.cache & (1 << this.left) - 1;
    len -= this.left;

    this.offset++;
    this.left = CHAR_BIT;

    /* more bytes */
    while (len >= CHAR_BIT) {
        value = __WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].bitwiseOr(__WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].lshift(value, CHAR_BIT), this.stream.getU8(this.offset++));
        len -= CHAR_BIT;
    }

    if (len > 0) {
        this.cache = this.stream.getU8(this.offset);

        value = __WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].bitwiseOr(__WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].lshift(value, len), this.cache >> CHAR_BIT - len);
        this.left -= len;
    }

    return value;
};

/* harmony default export */ __webpack_exports__["a"] = (Bit);

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ByteStream = function (url) {};

ByteStream.prototype.available = function (n) {
    return this.absoluteAvailable(this.state['offset'] + n);
};

ByteStream.prototype.getU8 = function (offset, bigEndian) {
    var bytes = this.get(offset, 1);

    return bytes.charCodeAt(0);
};

ByteStream.prototype.getU16 = function (offset, bigEndian) {
    var bytes = this.get(offset, 2);

    if (!bigEndian) {
        bytes = bytes.reverse();
    }

    return bytes.charCodeAt(0) << 8 | bytes.charCodeAt(1);
};

ByteStream.prototype.getU24 = function (offset, bigEndian) {
    var bytes = this.get(offset, 3);

    if (!bigEndian) {
        bytes = bytes.reverse();
    }

    return bytes.charCodeAt(0) << 16 | bytes.charCodeAt(1) << 8 | bytes.charCodeAt(2);
};

ByteStream.prototype.getU32 = function (offset, bigEndian) {
    var bytes = this.get(offset, 4);

    if (!bigEndian) {
        bytes = bytes.reverse();
    }

    return bytes.charCodeAt(0) << 24 | bytes.charCodeAt(1) << 16 | bytes.charCodeAt(2) << 8 | bytes.charCodeAt(3);
};

ByteStream.prototype.getI8 = function (offset, bigEndian) {
    return this.getU8(offset, bigEndian) - 128; // 2 ** 7
};

ByteStream.prototype.getI16 = function (offset, bigEndian) {
    return this.getU16(offset, bigEndian) - 65536; // 2 ** 15
};

ByteStream.prototype.getI32 = function (offset, bigEndian) {
    return this.getU32(offset, bigEndian) - 2147483648; // 2 ** 31
};

ByteStream.prototype.getSyncInteger = function (offset) {
    var bytes = this.get(offset, 4);

    return bytes.charCodeAt(0) << 21 | bytes.charCodeAt(1) << 14 | bytes.charCodeAt(2) << 7 | bytes.charCodeAt(3);
};

ByteStream.prototype.peekU8 = function (bigEndian) {
    return this.getU8(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekU16 = function (bigEndian) {
    return this.getU16(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekU24 = function (bigEndian) {
    return this.getU24(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekU32 = function (bigEndian) {
    return this.getU32(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekI8 = function (bigEndian) {
    return this.getI8(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekI16 = function (bigEndian) {
    return this.getI16(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekI32 = function (bigEndian) {
    return this.getI32(this.state['offset'], bigEndian);
};

ByteStream.prototype.peekSyncInteger = function () {
    return this.getSyncInteger(this.state['offset']);
};

ByteStream.prototype.readU8 = function (bigEndian) {
    var result = this.peekU8(bigEndian);

    this.seek(1);

    return result;
};

ByteStream.prototype.readU16 = function (bigEndian) {
    var result = this.peekU16(bigEndian);

    this.seek(2);

    return result;
};

ByteStream.prototype.readU24 = function (bigEndian) {
    var result = this.peekU24(bigEndian);

    this.seek(3);

    return result;
};

ByteStream.prototype.readU32 = function (bigEndian) {
    var result = this.peekU32(bigEndian);

    this.seek(4);

    return result;
};

ByteStream.prototype.readI8 = function (bigEndian) {
    var result = this.peekI8(bigEndian);

    this.seek(1);

    return result;
};

ByteStream.prototype.readI16 = function (bigEndian) {
    var result = this.peekI16(bigEndian);

    this.seek(2);

    return result;
};

ByteStream.prototype.readI32 = function (bigEndian) {
    var result = this.peekI32(bigEndian);

    this.seek(4);

    return result;
};

ByteStream.prototype.readSyncInteger = function () {
    var result = this.getSyncInteger(this.state['offset']);

    this.seek(4);

    return result;
};

/* harmony default export */ __webpack_exports__["a"] = (ByteStream);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_bitstream__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_util__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__header__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__id3tag__ = __webpack_require__(20);
/**
 * MP3音频信息解析模块
 * http://wiki.hydrogenaud.io/index.php?title=APEv2_specification
 * http://www.docin.com/p-1261649617.html
 * https://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header
 *
 * audioInfo需要包括的字段:{
 *      fileSize: 音频文件大小(byte),
 *      frameSync: 同步头（16进制字符串）,
 *      duration: 总时长（秒）,
 *      sampleRate: 采样率,
 *      audioDataOffset: audioData开始偏移量（相对于0字节位置）,
 *      totalSize: audioData总大小（仅当音频码率模式为VBR时返回）,
 *      toc: 音频数据索引表（仅当音频码率模式为VBR时返回）   
 * }
 */







//MP3播放信息解析对象
var MP3Info = {
    init: function (url, opt) {
        var self = this;
        var emptyFun = function () {};
        this.url = url;
        this.decrypt = this.onloadedmetadata = emptyFun;
        this.indexSize = 100; //分区数，默认100
        this.audioInfo = {}; //存储mp3相关的信息
        if (typeof opt == 'object') {
            opt.decrypt && (this.decrypt = opt.decrypt);
            opt.onloadedmetadata && (this.onloadedmetadata = opt.onloadedmetadata);
            opt.indexSize && (this.indexSize = opt.indexSize);
        }
        return new Promise(function (resolve, reject) {
            self._loadHeaderInfo(resolve, reject);
        }).then(function () {
            return self._loadFirstFrame();
        }).then(function (arrayBuffer) {
            var header = new __WEBPACK_IMPORTED_MODULE_3__header__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_1__common_bitstream__["a" /* default */](arrayBuffer));
            var result = header.parseHeader(true);
            if (result) {
                self.audioInfo.toc = header.toc;
                self.audioInfo.totalSize = header.totalBytes;
                self.audioInfo.sampleRate = header.sampleRate;
                self.audioInfo.frameSync = header.frameSync;
                self.audioInfo.duration = header.totalDuration;
                self.audioInfo.bitRate = header.bitRate;
                if (!self.audioInfo.toc) {
                    //cbr模式
                    return self._getFooterLength();
                } else {
                    self.onloadedmetadata(self.audioInfo.duration);
                    return self.audioInfo;
                }
            } else {
                return false;
            }
        });
    },
    //ajax获取音频头部标签头(32B)
    _loadHeaderInfo: function (resolve, reject) {
        var self = this;
        Object(__WEBPACK_IMPORTED_MODULE_0__common_range__["a" /* default */])(self.url, 0, 32 * 8 + 32 * 8 - 1, {
            onsuccess: function (request) {
                //加载前32个字节（判断是否存在ID3V2|Ape头）
                var arrayBuffer = request.response;
                var contetnRange = request.getResponseHeader('Content-Range');
                var length = 0;
                var id3tag = null;
                self.decrypt(arrayBuffer); //解密
                id3tag = new __WEBPACK_IMPORTED_MODULE_4__id3tag__["a" /* default */](arrayBuffer);
                self.audioInfo.audioDataOffset = id3tag.parseId3V2() + id3tag.parseApe();
                self.audioInfo.fileSize = parseInt(contetnRange.substr(contetnRange.indexOf('/') + 1));
                resolve();
            }
        });
    },
    //加载第一个数据帧(用来判断音频码率模式)
    _loadFirstFrame: function (resolve, reject) {
        var self = this;
        return new Promise(function (resolve, reject) {
            Object(__WEBPACK_IMPORTED_MODULE_0__common_range__["a" /* default */])(self.url, self.audioInfo.audioDataOffset, self.audioInfo.audioDataOffset + 156 * 8 - 1, {
                onsuccess: function (request) {
                    var arrayBuffer = request.response;
                    self.decrypt(arrayBuffer); //解密
                    resolve(arrayBuffer);
                }
            });
        });
    },
    //获取尾部额外信息长度（可能存在id3v1或者ape信息）
    _getFooterLength: function () {
        var self = this;
        return new Promise(function (resolve, reject) {
            Object(__WEBPACK_IMPORTED_MODULE_0__common_range__["a" /* default */])(self.url, self.audioInfo.fileSize - (128 + 32), self.audioInfo.fileSize - 1, {
                onsuccess: function (request) {
                    var arrayBuffer = request.response;
                    var id3tag = null;
                    var length = 0;
                    self.decrypt(arrayBuffer); //解密
                    id3tag = new __WEBPACK_IMPORTED_MODULE_4__id3tag__["a" /* default */](arrayBuffer);
                    self.audioInfo.footerLength = id3tag.parseId3V1() + id3tag.parseApe();
                    self.audioInfo.totalSize = self.audioInfo.fileSize - self.audioInfo.audioDataOffset - self.audioInfo.footerLength;
                    self.audioInfo.duration = self.audioInfo.totalSize * 8 / self.audioInfo.bitRate;
                    self.onloadedmetadata(self.audioInfo);
                    resolve(self.audioInfo);
                }
            });
        });
    }
};

/* harmony default export */ __webpack_exports__["a"] = (MP3Info);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_audiocontext_player__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_mediasource_player__ = __webpack_require__(21);



function Player(url, opt){
	if(opt.usemediasource){
		return new __WEBPACK_IMPORTED_MODULE_1__src_mediasource_player__["a" /* default */](url, opt);
	}else{
		return new __WEBPACK_IMPORTED_MODULE_0__src_audiocontext_player__["a" /* default */](url, opt);
	}
}

window.Player = Player;

/* harmony default export */ __webpack_exports__["a"] = (Player);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_util__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_bitstream__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__decoder_decoder__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mp3info_mp3info__ = __webpack_require__(6);
/**
 * 音频播放器模块
 * AudioContext wiki: https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext
 */







var indexSize = 100; //区块个数（根据时间平均分为100份,默认100）
var url = ''; //音频链接
var emptyUrl = ''; //空音频链接（用于触发IOS上音频播放）
var emptyCb = function () {};
var onbeforedecode = emptyCb;
var ontimeupdate = emptyCb;
var onplay = emptyCb;
var onpause = emptyCb;
var onwaiting = emptyCb;
var onplaying = emptyCb;
var onended = emptyCb;
var onloadedmetadata = emptyCb;
var onerror = emptyCb;
var maxDecodeSize = 0.1 * 1024 * 1024; // 最大解码字节长度(默认8M)
var isIos = navigator.userAgent.indexOf('iPhone') > -1;
var AudioInfo = null;
var audio = null;
if (isIos) {
    audio = new Audio();
    audio.src = opt.emptyUrl;
}

function Player() {
    this.timeoutIds = {
        decodeTimeoutId: null, //解码计时器
        updateIntervalId: null, //时间更新计时器
        playTimoutId: null, //播放计时器
        reloadTimeoutId: null //加载失败后重加载计时器
    };
}

Player.prototype._init = function (audioInfo) {
    var self = this;
    this.audioInfo = audioInfo; //音频信息
    this.bufferLength = 0; //音频全部解码后总大小
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); //音频上下文对象
    this.audioContext.onstatechange = function () {
        if (self.audioContext) {
            if (self.audioContext.state != 'running') {
                self.isPlaying = false;
            }
            __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log(self.audioContext.state);
        }
    };
    this.decoder = new __WEBPACK_IMPORTED_MODULE_3__decoder_decoder__["a" /* default */]();
    this.fileBlocks = new Array(100); //音频数据分区
    this.cacheFrameSize = 0; //每次加载的分区数
    this.indexSize = 100; //索引个数
    this.seeking = true; //是否正在索引
    this.totalBuffer = null; //音频资源节点队列
    this.nowSouceNode = null; //正在播放的资源节点
    this.loadingPromise = null; //数据加载异步对象集合
    if (audioInfo.fileSize / indexSize > 1024 * 1024) {
        //1/100总数据大小是否大于1M
        this.cacheFrameSize = 1;
    } else {
        this.cacheFrameSize = Math.ceil(1024 * 1024 / (audioInfo.fileSize / indexSize));
    }
    if (this.audioInfo) {
        this._decodeAudioData(0, this.cacheFrameSize, true, this.totalBuffer);
    }
};

//解码
Player.prototype._decodeAudioData = function (index, minSize, negative, beginDecodeTime) {
    var self = this;
    var audioInfo = this.audioInfo;
    if (index >= indexSize) {
        return;
    }
    return this._loadFrame(index, minSize, negative).then(function (result) {
        if (beginDecodeTime != self.beginDecodeTime || !result) {
            //see时强制停止
            return false;
        }
        __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('解码:' + result.beginIndex + ',' + result.endIndex);
        if (__WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].ifDebug()) {
            var decodeBeginTime = new Date().getTime();
        }
        var redoCount = 0;
        var arrayBuffer = result.arrayBuffer;
        var beginIndex = result.beginIndex;
        var endIndex = result.endIndex;
        if (negative) {
            self.decoder.kill();
        }
        self.decoder.decode({
            onsuccess: _onsuccess,
            onerror: _onerror,
            arrayBuffer: arrayBuffer,
            beginIndex: beginIndex,
            endIndex: endIndex
        });
        /**
         * 解码成功回调
         * @param  {AudioBuffer} buffer PCM数据
         */
        function _onsuccess(buffer) {
            //防止seek时，之前未完成的异步解码对新队列的影响
            if (beginDecodeTime != self.beginDecodeTime) {
                return;
            }
            if (!self.bufferLength) {
                self.bufferLength = Math.ceil(audioInfo.duration * buffer.sampleRate);
            }
            if (!self.numberOfChannels) {
                self.numberOfChannels = buffer.numberOfChannels;
            }
            if (!self.sampleRate) {
                self.sampleRate = buffer.sampleRate;
            }
            if (!self.totalBuffer) {
                self.totalBuffer = self.audioContext.createBuffer(self.numberOfChannels, self.bufferLength, self.sampleRate);
            }
            __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('解码完成:' + result.beginIndex + ',' + result.endIndex, 'duration:', buffer.duration);
            __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('解码花费:', new Date().getTime() - decodeBeginTime, 'ms');
            if (self.seeking) {
                self.preBuffer = null;
                self.seeking = false;
                self.totalBuffer.dataOffset = self.totalBuffer.dataBegin = self.totalBuffer.dataEnd = self.totalBuffer.length * result.beginIndex / indexSize >> 0;
                self._copyPCMData(buffer);
                if (self.hasPlayed && !self.pause) {
                    self._play(self.totalBuffer.dataBegin / self.totalBuffer.length * audioInfo.duration);
                }
            } else {
                self._copyPCMData(buffer);
                if (self.waiting) {
                    self.waiting = false;
                    if (!self.pause) {
                        //从等待状态唤醒
                        self.audioContext.resume();
                        onplaying();
                    }
                }
            }
            self.totalBuffer.endIndex = result.endIndex;
            if (result.endIndex + 1 < indexSize) {
                var nextDecodeTime = buffer.duration * 1000 / 2;
                if (nextDecodeTime > 10000) {
                    nextDecodeTime = 10000;
                }
                clearTimeout(self.timeoutIds.decodeTimeoutId);
                self.timeoutIds.decodeTimeoutId = setTimeout(function () {
                    if (self.loadingPromise) {
                        self.loadingPromise.stopNextLoad = true;
                        self.loadingPromise.then(function () {
                            _nextDecode(result, self.totalBuffer, minSize, audioInfo);
                        });
                    } else {
                        _nextDecode(result, self.totalBuffer, minSize, audioInfo);
                    }
                }, nextDecodeTime);
            }
        }
        //解码失败回调
        function _onerror() {
            if (beginDecodeTime != self.beginDecodeTime) {
                return;
            }
            //最多重试3次
            if (redoCount > 5) {
                return;
            }
            redoCount++;
            __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('decode fail...redo', redoCount);
            arrayBuffer = arrayBuffer.slice(100);
            arrayBuffer = self._fixFileBlock(arrayBuffer);
            self.decoder.decode({
                onsuccess: _onsuccess,
                onerror: _onerror,
                arrayBuffer: arrayBuffer,
                beginIndex: beginIndex,
                endIndex: endIndex
            });
        }

        function _nextDecode(result, totalBuffer, minSize, audioInfo) {
            if (!result.exceed) {
                self._decodeAudioData(result.beginIndex, result.endIndex - result.beginIndex + 1 + self.cacheFrameSize, null, beginDecodeTime);
            } else {
                totalBuffer.dataOffset = totalBuffer.dataEnd;
                self._decodeAudioData(result.endIndex + 1, self.cacheFrameSize, null, beginDecodeTime);
            }
        }
        return result;
    });
};

//复制PCM流
Player.prototype._copyPCMData = function (_buffer) {
    var offset = this.totalBuffer.dataOffset;
    for (var i = 0; i < _buffer.numberOfChannels; i++) {
        var cData = _buffer.getChannelData(i);
        if (cData.length + offset > this.totalBuffer.length) {
            cData = cData.slice(0, cData.length + offset - this.totalBuffer.length);
        }
        this.totalBuffer.getChannelData(i).set(cData, offset);
    }
    this.totalBuffer.dataEnd = offset + _buffer.length;

    //展示前后衔接处波形图，帮助分析
    // if (this.preBuffer) {
    //     var d1 = this.preBuffer.getChannelData(0).slice(-1152 * 2);
    //     var d2 = _buffer.getChannelData(0).slice(0, 1152 * 2);
    //     var ctx = document.querySelector('#canvas').getContext("2d");
    //     ctx.clearRect(0, 0, ctx.canvas.width, 200);
    //     ctx.beginPath();
    //     ctx.moveTo(0, 100);
    //     for (var i = 0; i < d1.length; i++) {
    //         var h = d1[i] * 100 + 100;
    //         ctx.lineTo(i, h);
    //     }
    //     ctx.strokeStyle = 'blue';
    //     ctx.stroke();
    //     ctx.closePath();

    //     ctx.beginPath();
    //     ctx.moveTo(d1.length - 1, h);
    //     for (var i = 0; i < d2.length; i++) {
    //         var h = d2[i] * 100 + 100;
    //         ctx.lineTo(i + d1.length, h);
    //     }
    //     ctx.strokeStyle = 'red';
    //     ctx.stroke();
    //     ctx.closePath();
    // }
    // this.preBuffer = _buffer;
};

//播放
Player.prototype._play = function (startTime) {
    var self = this;
    this.offsetTime = startTime;
    this.currentTime = Math.round(this.offsetTime);
    if (this.audioContext.state == 'suspended') {
        this.audioContext.resume();
    }
    if (this.nowSouceNode) {
        this.nowSouceNode.disconnect();
    }
    var sourceNode = this.audioContext.createBufferSource();
    sourceNode.buffer = this.totalBuffer;
    sourceNode.connect(this.audioContext.destination);
    sourceNode.onended = function () {
        self._end();
    };
    if (sourceNode.start) {
        sourceNode.start(0, startTime);
    } else {
        sourceNode.noteOn(0, startTime);
    }
    this.hasPlayed = true;
    this.nowSouceNode = sourceNode;
    this._startUpdateTimeoutId();
    this.isPlaying = true;
    __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('play');
};

//开始更新计时器
Player.prototype._startUpdateTimeoutId = function () {
    var self = this;
    clearInterval(this.timeoutIds.updateIntervalId);
    this.beginTime = this.audioContext.currentTime;
    this.timeoutIds.updateIntervalId = setInterval(function () {
        var time = self.audioContext.currentTime - self.beginTime;
        var currentTime = time + self.offsetTime;
        if (self.audioInfo.toc && currentTime > self.audioInfo.duration) {
            self._end();
        }
        if (Math.round(currentTime) > self.currentTime) {
            self.currentTime = Math.round(currentTime);
            ontimeupdate(self.currentTime); //时间更新计时器回调
        }
        //等待数据解码
        if (!self.waiting && self.totalBuffer.endIndex < indexSize - 1 && (currentTime + 2) * self.sampleRate > self.totalBuffer.dataEnd) {
            self.waiting = true;
            self.audioContext.suspend();
            onwaiting();
        }
    }, 1000);
};

Player.prototype._end = function () {
    this.nowSouceNode.disconnect();
    this.finished = true; //播放结束标识
    this._clearTimeout();
    this.audioContext.suspend();
    onended();
};

//获取数据帧
Player.prototype._loadFrame = function (index, minSize, negative) {
    var self = this;
    var begin = 0;
    var end = 0;
    var cached = true;
    var beginIndex = index; //避免网络加载重复数据
    var endIndex = 0;
    var originMinSize = minSize;
    var audioInfo = this.audioInfo;
    index = index >= indexSize ? indexSize - 1 : index;
    if (index + minSize > indexSize) {
        minSize = indexSize - index;
    }
    //防止头部加载重复数据
    for (var i = index; i < index + minSize; i++) {
        if (!this.fileBlocks[i]) {
            cached = false;
            beginIndex = i;
            minSize = minSize - (beginIndex - index);
            break;
        }
    }
    //对应索引区数据已经缓存
    if (cached) {
        var arr = null;
        var result = null;
        var length = 0;
        result = this._joinNextCachedFileBlock(index, minSize, negative);
        if (result.endIndex < indexSize - 1) {
            this._loadFrame(result.endIndex + 1, this.cacheFrameSize);
        }
        return Promise.resolve(result);
    }
    //防止尾部加载重复数据
    var i = beginIndex + minSize - 1;
    i = i >= indexSize ? indexSize - 1 : i;
    for (; i > beginIndex; i--) {
        if (this.fileBlocks[i]) {
            minSize--;
        } else {
            break;
        }
    }
    if (beginIndex + minSize > indexSize) {
        minSize = indexSize - beginIndex;
    }
    begin = this._getRangeBeginByIndex(beginIndex);
    end = this._getRangeBeginByIndex(beginIndex + minSize) - 1;
    __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('loading:', beginIndex, beginIndex + minSize - 1);
    var promise = new Promise(function (resolve, reject) {
        setTimeout(function () {
            //交出控制权给Player对象
            promise.resolve = resolve;
            promise.reject = reject;
        }, 0);

        self.request = Object(__WEBPACK_IMPORTED_MODULE_0__common_range__["a" /* default */])(url, begin, end, {
            onsuccess: function (request) {
                var arrayBuffer = request.response;
                var begin = 0;
                var end = 0;
                //数据解密
                onbeforedecode(arrayBuffer);
                //缓存数据块
                for (var i = beginIndex; i < beginIndex + minSize && i < indexSize; i++) {
                    if (audioInfo.toc) {
                        //VBR编码模式
                        if (i + 1 >= indexSize || i + 1 >= beginIndex + minSize) {
                            end = arrayBuffer.byteLength;
                        } else {
                            end = begin + (self._getRangeBeginByIndex(i + 1) - self._getRangeBeginByIndex(i)) >> 0;
                        }
                        self.fileBlocks[i] = arrayBuffer.slice(begin, end);
                        begin = end;
                    } else {
                        //CBR编码模式
                        if (i + 1 >= indexSize || i + 1 >= beginIndex + minSize) {
                            end = arrayBuffer.byteLength;
                        } else {
                            end = begin + (audioInfo.fileSize - audioInfo.audioDataOffset) / indexSize;
                        }
                        self.fileBlocks[i] = arrayBuffer.slice(begin, end);
                        begin = end;
                    }
                }
                __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('load完成:', beginIndex, beginIndex + minSize - 1);
                if (self.loadingPromise && !self.loadingPromise.stopNextLoad) {
                    //seek后应该从新的位置加载后面的数据
                    setTimeout(function () {
                        self._loadFrame(index + originMinSize, originMinSize);
                    }, 0);
                }
                self.loadingPromise = null;
                resolve(self._joinNextCachedFileBlock(index, originMinSize, negative));
            },
            ontimeout: function () {
                clearTimeout(self.timeoutIds.reloadTimeoutId);
                self.timeoutIds.reloadTimeoutId = setTimeout(function () {
                    //1秒后重新加载
                    self.loadingPromise = self._loadFrame(index, minSize, negative);
                    self.loadingPromise.then(function () {
                        resolve(self._joinNextCachedFileBlock(index, originMinSize, negative));
                    });
                }, 1000);
            },
            onerror: function (e) {
                clearTimeout(self.timeoutIds.reloadTimeoutId);
                self.timeoutIds.reloadTimeoutId = setTimeout(function () {
                    //1秒后重新加载
                    self.loadingPromise = self._loadFrame(index, minSize, negative);
                    self.loadingPromise.then(function () {
                        resolve(self._joinNextCachedFileBlock(index, originMinSize, negative));
                    });
                }, 1000);
            },
            onabort: function (e) {
                reject('abort');
            }
        });
    }).catch(function (e) {
        __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log(e);
        self.loadingPromise = null;
        return false;
    });
    this.loadingPromise = promise;
    return promise;
};

//合并index索引之后所有连续的已经缓存过的分区
Player.prototype._joinNextCachedFileBlock = function (index, minSize, negative) {
    var length = 0;
    var arr = null;
    var result = null;
    var endIndex = index;
    var indexLength = this.fileBlocks.length;
    var exceed = false; //是否超过了最大解码长度
    if (__WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].ifDebug()) {
        var joinBegin = new Date().getTime();
        __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('join', index);
    }

    //开始播放或者seek时只返回minSize个数据块
    if (negative) {
        indexLength = index + minSize;
        indexLength = indexLength > indexSize ? indexSize : indexLength;
    }
    for (var i = index; i < indexLength && this.fileBlocks[i]; i++) {
        endIndex = i;
        length += this.fileBlocks[i].byteLength;
        if (length >= maxDecodeSize) {
            exceed = true;
            break;
        }
    }
    result = new ArrayBuffer(length);
    arr = new Uint8Array(result);
    length = 0;
    for (i = index; i <= endIndex; i++) {
        arr.set(new Uint8Array(this.fileBlocks[i]), length);
        length += this.fileBlocks[i].byteLength;
    }
    //删除头部和尾部损坏数据
    if (negative) {
        result = this._fixFileBlock(result);
    }
    __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].log('join花费:', new Date().getTime() - joinBegin, 'ms');
    return {
        exceed: exceed,
        arrayBuffer: result,
        beginIndex: index,
        endIndex: endIndex
    };
};

//根据索引号，找到实际的音频数据字节位置
Player.prototype._getRangeBeginByIndex = function (index) {
    var begin = 0;
    var audioInfo = this.audioInfo;
    if (audioInfo.toc) {
        if (index >= indexSize) {
            begin = audioInfo.fileSize;
        } else {
            begin = (audioInfo.toc[index] / 256 * audioInfo.totalSize >> 0) + audioInfo.audioDataOffset;
        }
    } else {
        begin = (audioInfo.fileSize - audioInfo.audioDataOffset) * index / indexSize + audioInfo.audioDataOffset >> 0;
    }
    if (begin > audioInfo.fileSize) {
        begin = audioInfo.fileSize;
    }
    return begin;
};

/**
 * 修复数据块头尾损坏数据（分割后，头部数据可能不是数据帧的帧头开始，需要修复）
 * @param  {ArrayBuffer} arrayBuffer  源数据
 * @return {ArrayBuffer}              修复后的数据
 */
Player.prototype._fixFileBlock = function (arrayBuffer) {
    var frameSync = this.audioInfo.frameSync;
    //删除帧头部多余数据
    var begeinExtraLength = __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].getLengthByFrameSync(arrayBuffer, frameSync, 0);
    arrayBuffer = arrayBuffer.slice(begeinExtraLength);
    begeinExtraLength = __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].getLengthByFrameSync(arrayBuffer, frameSync, 4);
    var mainDataOffset = _getMainDataOffset(arrayBuffer);
    //下一帧主数据偏移量大于上一帧总长度，说明上一帧为无效帧
    if (mainDataOffset >= begeinExtraLength) {
        return this._fixFileBlock(arrayBuffer.slice(begeinExtraLength));
    }
    var u8a = new Uint8Array(arrayBuffer);
    //第一帧数据清零
    for (var i = 4; i < begeinExtraLength - mainDataOffset; i++) {
        u8a[i] = 0;
    }
    return arrayBuffer;

    //获取mainData偏移量
    function _getMainDataOffset(arrayBuffer) {
        var mainDataOffset = 0;
        //下一帧开始偏移量
        var begeinExtraLength = __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].getLengthByFrameSync(arrayBuffer, frameSync, 4);
        var bitstream = new __WEBPACK_IMPORTED_MODULE_2__common_bitstream__["a" /* default */](arrayBuffer.slice(begeinExtraLength));
        var mainDataOffset = 0;
        bitstream.skipBits(32);
        //主数据负偏移量
        mainDataOffset = bitstream.getBits(9);
        return mainDataOffset;
    }
};

//跳转某个索引
Player.prototype._seek = function (index) {
    var self = this;
    var audioInfo = this.audioInfo;
    if (index >= indexSize) {
        index = indexSize - 1;
    }
    if (this.waiting) {
        this.waiting = false;
        onplaying();
    }
    if (this.totalBuffer) {
        var begin = this.totalBuffer.length * index / indexSize;
        var startTime = index / indexSize * audioInfo.duration;
        if (begin > this.totalBuffer.dataBegin && begin + 5 * this.sampleRate < this.totalBuffer.dataEnd) {
            if (this.pause) {
                this.resumeTime = startTime;
            } else {
                clearInterval(this.timeoutIds.updateIntervalId);
                clearTimeout(this.timeoutIds.playTimoutId);
                this._play(startTime);
            }
            return;
        } else if (this.pause) {
            this.resumeTime = -1;
            this.hasPlayed = false;
        }
        this.totalBuffer = this.audioContext.createBuffer(this.numberOfChannels, this.bufferLength, this.sampleRate);
    }
    this._clearTimeout();
    this.seeking = true;
    this.finished = false;
    this.beginDecodeTime = new Date().getTime();
    if (this.nowSouceNode) {
        this.nowSouceNode.disconnect();
    }
    if (this.loadingPromise) {
        //是否有数据正在加载
        this.loadingPromise.then(function () {
            self._decodeAudioData(index, self.cacheFrameSize, true, self.beginDecodeTime);
        });
        this.request.abort(); //强制中断下载
    } else {
        this._decodeAudioData(index, this.cacheFrameSize, true, this.beginDecodeTime);
    }
};

//清除所有计时器
Player.prototype._clearTimeout = function () {
    clearTimeout(this.timeoutIds.decodeTimeoutId);
    clearInterval(this.timeoutIds.updateIntervalId);
    clearTimeout(this.timeoutIds.playTimoutId);
    clearTimeout(this.timeoutIds.reloadTimeoutId);
};

function Mp3Player(_url, opt) {
    url = _url;
    this.player = new Player();
    this._init(opt);
}

Mp3Player.prototype._init = function (opt) {
    var self = this;
    onbeforedecode = opt.onbeforedecode || emptyCb;
    ontimeupdate = opt.ontimeupdate || emptyCb;
    onplay = opt.onplay || emptyCb;
    onpause = opt.onpause || emptyCb;
    onwaiting = opt.onwaiting || emptyCb;
    onplaying = opt.onplaying || emptyCb;
    onended = opt.onended || emptyCb;
    onloadedmetadata = opt.onloadedmetadata || emptyCb;
    onerror = opt.onerror || emptyCb;
    __WEBPACK_IMPORTED_MODULE_4__mp3info_mp3info__["a" /* default */].init(url, {
        onbeforedecode: onbeforedecode,
        onloadedmetadata: onloadedmetadata
    }).then(function (audioInfo) {
        self.player._init(audioInfo);
        if (!audioInfo) {
            onerror();
            self.player.error = 'parse audioInfo failed';
        }
    }).catch(function (e) {
        self.player.error = 'load audioInfo failed';
        console.log(e);
        onerror();
    });
};

Mp3Player.prototype.play = function () {
    if (this.player.error) {
        onerror();
        return;
    } else if (!this.clickPlayTime) {
        this.player.waiting = false;
        this.clickPlayTime = new Date().getTime();
    } else if (this.player.audioInfo === false || new Date().getTime() - this.player.clickPlayTime > 5000 && !this.player.audioInfo) {
        this.clickPlayTime = 0;
        return;
    }
    var self = this;
    var nowSouceNode = this.player.nowSouceNode;
    var audioContext = this.player.audioContext;
    var audioInfo = this.player.audioInfo;
    clearTimeout(this.player.timeoutIds.playTimoutId);
    //ios需要手动触发音频设备
    if (isIos && !this.hasClick) {
        audio.play();
        this.hasClick = true;
    }
    if (!this.player.hasPlayed) {
        if (!this.player.totalBuffer || typeof this.player.totalBuffer.dataBegin == undefined) {
            if (!this.player.waiting) {
                this.player.waiting = true;
                onwaiting();
            }
            this.player.timeoutIds.playTimoutId = setTimeout(function () {
                self.play();
            }, 500);
            return;
        }
        if (this.player.waiting) {
            this.player.waiting = false;
            onplaying();
        }
        this.player._play(this.player.totalBuffer.dataBegin / this.player.totalBuffer.length * audioInfo.duration);
        this.player.pause = false;
        onplay();
    } else if ((this.player.pause == true || this.player.finished) && !this.player.waiting) {
        if (this.player.finished) {
            this.player._seek(0);
        } else {
            this.player.pause = false;
            if (this.player.resumeTime != -1) {
                this.player._play(this.player.resumeTime);
            } else {
                audioContext.resume();
            }
        }
        onplay();
    }
};

Mp3Player.prototype.pause = function () {
    onpause();
    this.player.resumeTime = -1;
    this.player.pause = true;
    this.player.waiting = false;
    if (this.player.audioContext) {
        this.player.audioContext.suspend();
    }
    clearTimeout(this.player.timeoutIds.playTimoutId);
};

Mp3Player.prototype.seek = function (percent) {
    percent = percent >> 0;
    if (!this.player.audioInfo) {
        return false;
    }
    this.player._seek(percent);
    return true;
};

Mp3Player.prototype.destory = function () {
    this.player._clearTimeout();
    if (this.player.audioContext) {
        this.player.audioContext.close();
        this.player.audioContext = null;
    }
};

Mp3Player.prototype.isPlaying = function () {
    return this.player.isPlaying;
};

/* harmony default export */ __webpack_exports__["a"] = (Mp3Player);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__frame__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__synth__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__stream__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bufferStream__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__substream__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__global__ = __webpack_require__(0);







var Decoder = function () {
    this.decodeQue = [];
};
/**
 * 重置解码器
 * @param           {Object}  opt   参数
 * opt.onsuccess    {Function}      成功回调
 * opt.ArrayBuffer  {ArrayBuffer}   音频数据
 * opt.beginIndex   {Number}        开始片段索引
 * opt.endIndex     {Number}        结束片段索引
 * @return          {Boolean}       是否重置成功
 */
Decoder.prototype.reset = function (opt) {
    this.createMpegStream(opt);
    this.onsuccess = opt.onsuccess;
    this.onerror = opt.onerror;
    if (!this.channelCount) {
        this.frame = __WEBPACK_IMPORTED_MODULE_0__frame__["a" /* default */].decode(this.frame, this.mpeg);
        if (this.frame == null) {
            this.kill();
            console.log('error_reset');
            if (this.mpeg.error == __WEBPACK_IMPORTED_MODULE_5__global__["a" /* default */].Error.BUFLEN) {
                this.mpeg = null;
                this.stream = null;
                console.log("End of file!");
            } else {
                this.stream = null;
                this.mpeg = null;
                this.onerror && this.onerror();
            }
            return false;
        }
        this.synth = new __WEBPACK_IMPORTED_MODULE_1__synth__["a" /* default */]();
        this.channelCount = this.frame.header.nchannels();
        this.sampleRate = this.frame.header.samplerate;
        this.synth.frame(this.frame);
    }
    return true;
};
/**
 * 解码音频数据
 * @param           {Object}  opt   参数
 * opt.onsuccess    {Function}      成功回调
 * opt.ArrayBuffer  {ArrayBuffer}   音频数据
 * opt.beginIndex   {Number}        开始片段索引
 * opt.endIndex     {Number}        结束片段索引
 * @return          {Array}         PCM数据
 */
Decoder.prototype.decode = function (opt) {
    var buffer = null,
        startTime = Date.now(),
        self = this;
    if (this.decoding) {
        this.decodeQue.push(opt);
        return;
    }
    if (this.reset(opt)) {
        buffer = new Mp3AudioBuffer(this.channelCount, this.sampleRate);
        buffer.length = 0;
        _decode();
    }

    function _decode() {
        self.decoding = true;
        //一次最多解码200帧，防止浏览器阻塞
        for (var i = 0; i < 20; i++) {
            if (self.mpeg.bufend - self.mpeg.next_frame <= (self.mpeg.next_frame - self.mpeg.this_frame) * 4) {
                buffer.duration = buffer.length / buffer.sampleRate;
                // console.log('success_decode', buffer.length);
                self.onsuccess && self.onsuccess(buffer);
                _compelete();
                buffer = null;
                return;
            } else {
                self.frame = __WEBPACK_IMPORTED_MODULE_0__frame__["a" /* default */].decode(self.frame, self.mpeg);
                if (self.frame) {
                    self.synth.frame(self.frame);
                    for (var ch = 0; ch < self.channelCount; ++ch) {
                        buffer.samples[ch] = buffer.samples[ch].concat(self.synth.pcm.samples[ch]);
                    }
                    buffer.length += self.synth.pcm.samples[0].length;
                } else {
                    buffer = null;
                    self.kill();
                    console.log('error_decode');
                    self.onerror && self.onerror();
                    return;
                }
            }
        }
        //解码剩余的数据
        self.decodeTimmer = setTimeout(function () {
            _decode();
        }, 0);
    }
    //当前音频片段解码完成
    function _compelete() {
        clearTimeout(self.decodeTimmer);
        self.decoding = false;
        // console.log('cost', Date.now() - startTime, 'ms', 'duration', buffer.duration);
        if (self.decodeQue.length) {
            self.decode(self.decodeQue.shift());
        }
    }
};

/**
 * 解码音频数据
 * @param           {Object}  opt   参数
 * opt.ArrayBuffer  {ArrayBuffer}   音频数据
 * opt.beginIndex   {Number}        开始片段索引
 * opt.endIndex     {Number}        结束片段索引
 */
Decoder.prototype.createMpegStream = function (opt) {
    var beginIndex = opt.beginIndex;
    var endIndex = opt.endIndex;
    var arrayBuffer = opt.arrayBuffer;
    //接着上个片段继续解码
    if (this.mpeg && this.endIndex + 1 == beginIndex) {
        var oldBuffer = this.stream.state['arrayBuffer'];
        var newBuffer = new ArrayBuffer(oldBuffer.byteLength + arrayBuffer.byteLength);
        var uint8Array = new Uint8Array(newBuffer);
        uint8Array.set(new Uint8Array(oldBuffer), 0);
        uint8Array.set(new Uint8Array(arrayBuffer), oldBuffer.byteLength);
        var stream = new __WEBPACK_IMPORTED_MODULE_3__bufferStream__["a" /* default */](newBuffer);
        this.stream = stream;
        stream = new __WEBPACK_IMPORTED_MODULE_4__substream__["a" /* default */](stream, 0, newBuffer.byteLength);
        this.mpeg.bufend = newBuffer.byteLength;
        this.mpeg.stream = stream;
        this.mpeg.anc_ptr.stream = stream;
        this.mpeg.ptr.stream = stream;
    } else {
        this.stream = new __WEBPACK_IMPORTED_MODULE_3__bufferStream__["a" /* default */](arrayBuffer);
        this.mpeg = new __WEBPACK_IMPORTED_MODULE_2__stream__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_4__substream__["a" /* default */](this.stream, 0, this.stream.state['amountRead']));
        this.frame = new __WEBPACK_IMPORTED_MODULE_0__frame__["a" /* default */]();
        this.channelCount = 0;
    }
    this.endIndex = endIndex;
};

/**
 * 停止当前音频片段的解码
 */
Decoder.prototype.kill = function () {
    clearTimeout(this.decodeTimmer);
    this.decoding = false;
    this.decodeQue = [];
};

/**
 * 模拟AudioBuffer对象
 * @param {Number} channelCount 声道数量
 * @param {Number} sampleRate   采样率
 */
function Mp3AudioBuffer(channelCount, sampleRate) {
    this.samples = [];
    this.numberOfChannels = channelCount;
    this.sampleRate = sampleRate;
    for (var i = 0; i < channelCount; i++) {
        this.samples[i] = [];
    }
}

/**
 * 获取单个声道PCM数据
 * @param  {Number}      channel  声道
 * @return {Float32Array}         PCM数据
 */
Mp3AudioBuffer.prototype.getChannelData = function (channel) {
    return this.samples[channel];
};

/* harmony default export */ __webpack_exports__["a"] = (Decoder);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bit__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer3__ = __webpack_require__(12);




var bitrate_table /* [5][15] */ = [
/* MPEG-1 */
[0, 32000, 64000, 96000, 128000, 160000, 192000, 224000, /* Layer I   */
256000, 288000, 320000, 352000, 384000, 416000, 448000], [0, 32000, 48000, 56000, 64000, 80000, 96000, 112000, /* Layer II  */
128000, 160000, 192000, 224000, 256000, 320000, 384000], [0, 32000, 40000, 48000, 56000, 64000, 80000, 96000, /* Layer III */
112000, 128000, 160000, 192000, 224000, 256000, 320000],

/* MPEG-2 LSF */
[0, 32000, 48000, 56000, 64000, 80000, 96000, 112000, /* Layer I   */
128000, 144000, 160000, 176000, 192000, 224000, 256000], [0, 8000, 16000, 24000, 32000, 40000, 48000, 56000, /* Layers    */
64000, 80000, 96000, 112000, 128000, 144000, 160000] /* II & III  */
];

var samplerate_table /* [3] */ = [44100, 48000, 32000];

var decoder_table = [function () {
    console.log("Layer I decoding is not implemented!");
}, function () {
    console.log("Layer II decoding is not implemented!");
}, __WEBPACK_IMPORTED_MODULE_2__layer3__["a" /* default */]];

var Header = function () {
    this.layer = 0; /* audio layer (1, 2, or 3) */
    this.mode = 0; /* channel mode (see above) */
    this.mode_extension = 0; /* additional mode info */
    this.emphasis = 0; /* de-emphasis to use (see above) */

    this.bitrate = 0; /* stream bitrate (bps) */
    this.samplerate = 0; /* sampling frequency (Hz) */

    this.crc_check = 0; /* frame CRC accumulator */
    this.crc_target = 0; /* final target CRC checksum */

    this.flags = 0; /* flags (see below) */
    this.private_bits = 0; /* private bits (see below) */

    //this.duration       = mad_timer_zero;         /* audio playing time of frame */
};

Header.prototype.nchannels = function () {
    return this.mode == 0 ? 1 : 2;
};

Header.prototype.nbsamples = function () {
    return this.layer == __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Layer.I ? 12 : this.layer == __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Layer.III && this.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.LSF_EXT ? 18 : 36;
};

/* libmad's decode_header */
Header.actually_decode = function (stream) {
    var header = new Header();

    header.flags = 0;
    header.private_bits = 0;

    /* header() */

    /* syncword */
    stream.ptr.skip(11);

    /* MPEG 2.5 indicator (really part of syncword) */
    if (stream.ptr.read(1) == 0) {
        header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.MPEG_2_5_EXT;
    }

    /* ID */
    if (stream.ptr.read(1) == 0) {
        header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.LSF_EXT;
    } else if (header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.MPEG_2_5_EXT) {
        stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.LOSTSYNC;
        return null;
    }

    /* layer */
    header.layer = 4 - stream.ptr.read(2);

    if (header.layer == 4) {
        stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BADLAYER;
        return header;
    }

    /* protection_bit */
    if (stream.ptr.read(1) == 0) {
        header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.PROTECTION;
        // TODO: crc
        //header.crc_check = mad_bit_crc(stream.ptr, 16, 0xffff);
        stream.ptr.skip(16);
    }

    /* bitrate_index */
    var index = stream.ptr.read(4);
    if (index == 15) {
        stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BADBITRATE;
        return header;
    }

    if (header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.LSF_EXT) {
        header.bitrate = bitrate_table[3 + (header.layer >> 1)][index];
    } else {
        header.bitrate = bitrate_table[header.layer - 1][index];
    }

    /* sampling_frequency */
    index = stream.ptr.read(2);

    if (index == 3) {
        stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BADSAMPLERATE;
        return header;
    }

    header.samplerate = samplerate_table[index];

    if (header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.LSF_EXT) {
        header.samplerate /= 2;

        if (header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.MPEG_2_5_EXT) header.samplerate /= 2;
    }

    /* padding_bit */
    if (stream.ptr.read(1)) header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.PADDING;

    /* private_bit */
    if (stream.ptr.read(1)) header.private_bits |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Private.HEADER;

    /* mode */
    header.mode = 3 - stream.ptr.read(2);

    /* mode_extension */
    header.mode_extension = stream.ptr.read(2);

    /* copyright */
    if (stream.ptr.read(1)) header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.COPYRIGHT;

    /* original/copy */
    if (stream.ptr.read(1)) header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.ORIGINAL;

    /* emphasis */
    header.emphasis = stream.ptr.read(2);

    /* error_check() */

    /* crc_check */
    if (header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.PROTECTION) header.crc_target = stream.ptr.read(16);

    return header;
};

/* libmad's mad_header_decode */
Header.decode = function (stream) {
    var header = null;

    // those are actually pointers. javascript powa.
    var ptr = stream.next_frame;
    var end = stream.bufend;
    var pad_slot = 0;
    var N = 0;

    /* stream skip */
    if (stream.skiplen) {
        if (!stream.sync) ptr = stream.this_frame;

        if (end - ptr < stream.skiplen) {
            stream.skiplen -= end - ptr;
            stream.next_frame = end;

            stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BUFLEN;
            return null;
        }

        ptr += stream.skiplen;
        stream.skiplen = 0;

        stream.sync = 1;
    }

    // emulating goto in JS, yay! this was a 'sync:' label
    var syncing = true;

    while (syncing) {
        syncing = false;

        /* synchronize */
        try {
            if (stream.sync) {
                if (end - ptr < __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].BUFFER_GUARD) {
                    stream.next_frame = ptr;

                    stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BUFLEN;
                    return null;
                } else if (!(stream.getU8(ptr) == 0xff && (stream.getU8(ptr + 1) & 0xe0) == 0xe0)) {
                    /* mark point where frame sync word was expected */
                    stream.this_frame = ptr;
                    stream.next_frame = ptr + 1;

                    stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.LOSTSYNC;
                    return null;
                }
            } else {
                stream.ptr = new __WEBPACK_IMPORTED_MODULE_1__bit__["a" /* default */](stream.stream, ptr);

                if (stream.doSync() == -1) {
                    if (end - stream.next_frame >= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].BUFFER_GUARD) stream.next_frame = end - __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].BUFFER_GUARD;
                    stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BUFLEN;
                    return null;
                }

                ptr = stream.ptr.nextbyte();
            }
        } catch (e) {
            console.log("Synchronization error: " + e);

            stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BUFLEN;

            return null;
        }

        /* begin processing */
        stream.this_frame = ptr;
        stream.next_frame = ptr + 1; /* possibly bogus sync word */

        stream.ptr = new __WEBPACK_IMPORTED_MODULE_1__bit__["a" /* default */](stream.stream, stream.this_frame);

        header = Header.actually_decode(stream);
        if (header == null) return null; // well Duh^2

        // console.log("============= Decoding layer " + header.layer + " audio mode " +
        //     header.mode + " with " + header.bitrate +
        //     " bps and a samplerate of " + header.samplerate);

        /* calculate frame duration */
        //mad_timer_set(&header.duration, 0, 32 * MAD_NSBSAMPLES(header), header.samplerate);

        /* calculate free bit rate */
        if (header.bitrate == 0) {
            console.log("Uh oh, a free bitrate stream. We're fucked.");
            stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BADDATAPTR; // best guess
            return null;

            //        if ((stream.freerate == 0 || !stream.sync ||
            //                        (header.layer == Mad.Layer.III && stream.freerate > 640000)) &&
            //                free_bitrate(stream, header) == -1)
            //            return null;
            //
            //        header.bitrate = stream.freerate;
            //        header.flags  |= Mad.Flag.FREEFORMAT;
        }

        /* calculate beginning of next frame */
        pad_slot = header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.PADDING ? 1 : 0;

        if (header.layer == __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Layer.I) {
            N = ((12 * header.bitrate / header.samplerate << 0) + pad_slot) * 4;
        } else {
            var slots_per_frame = header.layer == __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Layer.III && header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.LSF_EXT ? 72 : 144;
            //console.log("slots_per_frame = " + slots_per_frame + ", bitrate = " + header.bitrate + ", samplerate = " + header.samplerate);

            N = (slots_per_frame * header.bitrate / header.samplerate << 0) + pad_slot;
        }

        /* verify there is enough data left in buffer to decode this frame */
        if (N + __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].BUFFER_GUARD > end - stream.this_frame) {
            stream.next_frame = stream.this_frame;

            stream.error = __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Error.BUFLEN;
            return null;
        }

        stream.next_frame = stream.this_frame + N;

        // console.log("N = " + N + ", pad_slot = " + pad_slot + ", next_frame = " + stream.next_frame);

        if (!stream.sync) {
            /* check that a valid frame header follows this frame */
            ptr = stream.next_frame;
            if (!(stream.getU8(ptr) == 0xff && (stream.getU8(ptr + 1) & 0xe0) == 0xe0)) {
                ptr = stream.next_frame = stream.this_frame + 1;

                // emulating 'goto sync'
                syncing = true;
                continue;
            }
            stream.sync = 1;
        }
    } // end of goto emulation (label 'sync')

    header.flags |= __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.INCOMPLETE;
    return header;
};

var Frame = function () {
    this.header = new Header(); /* MPEG audio header */

    this.options = 0; /* decoding options (from stream) */

    // sbsample[2][36][32]
    this.sbsample = []; /* synthesis subband filter samples */
    for (var ch = 0; ch < 2; ch++) {
        this.sbsample[ch] = [];
        for (var grp = 0; grp < 36; grp++) {
            // this.sbsample[ch][grp] = new Float64Array(new ArrayBuffer(8 * 32));
            this.sbsample[ch][grp] = [];
            for (var i = 0; i < 32; i++) {
                this.sbsample[ch][grp][i] = 0;
            }
        }
    }

    // overlap[2][32][18]
    this.overlap = []; /* Layer III block overlap data */
    for (var ch = 0; ch < 2; ch++) {
        this.overlap[ch] = [];
        for (var sb = 0; sb < 32; sb++) {
            // this.overlap[ch][sb] = new Float64Array(new ArrayBuffer(8 * 18));
            this.overlap[ch][sb] = [];
            for (var i = 0; i < 18; i++) {
                this.overlap[ch][sb][i] = 0;
            }
        }
    }
};

Frame.decode = function (frame, stream) {
    frame.options = stream.options;

    /* header() */
    /* error_check() */

    if (!(frame.header.flags & __WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.INCOMPLETE)) {
        frame.header = Header.decode(stream);
        if (frame.header == null) {
            // something went wrong
            return null;
        }
    }

    /* audio_data() */

    frame.header.flags &= ~__WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].Flag.INCOMPLETE;

    // TODO: actually decode the data :)
    if (decoder_table[frame.header.layer - 1](stream, frame) == -1) {

        if (!__WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */].recoverable(stream.error)) stream.next_frame = stream.this_frame;
        return null;
    }

    return frame;
};

/* harmony default export */ __webpack_exports__["a"] = (Frame);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bytestream__ = __webpack_require__(5);


var StringStream = function (string) {
    this.state = { offset: 0, buffer: string, amountRead: string.length, length: string.length };
};

StringStream.prototype = new __WEBPACK_IMPORTED_MODULE_0__bytestream__["a" /* default */]();

StringStream.prototype.absoluteAvailable = function (n, updated) {
    return n < this.state['amountRead'];
};

StringStream.prototype.seek = function (n) {
    this.state['offset'] += n;
};

StringStream.prototype.read = function (n) {
    var result = this.peek(n);

    this.seek(n);

    return result;
};

StringStream.prototype.peek = function (n) {
    if (this.available(n)) {
        var offset = this.state['offset'];

        var result = this.get(offset, n);

        return result;
    } else {
        throw 'TODO: THROW PEEK ERROR!';
    }
};

StringStream.prototype.get = function (offset, length) {
    if (this.absoluteAvailable(offset + length)) {
        return this.state['buffer'].slice(offset, offset + length);
    } else {
        throw 'TODO: THROW GET ERROR!';
    }
};

/* harmony default export */ __webpack_exports__["a"] = (StringStream);

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__huffman__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__imdct_s__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__global__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bit__ = __webpack_require__(4);




/*
 * MPEG-1 scalefactor band widths
 * derived from Table B.8 of ISO/IEC 11172-3
 */
var sfb_48000_long = [4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 10, 12, 16, 18, 22, 28, 34, 40, 46, 54, 54, 192];

var sfb_44100_long = [4, 4, 4, 4, 4, 4, 6, 6, 8, 8, 10, 12, 16, 20, 24, 28, 34, 42, 50, 54, 76, 158];

var sfb_32000_long = [4, 4, 4, 4, 4, 4, 6, 6, 8, 10, 12, 16, 20, 24, 30, 38, 46, 56, 68, 84, 102, 26];

var sfb_48000_short = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 10, 10, 10, 12, 12, 12, 14, 14, 14, 16, 16, 16, 20, 20, 20, 26, 26, 26, 66, 66, 66];

var sfb_44100_short = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 8, 8, 10, 10, 10, 12, 12, 12, 14, 14, 14, 18, 18, 18, 22, 22, 22, 30, 30, 30, 56, 56, 56];

var sfb_32000_short = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 8, 8, 12, 12, 12, 16, 16, 16, 20, 20, 20, 26, 26, 26, 34, 34, 34, 42, 42, 42, 12, 12, 12];

var sfb_48000_mixed = [
/* long */4, 4, 4, 4, 4, 4, 6, 6,
/* short */4, 4, 4, 6, 6, 6, 6, 6, 6, 10, 10, 10, 12, 12, 12, 14, 14, 14, 16, 16, 16, 20, 20, 20, 26, 26, 26, 66, 66, 66];

var sfb_44100_mixed = [
/* long */4, 4, 4, 4, 4, 4, 6, 6,
/* short */4, 4, 4, 6, 6, 6, 8, 8, 8, 10, 10, 10, 12, 12, 12, 14, 14, 14, 18, 18, 18, 22, 22, 22, 30, 30, 30, 56, 56, 56];

var sfb_32000_mixed = [
/* long */4, 4, 4, 4, 4, 4, 6, 6,
/* short */4, 4, 4, 6, 6, 6, 8, 8, 8, 12, 12, 12, 16, 16, 16, 20, 20, 20, 26, 26, 26, 34, 34, 34, 42, 42, 42, 12, 12, 12];

var sfbwidth_table = [{ l: sfb_48000_long, s: sfb_48000_short, m: sfb_48000_mixed }, { l: sfb_44100_long, s: sfb_44100_short, m: sfb_44100_mixed }, { l: sfb_32000_long, s: sfb_32000_short, m: sfb_32000_mixed /*, // fuck MPEG 2.5
                                                                                                                                                                                                                  { l: sfb_24000_long, s: sfb_24000_short, m: sfb_24000_mixed },
                                                                                                                                                                                                                  { l: sfb_22050_long, s: sfb_22050_short, m: sfb_22050_mixed },
                                                                                                                                                                                                                  { l: sfb_16000_long, s: sfb_16000_short, m: sfb_16000_mixed },
                                                                                                                                                                                                                  { l: sfb_12000_long, s: sfb_12000_short, m: sfb_12000_mixed },
                                                                                                                                                                                                                  { l: sfb_11025_long, s: sfb_11025_short, m: sfb_11025_mixed },
                                                                                                                                                                                                                  { l:  sfb_8000_long, s:  sfb_8000_short, m:  sfb_8000_mixed }*/
}];

var pretab /* [22] */ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0];

/*
 * fractional powers of two
 * used for requantization and joint stereo decoding
 *
 * root_table[3 + x] = 2^(x/4)
 */
var root_table /* 7 */ = [
/* 2^(-3/4) */0.59460355750136,
/* 2^(-2/4) */0.70710678118655,
/* 2^(-1/4) */0.84089641525371,
/* 2^( 0/4) */1.00000000000000,
/* 2^(+1/4) */1.18920711500272,
/* 2^(+2/4) */1.41421356237310,
/* 2^(+3/4) */1.68179283050743];

var cs = [+0.857492926, +0.881741997, +0.949628649, +0.983314592, +0.995517816, +0.999160558, +0.999899195, +0.999993155];

var ca = [-0.514495755, -0.471731969, -0.313377454, -0.181913200, -0.094574193, -0.040965583, -0.014198569, -0.003699975];

/*
 * windowing coefficients for long blocks
 * derived from section 2.4.3.4.10.3 of ISO/IEC 11172-3
 *
 * window_l[i] = sin((PI / 36) * (i + 1/2))
 */
var window_l /* [36] */ = [0.043619387, 0.130526192, 0.216439614, 0.300705800, 0.382683432, 0.461748613, 0.537299608, 0.608761429, 0.675590208, 0.737277337, 0.793353340, 0.843391446, 0.887010833, 0.923879533, 0.953716951, 0.976296007, 0.991444861, 0.999048222, 0.999048222, 0.991444861, 0.976296007, 0.953716951, 0.923879533, 0.887010833, 0.843391446, 0.793353340, 0.737277337, 0.675590208, 0.608761429, 0.537299608, 0.461748613, 0.382683432, 0.300705800, 0.216439614, 0.130526192, 0.043619387];

/*
 * windowing coefficients for short blocks
 * derived from section 2.4.3.4.10.3 of ISO/IEC 11172-3
 *
 * window_s[i] = sin((PI / 12) * (i + 1/2))
 */
var window_s /* [12] */ = [0.130526192, 0.382683432, 0.608761429, 0.793353340, 0.923879533, 0.991444861, 0.991444861, 0.923879533, 0.793353340, 0.608761429, 0.382683432, 0.130526192];

/*
 * coefficients for intensity stereo processing
 * derived from section 2.4.3.4.9.3 of ISO/IEC 11172-3
 *
 * is_ratio[i] = tan(i * (PI / 12))
 * is_table[i] = is_ratio[i] / (1 + is_ratio[i])
 */
var is_table /* [7] */ = [0.000000000, 0.211324865, 0.366025404, 0.500000000, 0.633974596, 0.788675135, 1.000000000];

/*
 * coefficients for LSF intensity stereo processing
 * derived from section 2.4.3.2 of ISO/IEC 13818-3
 *
 * is_lsf_table[0][i] = (1 / sqrt(sqrt(2)))^(i + 1)
 * is_lsf_table[1][i] = (1 /      sqrt(2)) ^(i + 1)
 */
var is_lsf_table /* [2][15] */ = [[0.840896415, 0.707106781, 0.594603558, 0.500000000, 0.420448208, 0.353553391, 0.297301779, 0.250000000, 0.210224104, 0.176776695, 0.148650889, 0.125000000, 0.105112052, 0.088388348, 0.074325445], [0.707106781, 0.500000000, 0.353553391, 0.250000000, 0.176776695, 0.125000000, 0.088388348, 0.062500000, 0.044194174, 0.031250000, 0.022097087, 0.015625000, 0.011048543, 0.007812500, 0.005524272]];

var CHAR_BIT = 8;

var SideInfo = function () {
    this.gr = []; // array of Mad.Granule
    this.scfsi = []; // array of ints
};

/*
 * scalefactor bit lengths
 * derived from section 2.4.2.7 of ISO/IEC 11172-3
 */
var sflen_table = [{ slen1: 0, slen2: 0 }, { slen1: 0, slen2: 1 }, { slen1: 0, slen2: 2 }, { slen1: 0, slen2: 3 }, { slen1: 3, slen2: 0 }, { slen1: 1, slen2: 1 }, { slen1: 1, slen2: 2 }, { slen1: 1, slen2: 3 }, { slen1: 2, slen2: 1 }, { slen1: 2, slen2: 2 }, { slen1: 2, slen2: 3 }, { slen1: 3, slen2: 1 }, { slen1: 3, slen2: 2 }, { slen1: 3, slen2: 3 }, { slen1: 4, slen2: 2 }, { slen1: 4, slen2: 3 }];

var Granule = function () {
    this.ch = []; // list of Channel 
};

var Channel = function () {
    this.table_select = []; // list of Numbers (I guess)
    this.scalefac = []; // list of integers
    this.subblock_gain = [];
};

/* we must take care that sz >= bits and sz < sizeof(long) lest bits == 0 */
var MASK = function (cache, sz, bits) {
    // return Mad.bitwiseAnd(Mad.rshift(cache, sz - bits), Mad.lshift(1, bits) - 1);
    return cache >> sz - bits & (1 << bits) - 1;
};

var MASK1BIT = function (cache, sz) {
    // return Mad.bitwiseAnd(cache, Mad.lshift(1, sz - 1));
    return cache & 1 << sz - 1;
};

/*
 * NAME:    III_huffdecode()
 * DESCRIPTION: decode Huffman code words of one channel of one granule
 */
var III_huffdecode = function (ptr, xr /* Float64Array(576) */, channel, sfbwidth, part2_length) {
    var exponents = new Int32Array(new ArrayBuffer(4 * 39));
    var expptr = 0;
    var bits_left, cachesz;
    var xrptr;
    var sfbound;
    var bitcache;
    var sfbwidthptr = 0;

    bits_left = channel.part2_3_length - part2_length;

    if (bits_left < 0) return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADPART3LEN;

    III_exponents(channel, sfbwidth, exponents);

    var peek = ptr.clone();
    ptr.skip(bits_left);

    /* align bit reads to byte boundaries */
    cachesz = peek.left;
    cachesz += 32 - 1 - 24 + (24 - cachesz) & ~7;

    bitcache = peek.read(cachesz);
    //console.log("bitcache peek.read = " + bitcache);
    bits_left -= cachesz;

    xrptr = 0;

    /* big_values */
    {
        var region = 0,
            rcount;

        // var reqcache = new Float64Array(new ArrayBuffer(8 * 16));
        var reqcache = [];

        sfbound = xrptr + sfbwidth[sfbwidthptr++];
        rcount = channel.region0_count + 1;

        var entry = __WEBPACK_IMPORTED_MODULE_0__huffman__["a" /* huff_pair_table */][channel.table_select[region]];
        var table = entry.table;
        var linbits = entry.linbits;
        var startbits = entry.startbits;

        if (typeof table == 'undefined') return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADHUFFTABLE;

        expptr = 0;
        var exp = exponents[expptr++];
        var reqhits = 0;
        var big_values = channel.big_values;

        while (big_values-- && cachesz + bits_left > 0) {
            var pair;
            var clumpsz, value;
            var requantized;

            //console.log("big_values = " + big_values + ", cachesz = " + cachesz + ", bits_left = " + bits_left);

            if (xrptr == sfbound) {
                sfbound += sfbwidth[sfbwidthptr++];

                /* change table if region boundary */
                if (--rcount == 0) {
                    if (region == 0) rcount = channel.region1_count + 1;else rcount = 0; /* all remaining */

                    entry = __WEBPACK_IMPORTED_MODULE_0__huffman__["a" /* huff_pair_table */][channel.table_select[++region]];
                    table = entry.table;
                    linbits = entry.linbits;
                    startbits = entry.startbits;

                    if (typeof table == 'undefined') return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADHUFFTABLE;
                }

                if (exp != exponents[expptr]) {
                    exp = exponents[expptr];
                    reqhits = 0;
                }

                ++expptr;
            }

            if (cachesz < 21) {
                var bits = 32 - 1 - 21 + (21 - cachesz) & ~7;
                bitcache = bitcache << bits | peek.read(bits);
                cachesz += bits;
                bits_left -= bits;
            }

            /* hcod (0..19) */
            clumpsz = startbits;
            pair = table[bitcache >> cachesz - clumpsz & (1 << clumpsz) - 1];

            while (!pair['final']) {
                cachesz -= clumpsz;

                clumpsz = pair.ptr.bits;
                pair = table[pair.ptr.offset + (bitcache >> cachesz - clumpsz & (1 << clumpsz) - 1)];
            }

            cachesz -= pair.value.hlen;

            if (linbits) {
                /* x (0..14) */
                value = pair.value.x;
                var x_final = false;

                switch (value) {
                    case 0:
                        xr[xrptr] = 0;
                        break;

                    case 15:
                        if (cachesz < linbits + 2) {
                            bitcache = bitcache << 16 | peek.read(16);
                            cachesz += 16;
                            bits_left -= 16;
                        }

                        value += bitcache >> cachesz - linbits & (1 << linbits) - 1;
                        cachesz -= linbits;

                        requantized = III_requantize(value, exp);
                        x_final = true; // simulating goto, yay
                        break;

                    default:
                        if (reqhits & 1 << value) requantized = reqcache[value];else {
                            reqhits |= 1 << value;
                            requantized = reqcache[value] = III_requantize(value, exp);
                        }
                        x_final = true;
                }

                if (x_final) {
                    xr[xrptr] = bitcache & 1 << cachesz-- - 1 ? -requantized : requantized;
                }

                /* y (0..14) */
                value = pair.value.y;
                var y_final = false;

                switch (value) {
                    case 0:
                        xr[xrptr + 1] = 0;
                        break;

                    case 15:
                        if (cachesz < linbits + 1) {
                            bitcache = bitcache << 16 | peek.read(16);
                            cachesz += 16;
                            bits_left -= 16;
                        }

                        value += bitcache >> cachesz - linbits & (1 << linbits) - 1;
                        cachesz -= linbits;

                        requantized = III_requantize(value, exp);
                        y_final = true;
                        break; // simulating goto, yayzor

                    default:
                        if (reqhits & 1 << value) requantized = reqcache[value];else {
                            reqhits |= 1 << value;
                            reqcache[value] = III_requantize(value, exp);
                            requantized = reqcache[value];
                        }
                        y_final = true;
                }

                if (y_final) {
                    xr[xrptr + 1] = bitcache & 1 << cachesz-- - 1 ? -requantized : requantized;
                }
            } else {
                /* x (0..1) */
                value = pair.value.x;

                if (value == 0) {
                    xr[xrptr] = 0;
                } else {
                    if (reqhits & 1 << value) requantized = reqcache[value];else {
                        reqhits |= 1 << value;
                        requantized = reqcache[value] = III_requantize(value, exp);
                    }

                    xr[xrptr] = bitcache & 1 << cachesz-- - 1 ? -requantized : requantized;
                }

                /* y (0..1) */
                value = pair.value.y;

                if (value == 0) xr[xrptr + 1] = 0;else {
                    if (reqhits & 1 << value) requantized = reqcache[value];else {
                        reqhits |= 1 << value;
                        requantized = reqcache[value] = III_requantize(value, exp);
                    }

                    xr[xrptr + 1] = bitcache & 1 << cachesz-- - 1 ? -requantized : requantized;
                }
            }

            xrptr += 2;
            //console.log("big_values = " + big_values + ", cachesz = " + cachesz +
            //  ", bits_left = " + bits_left + ", xrptr = " + xrptr);
        }
    }

    //console.log("bits_left (before big_values overrun) = " + bits_left);

    if (cachesz + bits_left < 0) return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADHUFFDATA; /* big_values overrun */

    /* count1 */
    {
        var table = __WEBPACK_IMPORTED_MODULE_0__huffman__["b" /* huff_quad_table */][channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].count1table_select];
        var requantized = III_requantize(1, exp);

        while (cachesz + bits_left > 0 && xrptr <= 572) {
            /* hcod (1..6) */
            if (cachesz < 10) {
                bitcache = bitcache << 16 | peek.read(16);
                cachesz += 16;
                bits_left -= 16;
            }

            var quad = table[bitcache >> cachesz - 4 & (1 << 4) - 1];

            /* quad tables guaranteed to have at most one extra lookup */
            if (!quad['final']) {
                cachesz -= 4;

                quad = table[quad.ptr.offset + (bitcache >> cachesz - quad.ptr.bits & (1 << quad.ptr.bits) - 1)];
            }

            cachesz -= quad.value.hlen;

            if (xrptr == sfbound) {
                sfbound += sfbwidth[sfbwidthptr++];

                if (exp != exponents[expptr]) {
                    exp = exponents[expptr];
                    requantized = III_requantize(1, exp);
                }

                ++expptr;
            }

            /* v (0..1) */
            xr[xrptr] = quad.value.v ? bitcache & 1 << cachesz-- - 1 ? -requantized : requantized : 0;

            /* w (0..1) */
            xr[xrptr + 1] = quad.value.w ? bitcache & 1 << cachesz-- - 1 ? -requantized : requantized : 0;

            xrptr += 2;

            if (xrptr == sfbound) {
                sfbound += sfbwidth[sfbwidthptr++];

                if (exp != exponents[expptr]) {
                    exp = exponents[expptr];
                    requantized = III_requantize(1, exp);
                }

                ++expptr;
            }

            /* x (0..1) */
            xr[xrptr] = quad.value.x ? bitcache & 1 << cachesz-- - 1 ? -requantized : requantized : 0;

            /* y (0..1) */
            xr[xrptr + 1] = quad.value.y ? bitcache & 1 << cachesz-- - 1 ? -requantized : requantized : 0;

            xrptr += 2;
        }

        if (cachesz + bits_left < 0) {
            //# if 0 && defined(DEBUG)
            //console.log("huffman count1 overrun (" + (-(cachesz + bits_left)) + " bits)");
            //# endif

            /* technically the bitstream is misformatted, but apparently
               some encoders are just a bit sloppy with stuffing bits */
            xrptr -= 4;
        }
    }

    if (!(-bits_left <= __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].BUFFER_GUARD * CHAR_BIT)) {
        throw new Error("assertion failed: (-bits_left <= Mad.BUFFER_GUARD * CHAR_BIT)");
    }

    /*
      # if 0 && defined(DEBUG)
      if (bits_left < 0)
      console.log("read " + (-bits_left) + " bits too many");
      else if (cachesz + bits_left > 0)
      console.log((cachesz + bits_left) + " stuffing bits");
      else
      console.log("bits_left " + bits_left);
      # endif
    */

    /* rzero */
    while (xrptr < 576) {
        xr[xrptr] = 0;
        xr[xrptr + 1] = 0;

        xrptr += 2;
    }

    return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.NONE;
};

/*
 * NAME:    III_sideinfo()
 * DESCRIPTION: decode frame side information from a bitstream
 * 
 * Since several values are passed by reference to this function, instead
 * we're just returning a hash containing:
 * {
 *   ptr (Bit)
 *   sideinfo (Mad.Sideinfo) 
 *   data_bitlen (Number)
 *   priv_bitlen (Number)
 * }
 */
var III_sideinfo = function (ptr, nch, lsf) {

    var si = new SideInfo();
    var result = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.NONE;

    var data_bitlen = 0;
    var priv_bitlen = lsf ? nch == 1 ? 1 : 2 : nch == 1 ? 5 : 3;

    si.main_data_begin = ptr.read(lsf ? 8 : 9);
    si.private_bits = ptr.read(priv_bitlen);

    var ngr = 1;
    if (!lsf) {
        ngr = 2;

        for (var ch = 0; ch < nch; ++ch) si.scfsi[ch] = ptr.read(4);
    }

    for (var gr = 0; gr < ngr; ++gr) {
        var granule = new Granule();
        si.gr[gr] = granule;

        for (var ch = 0; ch < nch; ++ch) {
            var channel = new Channel();
            granule.ch[ch] = channel;

            channel.part2_3_length = ptr.read(12);
            channel.big_values = ptr.read(9);
            channel.global_gain = ptr.read(8);
            channel.scalefac_compress = ptr.read(lsf ? 9 : 4);

            data_bitlen += channel.part2_3_length;

            if (channel.big_values > 288 && result == 0) result = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADBIGVALUES;

            channel.flags = 0;

            /* window_switching_flag */
            if (ptr.read(1)) {
                channel.block_type = ptr.read(2);

                if (channel.block_type == 0 && result == 0) result = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADBLOCKTYPE;

                if (!lsf && channel.block_type == 2 && si.scfsi[ch] && result == 0) result = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADSCFSI;

                channel.region0_count = 7;
                channel.region1_count = 36;

                if (ptr.read(1)) channel.flags |= __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag;else if (channel.block_type == 2) channel.region0_count = 8;

                for (var i = 0; i < 2; ++i) channel.table_select[i] = ptr.read(5);

                for (var i = 0; i < 3; ++i) channel.subblock_gain[i] = ptr.read(3);
            } else {
                channel.block_type = 0;

                for (var i = 0; i < 3; ++i) channel.table_select[i] = ptr.read(5);

                channel.region0_count = ptr.read(4);
                channel.region1_count = ptr.read(3);
            }

            /* [preflag,] scalefac_scale, count1table_select */
            channel.flags |= ptr.read(lsf ? 2 : 3);
        }
    }

    return {
        ptr: ptr,
        si: si,
        data_bitlen: data_bitlen,
        priv_bitlen: priv_bitlen
    };
};

/*
 * NAME:    III_scalefactors()
 * DESCRIPTION: decode channel scalefactors of one granule from a bitstream
 */
var III_scalefactors = function (ptr, channel, gr0ch, scfsi) {
    var start; /* Bit */
    var slen1, slen2, sfbi;

    var start = ptr.clone();

    var slen1 = sflen_table[channel.scalefac_compress].slen1;
    var slen2 = sflen_table[channel.scalefac_compress].slen2;

    if (channel.block_type == 2) {
        sfbi = 0;

        var nsfb = channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag ? 8 + 3 * 3 : 6 * 3;
        while (nsfb--) channel.scalefac[sfbi++] = ptr.read(slen1);

        nsfb = 6 * 3;
        while (nsfb--) channel.scalefac[sfbi++] = ptr.read(slen2);

        nsfb = 1 * 3;
        while (nsfb--) channel.scalefac[sfbi++] = 0;
    } else {
        /* channel.block_type != 2 */
        if (scfsi & 0x8) {
            for (var sfbi = 0; sfbi < 6; ++sfbi) channel.scalefac[sfbi] = gr0ch.scalefac[sfbi];
        } else {
            for (var sfbi = 0; sfbi < 6; ++sfbi) channel.scalefac[sfbi] = ptr.read(slen1);
        }

        if (scfsi & 0x4) {
            for (var sfbi = 6; sfbi < 11; ++sfbi) channel.scalefac[sfbi] = gr0ch.scalefac[sfbi];
        } else {
            for (var sfbi = 6; sfbi < 11; ++sfbi) channel.scalefac[sfbi] = ptr.read(slen1);
        }

        if (scfsi & 0x2) {
            for (var sfbi = 11; sfbi < 16; ++sfbi) channel.scalefac[sfbi] = gr0ch.scalefac[sfbi];
        } else {
            for (var sfbi = 11; sfbi < 16; ++sfbi) channel.scalefac[sfbi] = ptr.read(slen2);
        }

        if (scfsi & 0x1) {
            for (var sfbi = 16; sfbi < 21; ++sfbi) channel.scalefac[sfbi] = gr0ch.scalefac[sfbi];
        } else {
            for (var sfbi = 16; sfbi < 21; ++sfbi) channel.scalefac[sfbi] = ptr.read(slen2);
        }

        channel.scalefac[21] = 0;
    }

    return start.length(ptr);
};

var c0 = 2 * Math.cos(1 * Math.PI / 18);
var c1 = 2 * Math.cos(3 * Math.PI / 18);
var c2 = 2 * Math.cos(4 * Math.PI / 18);
var c3 = 2 * Math.cos(5 * Math.PI / 18);
var c4 = 2 * Math.cos(7 * Math.PI / 18);
var c5 = 2 * Math.cos(8 * Math.PI / 18);
var c6 = 2 * Math.cos(16 * Math.PI / 18);

var fastsdct = function (x /* [9] */, y /* [18] */, offset) {
    var a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12;
    var a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25;
    var m0, m1, m2, m3, m4, m5, m6, m7;

    a0 = x[3] + x[5];
    a1 = x[3] - x[5];
    a2 = x[6] + x[2];
    a3 = x[6] - x[2];
    a4 = x[1] + x[7];
    a5 = x[1] - x[7];
    a6 = x[8] + x[0];
    a7 = x[8] - x[0];

    a8 = a0 + a2;
    a9 = a0 - a2;
    a10 = a0 - a6;
    a11 = a2 - a6;
    a12 = a8 + a6;
    a13 = a1 - a3;
    a14 = a13 + a7;
    a15 = a3 + a7;
    a16 = a1 - a7;
    a17 = a1 + a3;

    m0 = a17 * -c3;
    m1 = a16 * -c0;
    m2 = a15 * -c4;
    m3 = a14 * -c1;
    m4 = a5 * -c1;
    m5 = a11 * -c6;
    m6 = a10 * -c5;
    m7 = a9 * -c2;

    a18 = x[4] + a4;
    a19 = 2 * x[4] - a4;
    a20 = a19 + m5;
    a21 = a19 - m5;
    a22 = a19 + m6;
    a23 = m4 + m2;
    a24 = m4 - m2;
    a25 = m4 + m1;

    /* output to every other slot for convenience */
    y[offset + 0] = a18 + a12;
    y[offset + 2] = m0 - a25;
    y[offset + 4] = m7 - a20;
    y[offset + 6] = m3;
    y[offset + 8] = a21 - m6;
    y[offset + 10] = a24 - m1;
    y[offset + 12] = a12 - 2 * a18;
    y[offset + 14] = a23 + m0;
    y[offset + 16] = a22 + m7;
};

/* sdctII_scale[i] = 2 * cos(PI * (2 * i + 1) / (2 * 18)) */
var sdctII_scale = [];
for (var i = 0; i < 9; ++i) {
    sdctII_scale[i] = 2 * Math.cos(Math.PI * (2 * i + 1) / (2 * 18));
}

var sdctII = function (x /* [18] */, X /* [18] */) {
    /* divide the 18-point SDCT-II into two 9-point SDCT-IIs */

    // var tmp = new Float64Array(new ArrayBuffer(8 * 9));

    var tmp = [];

    /* even input butterfly */

    for (var i = 0; i < 9; ++i) {
        tmp[i] = x[i] + x[18 - i - 1];
    }

    fastsdct(tmp, X, 0);

    /* odd input butterfly and scaling */

    for (var i = 0; i < 9; ++i) {
        tmp[i] = (x[i] - x[18 - i - 1]) * sdctII_scale[i];
    }

    fastsdct(tmp, X, 1);

    /* output accumulation */

    for (var i = 3; i < 18; i += 2) {
        X[i] -= X[i - 2];
    }
};

/* dctIV_scale[i] = 2 * cos(PI * (2 * i + 1) / (4 * 18)) */
var dctIV_scale = [];
for (i = 0; i < 18; i++) {
    dctIV_scale[i] = 2 * Math.cos(Math.PI * (2 * i + 1) / (4 * 18));
}

var dctIV = function (y /* [18] */, X /* [18] */) {
    // var tmp = new Float64Array(new ArrayBuffer(8 * 18));
    var tmp = [];

    /* scaling */

    for (var i = 0; i < 18; ++i) {
        tmp[i] = y[i] * dctIV_scale[i];
    }

    /* SDCT-II */

    sdctII(tmp, X);

    /* scale reduction and output accumulation */

    X[0] /= 2;
    for (var i = 1; i < 18; ++i) {
        X[i] = X[i] / 2 - X[i - 1];
    }
};

/*
 * NAME:    imdct36
 * DESCRIPTION: perform X[18]->x[36] IMDCT using Szu-Wei Lee's fast algorithm
 */
var imdct36 = function (x /* [18] */, y /* [36] */) {
    // var tmp = new Float64Array(new ArrayBuffer(8 * 18));
    var tmp = [];

    /* DCT-IV */
    dctIV(x, tmp);

    /* convert 18-point DCT-IV to 36-point IMDCT */

    for (var i = 0; i < 9; ++i) {
        y[i] = tmp[9 + i];
    }
    for (var i = 9; i < 27; ++i) {
        y[i] = -tmp[36 - (9 + i) - 1];
    }
    for (var i = 27; i < 36; ++i) {
        y[i] = -tmp[i - 27];
    }
};

/*
 * NAME:    III_imdct_s()
 * DESCRIPTION: perform IMDCT and windowing for short blocks
 */
var III_imdct_s = function (X /* [18] */, z /* [36] */) {
    var yptr = 0;
    var wptr;
    var Xptr = 0;

    // var imdct_s_y = new Float64Array(new ArrayBuffer(8 * 36));
    var y = [];
    var hi, lo;

    /* IMDCT */
    for (var w = 0; w < 3; ++w) {
        var s = __WEBPACK_IMPORTED_MODULE_1__imdct_s__["a" /* default */];
        var sptr = 0;

        for (var i = 0; i < 3; ++i) {
            lo = X[Xptr + 0] * s[sptr][0] + X[Xptr + 1] * s[sptr][1] + X[Xptr + 2] * s[sptr][2] + X[Xptr + 3] * s[sptr][3] + X[Xptr + 4] * s[sptr][4] + X[Xptr + 5] * s[sptr][5];

            y[yptr + i + 0] = lo;
            y[yptr + 5 - i] = -y[yptr + i + 0];

            ++sptr;

            lo = X[Xptr + 0] * s[sptr][0] + X[Xptr + 1] * s[sptr][1] + X[Xptr + 2] * s[sptr][2] + X[Xptr + 3] * s[sptr][3] + X[Xptr + 4] * s[sptr][4] + X[Xptr + 5] * s[sptr][5];

            y[yptr + i + 6] = lo;
            y[yptr + 11 - i] = y[yptr + i + 6];

            ++sptr;
        }

        yptr += 12;
        Xptr += 6;
    }

    /* windowing, overlapping and concatenation */

    yptr = 0;
    var wptr = 0;

    for (var i = 0; i < 6; ++i) {
        z[i + 0] = 0;
        z[i + 6] = y[yptr + 0 + 0] * window_s[wptr + 0];

        lo = y[yptr + 0 + 6] * window_s[wptr + 6] + y[yptr + 12 + 0] * window_s[wptr + 0];

        z[i + 12] = lo;

        lo = y[yptr + 12 + 6] * window_s[wptr + 6] + y[yptr + 24 + 0] * window_s[wptr + 0];

        z[i + 18] = lo;

        z[i + 24] = y[yptr + 24 + 6] * window_s[wptr + 6];
        z[i + 30] = 0;

        ++yptr;
        ++wptr;
    }
};

/*
 * NAME:    III_imdct_l()
 * DESCRIPTION: perform IMDCT and windowing for long blocks
 */
__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].III_imdct_l = function (X /* 18 */, z /* 36 */, block_type) {
    /* IMDCT */
    imdct36(X, z);

    /* windowing */

    switch (block_type) {
        case 0:
            /* normal window */
            for (var i = 0; i < 36; ++i) z[i] = z[i] * window_l[i];
            break;

        case 1:
            /* start block */
            for (var i = 0; i < 18; ++i) z[i] = z[i] * window_l[i];
            /*  (var i = 18; i < 24; ++i) z[i] unchanged */
            for (var i = 24; i < 30; ++i) z[i] = z[i] * window_s[i - 18];
            for (var i = 30; i < 36; ++i) z[i] = 0;
            break;

        case 3:
            /* stop block */
            for (var i = 0; i < 6; ++i) z[i] = 0;
            for (var i = 6; i < 12; ++i) z[i] = z[i] * window_s[i - 6];
            /*  (var i = 12; i < 18; ++i) z[i] unchanged */
            for (var i = 18; i < 36; ++i) z[i] = z[i] * window_l[i];
            break;
    }
};

/*
 * NAME:III_freqinver()
 * DESCRIPTION: perform subband frequency inversion for odd sample lines
 */
var III_freqinver = function (sample /* [18][32] */, sb) {
    for (var i = 1; i < 18; i += 2) sample[i][sb] = -sample[i][sb];
};

/*
 * NAME:    III_decode()
 * DESCRIPTION: decode frame main_data
 * 
 * result struct:
 */
var III_decode = function (ptr, frame, si, nch) {
    var header = frame.header;
    var sfreqi;

    {
        var sfreq = header.samplerate;

        if (header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.MPEG_2_5_EXT) sfreq *= 2;

        /* 48000 => 0, 44100 => 1, 32000 => 2,
           24000 => 3, 22050 => 4, 16000 => 5 */
        sfreqi = (sfreq >> 7 & 0x000f) + (sfreq >> 15 & 0x0001) - 8;

        if (header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.MPEG_2_5_EXT) sfreqi += 3;
    }

    /* scalefactors, Huffman decoding, requantization */
    var ngr = header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.LSF_EXT ? 1 : 2;

    for (var gr = 0; gr < ngr; ++gr) {
        var granule = si.gr[gr];
        var sfbwidth = [];
        /* unsigned char const *sfbwidth[2]; */
        var l = 0;
        // var xr = [ new Float64Array(new ArrayBuffer(8 * 576)), new Float64Array(new ArrayBuffer(8 * 576)) ];
        var xr = [[], []];
        var error;

        for (var ch = 0; ch < nch; ++ch) {
            var channel = granule.ch[ch];
            var part2_length;

            sfbwidth[ch] = sfbwidth_table[sfreqi].l;

            if (channel.block_type == 2) {
                sfbwidth[ch] = channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag ? sfbwidth_table[sfreqi].m : sfbwidth_table[sfreqi].s;
            }

            if (header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.LSF_EXT) {
                part2_length = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].III_scalefactors_lsf(ptr, channel, ch == 0 ? 0 : si.gr[1].ch[1], header.mode_extension);
            } else {
                part2_length = III_scalefactors(ptr, channel, si.gr[0].ch[ch], gr == 0 ? 0 : si.scfsi[ch]);
            }

            error = III_huffdecode(ptr, xr[ch], channel, sfbwidth[ch], part2_length);

            if (error) return error;
        }

        if (__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug) {
            __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.huffdecode.write(__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.iteration + "\t");

            for (var i = 0; i < 576; i++) {
                __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.huffdecode.write(xr[0][i].toFixed(8) + "\t");
            }
            __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.huffdecode.write("\n");
        }

        /* joint stereo processing */
        if (header.mode == __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Mode.JOINT_STEREO && header.mode_extension != 0) {
            error = III_stereo(xr, granule, header, sfbwidth[0]);

            if (error) return error;
        }

        /* reordering, alias reduction, IMDCT, overlap-add, frequency inversion */
        for (var ch = 0; ch < nch; ++ch) {
            var channel = granule.ch[ch];
            var sample = frame.sbsample[ch].slice(18 * gr);

            var sb,
                l = 0,
                i,
                sblimit;
            // var output = new Float64Array(new ArrayBuffer(8 * 36));
            var output = [];

            if (channel.block_type == 2) {
                III_reorder(xr[ch], channel, sfbwidth[ch]);

                /*
                 * According to ISO/IEC 11172-3, "Alias reduction is not applied for
                 * granules with block_type == 2 (short block)." However, other
                 * sources suggest alias reduction should indeed be performed on the
                 * lower two subbands of mixed blocks. Most other implementations do
                 * this, so by default we will too.
                 */
                if (channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) III_aliasreduce(xr[ch], 36);
            } else {
                III_aliasreduce(xr[ch], 576);
            }

            /* subbands 0-1 */
            if (channel.block_type != 2 || channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) {
                var block_type = channel.block_type;
                if (channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) block_type = 0;

                /* long blocks */
                for (var sb = 0; sb < 2; ++sb, l += 18) {
                    __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].III_imdct_l(xr[ch].slice(l, l + 18), output, block_type);
                    III_overlap(output, frame.overlap[ch][sb], sample, sb);

                    // var sys = require('sys');
                    // sys.print("\nblocktype: " + block_type + " sb: " + sb + "\n");
                    // for (var i = 0; i < 18; i++) {
                    //     sys.print(output[i].toFixed(8) + "\t");
                    //     if (i % 8 == 7) sys.print("\n");
                    // }
                }
            } else {
                /* short blocks */
                for (var sb = 0; sb < 2; ++sb, l += 18) {
                    III_imdct_s(xr[ch].slice(l, l + 18), output);
                    III_overlap(output, frame.overlap[ch][sb], sample, sb);
                }
            }

            III_freqinver(sample, 1);

            /* (nonzero) subbands 2-31 */
            i = 576;
            while (i > 36 && xr[ch][i - 1] == 0) --i;

            sblimit = 32 - ((576 - i) / 18 << 0);

            if (channel.block_type != 2) {
                /* long blocks */
                for (var sb = 2; sb < sblimit; ++sb, l += 18) {
                    __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].III_imdct_l(xr[ch].slice(l, l + 18), output, channel.block_type);
                    III_overlap(output, frame.overlap[ch][sb], sample, sb);

                    if (sb & 1) III_freqinver(sample, sb);
                }
            } else {
                /* short blocks */
                for (var sb = 2; sb < sblimit; ++sb, l += 18) {
                    III_imdct_s(xr[ch].slice(l, l + 18), output);
                    III_overlap(output, frame.overlap[ch][sb], sample, sb);

                    if (sb & 1) III_freqinver(sample, sb);
                }
            }

            // remaining (zero) subbands
            for (var sb = sblimit; sb < 32; ++sb) {
                III_overlap_z(frame.overlap[ch][sb], sample, sb);

                if (sb & 1) III_freqinver(sample, sb);
            }

            if (__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug) {
                for (var i = 0; i < 18; i++) {
                    __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.sample.write(__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.iteration * 18 + i + "\t");
                    for (var j = 0; j < 32; j++) {
                        __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.sample.write(sample[i][j].toFixed(8) + "\t");
                    }
                    __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.sample.write("\n");
                }
                __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].debug.iteration += 1;
            }
        }
    }

    return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.NONE;
};

/*
 * NAME:    layer.III()
 * DESCRIPTION: decode a single Layer III frame
 */
var layer_III = function (stream, frame) {
    var header = frame.header;
    var nch,
        next_md_begin = 0;
    var si_len,
        data_bitlen,
        md_len = 0;
    var frame_space, frame_used, frame_free;
    var /* Mad.Error */error;
    var ptr;
    var result = 0;

    /* allocate Layer III dynamic structures */
    nch = header.nchannels();
    si_len = header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.LSF_EXT ? nch == 1 ? 9 : 17 : nch == 1 ? 17 : 32;

    /* check frame sanity */
    if (stream.next_frame - stream.ptr.nextbyte() < si_len) {
        stream.error = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADFRAMELEN;
        stream.md_len = 0;
        return -1;
    }

    /* check CRC word */
    if (header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.PROTECTION) {
        header.crc_check = mad_bit_crc(stream.ptr, si_len * CHAR_BIT, header.crc_check);

        if (header.crc_check != header.crc_target && !(frame.options & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Option.IGNORECRC)) {
            stream.error = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADCRC;
            result = -1;
        }
    }

    /* decode frame side information */
    var sideinfoResult = III_sideinfo(stream.ptr, nch, header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.LSF_EXT);

    stream.ptr = sideinfoResult.ptr;
    var si = sideinfoResult.si;
    var data_bitlen = sideinfoResult.data_bitlen;
    var priv_bitlen = sideinfoResult.priv_bitlen;

    //console.log("We're at " + stream.ptr.offset + ", data_bitlen = " + data_bitlen + ", priv_bitlen = " + priv_bitlen);

    if (error && result == 0) {
        stream.error = error;
        result = -1;
    }

    header.flags |= priv_bitlen;
    header.private_bits |= si.private_bits;

    /* find main_data of next frame */
    {
        var peek = new __WEBPACK_IMPORTED_MODULE_3__bit__["a" /* default */](stream.stream, stream.next_frame);

        header = peek.read(32);

        if (__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].bitwiseAnd(header, 0xffe60000) /* syncword | layer */ == 0xffe20000) {
            if (!__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].bitwiseAnd(header, 0x00010000)) /* protection_bit */
                peek.skip(16); /* crc_check */

            next_md_begin = peek.read(__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].bitwiseAnd(header, 0x00080000) /* ID */ ? 9 : 8);
        }
    }

    /* find main_data of this frame */
    frame_space = stream.next_frame - stream.ptr.nextbyte();

    //console.log("next_frame = " + stream.next_frame + ", nextbyte = " + stream.ptr.nextbyte() + ", frame_space = " + frame_space);

    //console.log("before, next_md_begin = " + next_md_begin);

    if (next_md_begin > si.main_data_begin + frame_space) next_md_begin = 0;

    //console.log("so far, md_len = " + md_len + ", si.main_data_begin = " + si.main_data_begin + ", frame_space = " + frame_space + ", next_md_begin = " + next_md_begin);

    md_len = si.main_data_begin + frame_space - next_md_begin;

    frame_used = 0;

    if (si.main_data_begin == 0) {
        ptr = stream.ptr;
        stream.md_len = 0;

        frame_used = md_len;
    } else {
        //console.log("si.main_data_begin = " + si.main_data_begin + ", stream.md_len = " + stream.md_len);
        if (si.main_data_begin > stream.md_len) {
            if (result == 0) {
                stream.error = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADDATAPTR;
                result = -1;
            }
        } else {
            var old_md_len = stream.md_len;

            if (md_len > si.main_data_begin) {
                if (!(stream.md_len + md_len - si.main_data_begin <= __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].BUFFER_MDLEN)) {
                    throw new Error("Assertion failed: (stream.md_len + md_len - si.main_data_begin <= MAD_BUFFER_MDLEN)");
                }

                frame_used = md_len - si.main_data_begin;

                /* memcpy(dst, dstOffset, src, srcOffset, length) - returns a copy of dst with modified bytes */
                stream.main_data = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].memcpy(stream.main_data, stream.md_len, stream.ptr.stream, stream.ptr.nextbyte(), frame_used);

                /*
                // Keeping this here as a handy little reference
                memcpy(*stream.main_data + stream.md_len,
                mad_bit_nextbyte(&stream.ptr),
                frame_used = md_len - si.main_data_begin
                );
                */
                stream.md_len += frame_used;
            }

            ptr = new __WEBPACK_IMPORTED_MODULE_3__bit__["a" /* default */](stream.main_data, old_md_len - si.main_data_begin);
        }
    }

    frame_free = frame_space - frame_used;

    /* decode main_data */
    if (result == 0) {
        error = III_decode(ptr, frame, si, nch);

        if (error) {
            stream.error = error;
            result = -1;
        }

        /* designate ancillary bits */
        stream.anc_ptr = ptr;
        stream.anc_bitlen = md_len * CHAR_BIT - data_bitlen;
    }

    // DEBUG
    /*
      console.log(
      "main_data_begin:" + si.main_data_begin +
      ", md_len:" + md_len +
      ", frame_free:" + frame_free +
      ", data_bitlen:" + data_bitlen +
      ", anc_bitlen: " + stream.anc_bitlen);
    */

    /* preload main_data buffer with up to 511 bytes for next frame(s) */
    if (frame_free >= next_md_begin) {
        stream.main_data = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].memcpy(stream.main_data, 0, stream.stream, stream.next_frame - next_md_begin, next_md_begin);
        /*
        // Keeping here for reference
        memcpy(*stream.main_data, stream.next_frame - next_md_begin, next_md_begin);
        */
        stream.md_len = next_md_begin;
    } else {
        if (md_len < si.main_data_begin) {
            var extra = si.main_data_begin - md_len;
            if (extra + frame_free > next_md_begin) extra = next_md_begin - frame_free;

            if (extra < stream.md_len) {
                stream.main_data = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].memcpy(stream.main_data, 0, stream.main_data, stream.md_len - extra, extra);
                /*
                // Keeping here for reference
                memmove(*stream.main_data, *stream.main_data + stream.md_len - extra, extra);
                */
                stream.md_len = extra;
            }
        } else {
            stream.md_len = 0;
        }

        stream.main_data = __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].memcpy(stream.main_data, stream.md_len, stream.stream, stream.next_frame - frame_free, frame_free);
        /*
        // Keeping here for reference
        memcpy(*stream.main_data + stream.md_len, stream.next_frame - frame_free, frame_free);
        */
        stream.md_len += frame_free;
    }

    return result;
};

var III_exponents = function (channel, sfbwidth, exponents) {
    var gain = channel.global_gain - 210;
    var scalefac_multiplier = channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].scalefac_scale ? 2 : 1;

    if (channel.block_type == 2) {
        var sfbi = 0,
            l = 0;

        if (channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) {
            var premask = channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].preflag ? ~0 : 0;

            /* long block subbands 0-1 */

            while (l < 36) {
                exponents[sfbi] = gain - (channel.scalefac[sfbi] + (pretab[sfbi] & premask) << scalefac_multiplier);

                l += sfbwidth[sfbi++];
            }
        }

        /* this is probably wrong for 8000 Hz short/mixed blocks */

        var gain0 = gain - 8 * channel.subblock_gain[0];
        var gain1 = gain - 8 * channel.subblock_gain[1];
        var gain2 = gain - 8 * channel.subblock_gain[2];

        while (l < 576) {
            exponents[sfbi + 0] = gain0 - (channel.scalefac[sfbi + 0] << scalefac_multiplier);
            exponents[sfbi + 1] = gain1 - (channel.scalefac[sfbi + 1] << scalefac_multiplier);
            exponents[sfbi + 2] = gain2 - (channel.scalefac[sfbi + 2] << scalefac_multiplier);

            l += 3 * sfbwidth[sfbi];
            sfbi += 3;
        }
    } else {
        /* channel.block_type != 2 */
        if (channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].preflag) {
            for (var sfbi = 0; sfbi < 22; ++sfbi) {
                exponents[sfbi] = gain - (channel.scalefac[sfbi] + pretab[sfbi] << scalefac_multiplier);
            }
        } else {
            for (var sfbi = 0; sfbi < 22; ++sfbi) {
                exponents[sfbi] = gain - (channel.scalefac[sfbi] << scalefac_multiplier);
            }
        }
    }
};

var III_requantize = function (value, exp) {
    // usual (x >> 0) tricks to make sure frac and exp stay integers
    var frac = exp % 4 >> 0; /* assumes sign(frac) == sign(exp) */
    exp = exp / 4 >> 0;

    var requantized = Math.pow(value, 4.0 / 3.0);
    requantized *= Math.pow(2.0, exp / 4.0);

    if (frac) {
        requantized *= Math.pow(2.0, frac / 4.0);
    }

    if (exp < 0) {
        requantized /= Math.pow(2.0, -exp * (3.0 / 4.0));
    }

    return requantized;
};

var III_aliasreduce = function (xr, lines) {
    var xrPointer = 0;

    for (xrPointer += 18; xrPointer < lines; xrPointer += 18) {
        for (var i = 0; i < 8; ++i) {
            var a = xr[xrPointer - i - 1];
            var b = xr[xrPointer + i];

            var lo = a * cs[i] - b * ca[i];

            xr[xrPointer - i - 1] = lo;

            lo = b * cs[i] + a * ca[i];

            xr[xrPointer + i] = lo;
        }
    }
};

var III_overlap = function (output /* [36] */, overlap /* [18] */, sample /* [18][32] */, sb) {
    for (var i = 0; i < 18; ++i) {
        sample[i][sb] = output[i + 0] + overlap[i];
        overlap[i] = output[i + 18];
    }
};

var III_overlap_z = function (overlap /* [18] */, sample /* [18][32] */, sb) {
    for (var i = 0; i < 18; ++i) {
        sample[i][sb] = overlap[i];
        overlap[i] = 0;
    }
};

// allocating typed arrays once and for all, outside the function
// var reorder_tmp = new Float64Array(new ArrayBuffer(8 * 32 * 3 * 6));
// var reorder_sbw = new Float64Array(new ArrayBuffer(8 * 3));
// var reorder_sw  = new Float64Array(new ArrayBuffer(8 * 3));

var III_reorder = function (xr /* [576] */, channel, sfbwidth /* [39] */) {
    var sfbwidthPointer = 0;
    var tmp = [];

    for (var i = 0; i < 32; i++) {
        tmp[i] = [];
        for (var j = 0; j < 3; j++) {
            tmp[i][j] = [];
            for (var k = 0; k < 6; k++) {
                tmp[i][j][k] = 0;
            }
        }
    }

    var sbw = [];
    var sw = [];

    /* this is probably wrong for 8000 Hz mixed blocks */

    var sb = 0;
    if (channel.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) {
        var sb = 2;

        var l = 0;
        while (l < 36) l += sfbwidth[sfbwidthPointer++];
    }

    for (var w = 0; w < 3; ++w) {
        sbw[w] = sb;
        sw[w] = 0;
    }

    var f = sfbwidth[sfbwidthPointer++];
    var w = 0;

    for (var l = 18 * sb; l < 576; ++l) {
        if (f-- == 0) {
            f = sfbwidth[sfbwidthPointer++] - 1;
            w = (w + 1) % 3;
        }

        tmp[sbw[w]][w][sw[w]++] = xr[l];

        if (sw[w] == 6) {
            sw[w] = 0;
            ++sbw[w];
        }
    }

    var tmp2 = [];
    var ptr = 0;

    for (var i = 0; i < 32; i++) {
        for (var j = 0; j < 3; j++) {
            for (var k = 0; k < 6; k++) {
                tmp2[ptr++] = tmp[i][j][k];
            }
        }
    }

    var len = 576 - 18 * sb;

    for (var i = 0; i < len; i++) {
        xr[18 * sb + i] = tmp2[sb + i];
    }
};

var III_stereo = function (xr /* [2][576] */, granule, header, sfbwidth) {
    var modes = [];
    var sfbi, l, n, i;

    if (granule.ch[0].block_type != granule.ch[1].block_type || (granule.ch[0].flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) != (granule.ch[1].flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag)) return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.BADSTEREO;

    for (i = 0; i < 39; ++i) modes[i] = header.mode_extension;

    /* intensity stereo */

    if (header.mode_extension & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO) {
        var right_ch = granule.ch[1];
        var right_xr = xr[1];
        var is_pos;

        header.flags |= __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.I_STEREO;

        /* first determine which scalefactor bands are to be processed */

        if (right_ch.block_type == 2) {
            var lower,
                start,
                max,
                bound = [],
                w;

            lower = start = max = bound[0] = bound[1] = bound[2] = 0;

            sfbi = l = 0;

            if (right_ch.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].mixed_block_flag) {
                while (l < 36) {
                    n = sfbwidth[sfbi++];

                    for (i = 0; i < n; ++i) {
                        if (right_xr[i]) {
                            lower = sfbi;
                            break;
                        }
                    }

                    right_xr += n;
                    l += n;
                }

                start = sfbi;
            }

            w = 0;
            while (l < 576) {
                n = sfbwidth[sfbi++];

                for (i = 0; i < n; ++i) {
                    if (right_xr[i]) {
                        max = bound[w] = sfbi;
                        break;
                    }
                }

                right_xr += n;
                l += n;
                w = (w + 1) % 3;
            }

            if (max) lower = start;

            /* long blocks */

            for (i = 0; i < lower; ++i) modes[i] = header.mode_extension & ~__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO;

            /* short blocks */

            w = 0;
            for (i = start; i < max; ++i) {
                if (i < bound[w]) modes[i] = header.mode_extension & ~__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO;

                w = (w + 1) % 3;
            }
        } else {
            /* right_ch.block_type != 2 */
            var bound;

            bound = 0;
            for (sfbi = l = 0; l < 576; l += n) {
                n = sfbwidth[sfbi++];

                for (i = 0; i < n; ++i) {
                    if (right_xr[i]) {
                        bound = sfbi;
                        break;
                    }
                }

                right_xr += n;
            }

            for (i = 0; i < bound; ++i) modes[i] = header.mode_extension & ~__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO;
        }

        /* now do the actual processing */

        if (header.flags & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.LSF_EXT) {
            illegal_pos = granule[1].ch[1].scalefac;
            var lsf_scale;

            /* intensity_scale */
            lsf_scale = is_lsf_table[right_ch.scalefac_compress & 0x1];

            for (sfbi = l = 0; l < 576; ++sfbi, l += n) {
                n = sfbwidth[sfbi];

                if (!(modes[sfbi] & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO)) continue;

                if (illegal_pos[sfbi]) {
                    modes[sfbi] &= ~__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO;
                    continue;
                }

                is_pos = right_ch.scalefac[sfbi];

                for (i = 0; i < n; ++i) {
                    var left;

                    left = xr[0][l + i];

                    if (is_pos == 0) xr[1][l + i] = left;else {
                        var opposite;

                        opposite = left * lsf_scale[(is_pos - 1) / 2];

                        if (is_pos & 1) {
                            xr[0][l + i] = opposite;
                            xr[1][l + i] = left;
                        } else xr[1][l + i] = opposite;
                    }
                }
            }
        } else {
            /* !(header.flags & MAD_FLAG_LSF_EXT) */
            for (sfbi = l = 0; l < 576; ++sfbi, l += n) {
                n = sfbwidth[sfbi];

                if (!(modes[sfbi] & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO)) continue;

                is_pos = right_ch.scalefac[sfbi];

                if (is_pos >= 7) {
                    /* illegal intensity position */
                    modes[sfbi] &= ~__WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].I_STEREO;
                    continue;
                }

                for (i = 0; i < n; ++i) {
                    var left;

                    left = xr[0][l + i];

                    xr[0][l + i] = left * is_table[is_pos];
                    xr[1][l + i] = left * is_table[6 - is_pos];
                }
            }
        }
    }

    /* middle/side stereo */

    if (header.mode_extension & __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].MS_STEREO) {
        var invsqrt2;

        header.flags |= __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Flag.MS_STEREO;

        invsqrt2 = root_table[3 + -2];

        for (sfbi = l = 0; l < 576; ++sfbi, l += n) {
            n = sfbwidth[sfbi];

            if (modes[sfbi] != __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].MS_STEREO) continue;

            for (i = 0; i < n; ++i) {
                var m, s;

                m = xr[0][l + i];
                s = xr[1][l + i];

                xr[0][l + i] = (m + s) * invsqrt2; /* l = (m + s) / sqrt(2) */
                xr[1][l + i] = (m - s) * invsqrt2; /* r = (m - s) / sqrt(2) */
            }
        }
    }

    return __WEBPACK_IMPORTED_MODULE_2__global__["a" /* default */].Error.NONE;
};

/* harmony default export */ __webpack_exports__["a"] = (layer_III);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

/*
 * These are the Huffman code words for Layer III.
 * The data for these tables are derived from Table B.7 of ISO/IEC 11172-3.
 *
 * These tables support decoding up to 4 Huffman code bits at a time.
 */

/*
union huffquad {
  struct {
    unsigned short final  :  1;
    unsigned short bits   :  3;
    unsigned short offset : 12;
  } ptr;
  struct {
    unsigned short final  :  1;
    unsigned short hlen   :  3;
    unsigned short v      :  1;
    unsigned short w      :  1;
    unsigned short x      :  1;
    unsigned short y      :  1;
  } value;
  unsigned short final    :  1;
};

union huffpair {
  struct {
    unsigned short final  :  1;
    unsigned short bits   :  3;
    unsigned short offset : 12;
  } ptr;
  struct {
    unsigned short final  :  1;
    unsigned short hlen   :  3;
    unsigned short x      :  4;
    unsigned short y      :  4;
  } value;
  unsigned short final    :  1;
};

struct hufftable {
  union huffpair const *table;
  unsigned short linbits;
  unsigned short startbits;
};
*/

//extern union huffquad const *const mad_huff_quad_table[2];
//extern struct hufftable const mad_huff_pair_table[32];

var PTR = function (offs, bits) {
  return {
    'final': 0, // final is a reserved word in JavaScript and GSC will complain about it.
    ptr: {
      bits: bits,
      offset: offs
    }
  };
};

var huffquad_V = function (v, w, x, y, hlen) {
  return {
    'final': 1, // final is a reserved word in JavaScript and GSC will complain about it.
    value: {
      v: v,
      w: w,
      x: x,
      y: y
    }
  };
};

/*
# if defined(__GNUC__) ||  \
    (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901)
#  define PTR(offs, bits)	{ .ptr   = { 0, bits, offs       } }
#  define V(v, w, x, y, hlen)	{ .value = { 1, hlen, v, w, x, y } }
# else
#  define PTR(offs, bits)	{ { 0, bits, offs } }
#  if defined(WORDS_BIGENDIAN)
#   define V(v, w, x, y, hlen)	{ { 1, hlen, (v << 11) | (w << 10) | (x <<  9) | (y <<  8) } }
#  else
#   define V(v, w, x, y, hlen)	{ { 1, hlen, (v <<  0) | (w <<  1) | (x <<  2) | (y <<  3) } }
#  endif
# endif
*/

/* huffquad */var hufftabA = [
/* 0000 */PTR(16, 2),
/* 0001 */PTR(20, 2),
/* 0010 */PTR(24, 1),
/* 0011 */PTR(26, 1),
/* 0100 */huffquad_V(0, 0, 1, 0, 4),
/* 0101 */huffquad_V(0, 0, 0, 1, 4),
/* 0110 */huffquad_V(0, 1, 0, 0, 4),
/* 0111 */huffquad_V(1, 0, 0, 0, 4),
/* 1000 */huffquad_V(0, 0, 0, 0, 1),
/* 1001 */huffquad_V(0, 0, 0, 0, 1),
/* 1010 */huffquad_V(0, 0, 0, 0, 1),
/* 1011 */huffquad_V(0, 0, 0, 0, 1),
/* 1100 */huffquad_V(0, 0, 0, 0, 1),
/* 1101 */huffquad_V(0, 0, 0, 0, 1),
/* 1110 */huffquad_V(0, 0, 0, 0, 1),
/* 1111 */huffquad_V(0, 0, 0, 0, 1),

/* 0000 ... */
/* 00   */huffquad_V(1, 0, 1, 1, 2), /* 16 */
/* 01   */huffquad_V(1, 1, 1, 1, 2),
/* 10   */huffquad_V(1, 1, 0, 1, 2),
/* 11   */huffquad_V(1, 1, 1, 0, 2),

/* 0001 ... */
/* 00   */huffquad_V(0, 1, 1, 1, 2), /* 20 */
/* 01   */huffquad_V(0, 1, 0, 1, 2),
/* 10   */huffquad_V(1, 0, 0, 1, 1),
/* 11   */huffquad_V(1, 0, 0, 1, 1),

/* 0010 ... */
/* 0    */huffquad_V(0, 1, 1, 0, 1), /* 24 */
/* 1    */huffquad_V(0, 0, 1, 1, 1),

/* 0011 ... */
/* 0    */huffquad_V(1, 0, 1, 0, 1), /* 26 */
/* 1    */huffquad_V(1, 1, 0, 0, 1)];

/* huffquad */var hufftabB = [
/* 0000 */huffquad_V(1, 1, 1, 1, 4),
/* 0001 */huffquad_V(1, 1, 1, 0, 4),
/* 0010 */huffquad_V(1, 1, 0, 1, 4),
/* 0011 */huffquad_V(1, 1, 0, 0, 4),
/* 0100 */huffquad_V(1, 0, 1, 1, 4),
/* 0101 */huffquad_V(1, 0, 1, 0, 4),
/* 0110 */huffquad_V(1, 0, 0, 1, 4),
/* 0111 */huffquad_V(1, 0, 0, 0, 4),
/* 1000 */huffquad_V(0, 1, 1, 1, 4),
/* 1001 */huffquad_V(0, 1, 1, 0, 4),
/* 1010 */huffquad_V(0, 1, 0, 1, 4),
/* 1011 */huffquad_V(0, 1, 0, 0, 4),
/* 1100 */huffquad_V(0, 0, 1, 1, 4),
/* 1101 */huffquad_V(0, 0, 1, 0, 4),
/* 1110 */huffquad_V(0, 0, 0, 1, 4),
/* 1111 */huffquad_V(0, 0, 0, 0, 4)];

/*
# undef V
# undef PTR

# if defined(__GNUC__) ||  \
    (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901)
#  define PTR(offs, bits)	{ .ptr   = { 0, bits, offs } }
#  define V(x, y, hlen)		{ .value = { 1, hlen, x, y } }
# else
#  define PTR(offs, bits)	{ { 0, bits, offs } }
#  if defined(WORDS_BIGENDIAN)
#   define V(x, y, hlen)	{ { 1, hlen, (x << 8) | (y << 4) } }
#  else
#   define V(x, y, hlen)	{ { 1, hlen, (x << 0) | (y << 4) } }
#  endif
# endif
*/

var V = function (x, y, hlen) {
  return {
    'final': 1, // final is a reserved word in JavaScript and GSC will complain about it.
    value: {
      x: x,
      y: y,
      hlen: hlen
    }
  };
};

var hufftab0 = [
/*      */V(0, 0, 0)];

var hufftab1 = [
/* 000  */V(1, 1, 3),
/* 001  */V(0, 1, 3),
/* 010  */V(1, 0, 2),
/* 011  */V(1, 0, 2),
/* 100  */V(0, 0, 1),
/* 101  */V(0, 0, 1),
/* 110  */V(0, 0, 1),
/* 111  */V(0, 0, 1)];

var hufftab2 = [
/* 000  */PTR(8, 3),
/* 001  */V(1, 1, 3),
/* 010  */V(0, 1, 3),
/* 011  */V(1, 0, 3),
/* 100  */V(0, 0, 1),
/* 101  */V(0, 0, 1),
/* 110  */V(0, 0, 1),
/* 111  */V(0, 0, 1),

/* 000 ... */
/* 000  */V(2, 2, 3), /* 8 */
/* 001  */V(0, 2, 3),
/* 010  */V(1, 2, 2),
/* 011  */V(1, 2, 2),
/* 100  */V(2, 1, 2),
/* 101  */V(2, 1, 2),
/* 110  */V(2, 0, 2),
/* 111  */V(2, 0, 2)];

var hufftab3 = [
/* 000  */PTR(8, 3),
/* 001  */V(1, 0, 3),
/* 010  */V(1, 1, 2),
/* 011  */V(1, 1, 2),
/* 100  */V(0, 1, 2),
/* 101  */V(0, 1, 2),
/* 110  */V(0, 0, 2),
/* 111  */V(0, 0, 2),

/* 000 ... */
/* 000  */V(2, 2, 3), /* 8 */
/* 001  */V(0, 2, 3),
/* 010  */V(1, 2, 2),
/* 011  */V(1, 2, 2),
/* 100  */V(2, 1, 2),
/* 101  */V(2, 1, 2),
/* 110  */V(2, 0, 2),
/* 111  */V(2, 0, 2)];

var hufftab5 = [
/* 000  */PTR(8, 4),
/* 001  */V(1, 1, 3),
/* 010  */V(0, 1, 3),
/* 011  */V(1, 0, 3),
/* 100  */V(0, 0, 1),
/* 101  */V(0, 0, 1),
/* 110  */V(0, 0, 1),
/* 111  */V(0, 0, 1),

/* 000 ... */
/* 0000 */PTR(24, 1), /* 8 */
/* 0001 */V(3, 2, 4),
/* 0010 */V(3, 1, 3),
/* 0011 */V(3, 1, 3),
/* 0100 */V(1, 3, 4),
/* 0101 */V(0, 3, 4),
/* 0110 */V(3, 0, 4),
/* 0111 */V(2, 2, 4),
/* 1000 */V(1, 2, 3),
/* 1001 */V(1, 2, 3),
/* 1010 */V(2, 1, 3),
/* 1011 */V(2, 1, 3),
/* 1100 */V(0, 2, 3),
/* 1101 */V(0, 2, 3),
/* 1110 */V(2, 0, 3),
/* 1111 */V(2, 0, 3),

/* 000 0000 ... */
/* 0    */V(3, 3, 1), /* 24 */
/* 1    */V(2, 3, 1)];

var hufftab6 = [
/* 0000 */PTR(16, 3),
/* 0001 */PTR(24, 1),
/* 0010 */PTR(26, 1),
/* 0011 */V(1, 2, 4),
/* 0100 */V(2, 1, 4),
/* 0101 */V(2, 0, 4),
/* 0110 */V(0, 1, 3),
/* 0111 */V(0, 1, 3),
/* 1000 */V(1, 1, 2),
/* 1001 */V(1, 1, 2),
/* 1010 */V(1, 1, 2),
/* 1011 */V(1, 1, 2),
/* 1100 */V(1, 0, 3),
/* 1101 */V(1, 0, 3),
/* 1110 */V(0, 0, 3),
/* 1111 */V(0, 0, 3),

/* 0000 ... */
/* 000  */V(3, 3, 3), /* 16 */
/* 001  */V(0, 3, 3),
/* 010  */V(2, 3, 2),
/* 011  */V(2, 3, 2),
/* 100  */V(3, 2, 2),
/* 101  */V(3, 2, 2),
/* 110  */V(3, 0, 2),
/* 111  */V(3, 0, 2),

/* 0001 ... */
/* 0    */V(1, 3, 1), /* 24 */
/* 1    */V(3, 1, 1),

/* 0010 ... */
/* 0    */V(2, 2, 1), /* 26 */
/* 1    */V(0, 2, 1)];

var hufftab7 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 2),
/* 0011 */V(1, 1, 4),
/* 0100 */V(0, 1, 3),
/* 0101 */V(0, 1, 3),
/* 0110 */V(1, 0, 3),
/* 0111 */V(1, 0, 3),
/* 1000 */V(0, 0, 1),
/* 1001 */V(0, 0, 1),
/* 1010 */V(0, 0, 1),
/* 1011 */V(0, 0, 1),
/* 1100 */V(0, 0, 1),
/* 1101 */V(0, 0, 1),
/* 1110 */V(0, 0, 1),
/* 1111 */V(0, 0, 1),

/* 0000 ... */
/* 0000 */PTR(52, 2), /* 16 */
/* 0001 */PTR(56, 1),
/* 0010 */PTR(58, 1),
/* 0011 */V(1, 5, 4),
/* 0100 */V(5, 1, 4),
/* 0101 */PTR(60, 1),
/* 0110 */V(5, 0, 4),
/* 0111 */PTR(62, 1),
/* 1000 */V(2, 4, 4),
/* 1001 */V(4, 2, 4),
/* 1010 */V(1, 4, 3),
/* 1011 */V(1, 4, 3),
/* 1100 */V(4, 1, 3),
/* 1101 */V(4, 1, 3),
/* 1110 */V(4, 0, 3),
/* 1111 */V(4, 0, 3),

/* 0001 ... */
/* 0000 */V(0, 4, 4), /* 32 */
/* 0001 */V(2, 3, 4),
/* 0010 */V(3, 2, 4),
/* 0011 */V(0, 3, 4),
/* 0100 */V(1, 3, 3),
/* 0101 */V(1, 3, 3),
/* 0110 */V(3, 1, 3),
/* 0111 */V(3, 1, 3),
/* 1000 */V(3, 0, 3),
/* 1001 */V(3, 0, 3),
/* 1010 */V(2, 2, 3),
/* 1011 */V(2, 2, 3),
/* 1100 */V(1, 2, 2),
/* 1101 */V(1, 2, 2),
/* 1110 */V(1, 2, 2),
/* 1111 */V(1, 2, 2),

/* 0010 ... */
/* 00   */V(2, 1, 1), /* 48 */
/* 01   */V(2, 1, 1),
/* 10   */V(0, 2, 2),
/* 11   */V(2, 0, 2),

/* 0000 0000 ... */
/* 00   */V(5, 5, 2), /* 52 */
/* 01   */V(4, 5, 2),
/* 10   */V(5, 4, 2),
/* 11   */V(5, 3, 2),

/* 0000 0001 ... */
/* 0    */V(3, 5, 1), /* 56 */
/* 1    */V(4, 4, 1),

/* 0000 0010 ... */
/* 0    */V(2, 5, 1), /* 58 */
/* 1    */V(5, 2, 1),

/* 0000 0101 ... */
/* 0    */V(0, 5, 1), /* 60 */
/* 1    */V(3, 4, 1),

/* 0000 0111 ... */
/* 0    */V(4, 3, 1), /* 62 */
/* 1    */V(3, 3, 1)];

var hufftab8 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */V(1, 2, 4),
/* 0011 */V(2, 1, 4),
/* 0100 */V(1, 1, 2),
/* 0101 */V(1, 1, 2),
/* 0110 */V(1, 1, 2),
/* 0111 */V(1, 1, 2),
/* 1000 */V(0, 1, 3),
/* 1001 */V(0, 1, 3),
/* 1010 */V(1, 0, 3),
/* 1011 */V(1, 0, 3),
/* 1100 */V(0, 0, 2),
/* 1101 */V(0, 0, 2),
/* 1110 */V(0, 0, 2),
/* 1111 */V(0, 0, 2),

/* 0000 ... */
/* 0000 */PTR(48, 3), /* 16 */
/* 0001 */PTR(56, 2),
/* 0010 */PTR(60, 1),
/* 0011 */V(1, 5, 4),
/* 0100 */V(5, 1, 4),
/* 0101 */PTR(62, 1),
/* 0110 */PTR(64, 1),
/* 0111 */V(2, 4, 4),
/* 1000 */V(4, 2, 4),
/* 1001 */V(1, 4, 4),
/* 1010 */V(4, 1, 3),
/* 1011 */V(4, 1, 3),
/* 1100 */V(0, 4, 4),
/* 1101 */V(4, 0, 4),
/* 1110 */V(2, 3, 4),
/* 1111 */V(3, 2, 4),

/* 0001 ... */
/* 0000 */V(1, 3, 4), /* 32 */
/* 0001 */V(3, 1, 4),
/* 0010 */V(0, 3, 4),
/* 0011 */V(3, 0, 4),
/* 0100 */V(2, 2, 2),
/* 0101 */V(2, 2, 2),
/* 0110 */V(2, 2, 2),
/* 0111 */V(2, 2, 2),
/* 1000 */V(0, 2, 2),
/* 1001 */V(0, 2, 2),
/* 1010 */V(0, 2, 2),
/* 1011 */V(0, 2, 2),
/* 1100 */V(2, 0, 2),
/* 1101 */V(2, 0, 2),
/* 1110 */V(2, 0, 2),
/* 1111 */V(2, 0, 2),

/* 0000 0000 ... */
/* 000  */V(5, 5, 3), /* 48 */
/* 001  */V(5, 4, 3),
/* 010  */V(4, 5, 2),
/* 011  */V(4, 5, 2),
/* 100  */V(5, 3, 1),
/* 101  */V(5, 3, 1),
/* 110  */V(5, 3, 1),
/* 111  */V(5, 3, 1),

/* 0000 0001 ... */
/* 00   */V(3, 5, 2), /* 56 */
/* 01   */V(4, 4, 2),
/* 10   */V(2, 5, 1),
/* 11   */V(2, 5, 1),

/* 0000 0010 ... */
/* 0    */V(5, 2, 1), /* 60 */
/* 1    */V(0, 5, 1),

/* 0000 0101 ... */
/* 0    */V(3, 4, 1), /* 62 */
/* 1    */V(4, 3, 1),

/* 0000 0110 ... */
/* 0    */V(5, 0, 1), /* 64 */
/* 1    */V(3, 3, 1)];

var hufftab9 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 3),
/* 0010 */PTR(40, 2),
/* 0011 */PTR(44, 2),
/* 0100 */PTR(48, 1),
/* 0101 */V(1, 2, 4),
/* 0110 */V(2, 1, 4),
/* 0111 */V(2, 0, 4),
/* 1000 */V(1, 1, 3),
/* 1001 */V(1, 1, 3),
/* 1010 */V(0, 1, 3),
/* 1011 */V(0, 1, 3),
/* 1100 */V(1, 0, 3),
/* 1101 */V(1, 0, 3),
/* 1110 */V(0, 0, 3),
/* 1111 */V(0, 0, 3),

/* 0000 ... */
/* 0000 */PTR(50, 1), /* 16 */
/* 0001 */V(3, 5, 4),
/* 0010 */V(5, 3, 4),
/* 0011 */PTR(52, 1),
/* 0100 */V(4, 4, 4),
/* 0101 */V(2, 5, 4),
/* 0110 */V(5, 2, 4),
/* 0111 */V(1, 5, 4),
/* 1000 */V(5, 1, 3),
/* 1001 */V(5, 1, 3),
/* 1010 */V(3, 4, 3),
/* 1011 */V(3, 4, 3),
/* 1100 */V(4, 3, 3),
/* 1101 */V(4, 3, 3),
/* 1110 */V(5, 0, 4),
/* 1111 */V(0, 4, 4),

/* 0001 ... */
/* 000  */V(2, 4, 3), /* 32 */
/* 001  */V(4, 2, 3),
/* 010  */V(3, 3, 3),
/* 011  */V(4, 0, 3),
/* 100  */V(1, 4, 2),
/* 101  */V(1, 4, 2),
/* 110  */V(4, 1, 2),
/* 111  */V(4, 1, 2),

/* 0010 ... */
/* 00   */V(2, 3, 2), /* 40 */
/* 01   */V(3, 2, 2),
/* 10   */V(1, 3, 1),
/* 11   */V(1, 3, 1),

/* 0011 ... */
/* 00   */V(3, 1, 1), /* 44 */
/* 01   */V(3, 1, 1),
/* 10   */V(0, 3, 2),
/* 11   */V(3, 0, 2),

/* 0100 ... */
/* 0    */V(2, 2, 1), /* 48 */
/* 1    */V(0, 2, 1),

/* 0000 0000 ... */
/* 0    */V(5, 5, 1), /* 50 */
/* 1    */V(4, 5, 1),

/* 0000 0011 ... */
/* 0    */V(5, 4, 1), /* 52 */
/* 1    */V(0, 5, 1)];

var hufftab10 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 2),
/* 0011 */V(1, 1, 4),
/* 0100 */V(0, 1, 3),
/* 0101 */V(0, 1, 3),
/* 0110 */V(1, 0, 3),
/* 0111 */V(1, 0, 3),
/* 1000 */V(0, 0, 1),
/* 1001 */V(0, 0, 1),
/* 1010 */V(0, 0, 1),
/* 1011 */V(0, 0, 1),
/* 1100 */V(0, 0, 1),
/* 1101 */V(0, 0, 1),
/* 1110 */V(0, 0, 1),
/* 1111 */V(0, 0, 1),

/* 0000 ... */
/* 0000 */PTR(52, 3), /* 16 */
/* 0001 */PTR(60, 2),
/* 0010 */PTR(64, 3),
/* 0011 */PTR(72, 1),
/* 0100 */PTR(74, 2),
/* 0101 */PTR(78, 2),
/* 0110 */PTR(82, 2),
/* 0111 */V(1, 7, 4),
/* 1000 */V(7, 1, 4),
/* 1001 */PTR(86, 1),
/* 1010 */PTR(88, 2),
/* 1011 */PTR(92, 2),
/* 1100 */V(1, 6, 4),
/* 1101 */V(6, 1, 4),
/* 1110 */V(6, 0, 4),
/* 1111 */PTR(96, 1),

/* 0001 ... */
/* 0000 */PTR(98, 1), /* 32 */
/* 0001 */PTR(100, 1),
/* 0010 */V(1, 4, 4),
/* 0011 */V(4, 1, 4),
/* 0100 */V(4, 0, 4),
/* 0101 */V(2, 3, 4),
/* 0110 */V(3, 2, 4),
/* 0111 */V(0, 3, 4),
/* 1000 */V(1, 3, 3),
/* 1001 */V(1, 3, 3),
/* 1010 */V(3, 1, 3),
/* 1011 */V(3, 1, 3),
/* 1100 */V(3, 0, 3),
/* 1101 */V(3, 0, 3),
/* 1110 */V(2, 2, 3),
/* 1111 */V(2, 2, 3),

/* 0010 ... */
/* 00   */V(1, 2, 2), /* 48 */
/* 01   */V(2, 1, 2),
/* 10   */V(0, 2, 2),
/* 11   */V(2, 0, 2),

/* 0000 0000 ... */
/* 000  */V(7, 7, 3), /* 52 */
/* 001  */V(6, 7, 3),
/* 010  */V(7, 6, 3),
/* 011  */V(5, 7, 3),
/* 100  */V(7, 5, 3),
/* 101  */V(6, 6, 3),
/* 110  */V(4, 7, 2),
/* 111  */V(4, 7, 2),

/* 0000 0001 ... */
/* 00   */V(7, 4, 2), /* 60 */
/* 01   */V(5, 6, 2),
/* 10   */V(6, 5, 2),
/* 11   */V(3, 7, 2),

/* 0000 0010 ... */
/* 000  */V(7, 3, 2), /* 64 */
/* 001  */V(7, 3, 2),
/* 010  */V(4, 6, 2),
/* 011  */V(4, 6, 2),
/* 100  */V(5, 5, 3),
/* 101  */V(5, 4, 3),
/* 110  */V(6, 3, 2),
/* 111  */V(6, 3, 2),

/* 0000 0011 ... */
/* 0    */V(2, 7, 1), /* 72 */
/* 1    */V(7, 2, 1),

/* 0000 0100 ... */
/* 00   */V(6, 4, 2), /* 74 */
/* 01   */V(0, 7, 2),
/* 10   */V(7, 0, 1),
/* 11   */V(7, 0, 1),

/* 0000 0101 ... */
/* 00   */V(6, 2, 1), /* 78 */
/* 01   */V(6, 2, 1),
/* 10   */V(4, 5, 2),
/* 11   */V(3, 5, 2),

/* 0000 0110 ... */
/* 00   */V(0, 6, 1), /* 82 */
/* 01   */V(0, 6, 1),
/* 10   */V(5, 3, 2),
/* 11   */V(4, 4, 2),

/* 0000 1001 ... */
/* 0    */V(3, 6, 1), /* 86 */
/* 1    */V(2, 6, 1),

/* 0000 1010 ... */
/* 00   */V(2, 5, 2), /* 88 */
/* 01   */V(5, 2, 2),
/* 10   */V(1, 5, 1),
/* 11   */V(1, 5, 1),

/* 0000 1011 ... */
/* 00   */V(5, 1, 1), /* 92 */
/* 01   */V(5, 1, 1),
/* 10   */V(3, 4, 2),
/* 11   */V(4, 3, 2),

/* 0000 1111 ... */
/* 0    */V(0, 5, 1), /* 96 */
/* 1    */V(5, 0, 1),

/* 0001 0000 ... */
/* 0    */V(2, 4, 1), /* 98 */
/* 1    */V(4, 2, 1),

/* 0001 0001 ... */
/* 0    */V(3, 3, 1), /* 100 */
/* 1    */V(0, 4, 1)];

var hufftab11 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */PTR(64, 3),
/* 0100 */V(1, 2, 4),
/* 0101 */PTR(72, 1),
/* 0110 */V(1, 1, 3),
/* 0111 */V(1, 1, 3),
/* 1000 */V(0, 1, 3),
/* 1001 */V(0, 1, 3),
/* 1010 */V(1, 0, 3),
/* 1011 */V(1, 0, 3),
/* 1100 */V(0, 0, 2),
/* 1101 */V(0, 0, 2),
/* 1110 */V(0, 0, 2),
/* 1111 */V(0, 0, 2),

/* 0000 ... */
/* 0000 */PTR(74, 2), /* 16 */
/* 0001 */PTR(78, 3),
/* 0010 */PTR(86, 2),
/* 0011 */PTR(90, 1),
/* 0100 */PTR(92, 2),
/* 0101 */V(2, 7, 4),
/* 0110 */V(7, 2, 4),
/* 0111 */PTR(96, 1),
/* 1000 */V(7, 1, 3),
/* 1001 */V(7, 1, 3),
/* 1010 */V(1, 7, 4),
/* 1011 */V(7, 0, 4),
/* 1100 */V(3, 6, 4),
/* 1101 */V(6, 3, 4),
/* 1110 */V(6, 0, 4),
/* 1111 */PTR(98, 1),

/* 0001 ... */
/* 0000 */PTR(100, 1), /* 32 */
/* 0001 */V(1, 5, 4),
/* 0010 */V(6, 2, 3),
/* 0011 */V(6, 2, 3),
/* 0100 */V(2, 6, 4),
/* 0101 */V(0, 6, 4),
/* 0110 */V(1, 6, 3),
/* 0111 */V(1, 6, 3),
/* 1000 */V(6, 1, 3),
/* 1001 */V(6, 1, 3),
/* 1010 */V(5, 1, 4),
/* 1011 */V(3, 4, 4),
/* 1100 */V(5, 0, 4),
/* 1101 */PTR(102, 1),
/* 1110 */V(2, 4, 4),
/* 1111 */V(4, 2, 4),

/* 0010 ... */
/* 0000 */V(1, 4, 4), /* 48 */
/* 0001 */V(4, 1, 4),
/* 0010 */V(0, 4, 4),
/* 0011 */V(4, 0, 4),
/* 0100 */V(2, 3, 3),
/* 0101 */V(2, 3, 3),
/* 0110 */V(3, 2, 3),
/* 0111 */V(3, 2, 3),
/* 1000 */V(1, 3, 2),
/* 1001 */V(1, 3, 2),
/* 1010 */V(1, 3, 2),
/* 1011 */V(1, 3, 2),
/* 1100 */V(3, 1, 2),
/* 1101 */V(3, 1, 2),
/* 1110 */V(3, 1, 2),
/* 1111 */V(3, 1, 2),

/* 0011 ... */
/* 000  */V(0, 3, 3), /* 64 */
/* 001  */V(3, 0, 3),
/* 010  */V(2, 2, 2),
/* 011  */V(2, 2, 2),
/* 100  */V(2, 1, 1),
/* 101  */V(2, 1, 1),
/* 110  */V(2, 1, 1),
/* 111  */V(2, 1, 1),

/* 0101 ... */
/* 0    */V(0, 2, 1), /* 72 */
/* 1    */V(2, 0, 1),

/* 0000 0000 ... */
/* 00   */V(7, 7, 2), /* 74 */
/* 01   */V(6, 7, 2),
/* 10   */V(7, 6, 2),
/* 11   */V(7, 5, 2),

/* 0000 0001 ... */
/* 000  */V(6, 6, 2), /* 78 */
/* 001  */V(6, 6, 2),
/* 010  */V(4, 7, 2),
/* 011  */V(4, 7, 2),
/* 100  */V(7, 4, 2),
/* 101  */V(7, 4, 2),
/* 110  */V(5, 7, 3),
/* 111  */V(5, 5, 3),

/* 0000 0010 ... */
/* 00   */V(5, 6, 2), /* 86 */
/* 01   */V(6, 5, 2),
/* 10   */V(3, 7, 1),
/* 11   */V(3, 7, 1),

/* 0000 0011 ... */
/* 0    */V(7, 3, 1), /* 90 */
/* 1    */V(4, 6, 1),

/* 0000 0100 ... */
/* 00   */V(4, 5, 2), /* 92 */
/* 01   */V(5, 4, 2),
/* 10   */V(3, 5, 2),
/* 11   */V(5, 3, 2),

/* 0000 0111 ... */
/* 0    */V(6, 4, 1), /* 96 */
/* 1    */V(0, 7, 1),

/* 0000 1111 ... */
/* 0    */V(4, 4, 1), /* 98 */
/* 1    */V(2, 5, 1),

/* 0001 0000 ... */
/* 0    */V(5, 2, 1), /* 100 */
/* 1    */V(0, 5, 1),

/* 0001 1101 ... */
/* 0    */V(4, 3, 1), /* 102 */
/* 1    */V(3, 3, 1)];

var hufftab12 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */PTR(64, 2),
/* 0100 */PTR(68, 3),
/* 0101 */PTR(76, 1),
/* 0110 */V(1, 2, 4),
/* 0111 */V(2, 1, 4),
/* 1000 */PTR(78, 1),
/* 1001 */V(0, 0, 4),
/* 1010 */V(1, 1, 3),
/* 1011 */V(1, 1, 3),
/* 1100 */V(0, 1, 3),
/* 1101 */V(0, 1, 3),
/* 1110 */V(1, 0, 3),
/* 1111 */V(1, 0, 3),

/* 0000 ... */
/* 0000 */PTR(80, 2), /* 16 */
/* 0001 */PTR(84, 1),
/* 0010 */PTR(86, 1),
/* 0011 */PTR(88, 1),
/* 0100 */V(5, 6, 4),
/* 0101 */V(3, 7, 4),
/* 0110 */PTR(90, 1),
/* 0111 */V(2, 7, 4),
/* 1000 */V(7, 2, 4),
/* 1001 */V(4, 6, 4),
/* 1010 */V(6, 4, 4),
/* 1011 */V(1, 7, 4),
/* 1100 */V(7, 1, 4),
/* 1101 */PTR(92, 1),
/* 1110 */V(3, 6, 4),
/* 1111 */V(6, 3, 4),

/* 0001 ... */
/* 0000 */V(4, 5, 4), /* 32 */
/* 0001 */V(5, 4, 4),
/* 0010 */V(4, 4, 4),
/* 0011 */PTR(94, 1),
/* 0100 */V(2, 6, 3),
/* 0101 */V(2, 6, 3),
/* 0110 */V(6, 2, 3),
/* 0111 */V(6, 2, 3),
/* 1000 */V(6, 1, 3),
/* 1001 */V(6, 1, 3),
/* 1010 */V(1, 6, 4),
/* 1011 */V(6, 0, 4),
/* 1100 */V(3, 5, 4),
/* 1101 */V(5, 3, 4),
/* 1110 */V(2, 5, 4),
/* 1111 */V(5, 2, 4),

/* 0010 ... */
/* 0000 */V(1, 5, 3), /* 48 */
/* 0001 */V(1, 5, 3),
/* 0010 */V(5, 1, 3),
/* 0011 */V(5, 1, 3),
/* 0100 */V(3, 4, 3),
/* 0101 */V(3, 4, 3),
/* 0110 */V(4, 3, 3),
/* 0111 */V(4, 3, 3),
/* 1000 */V(5, 0, 4),
/* 1001 */V(0, 4, 4),
/* 1010 */V(2, 4, 3),
/* 1011 */V(2, 4, 3),
/* 1100 */V(4, 2, 3),
/* 1101 */V(4, 2, 3),
/* 1110 */V(1, 4, 3),
/* 1111 */V(1, 4, 3),

/* 0011 ... */
/* 00   */V(3, 3, 2), /* 64 */
/* 01   */V(4, 1, 2),
/* 10   */V(2, 3, 2),
/* 11   */V(3, 2, 2),

/* 0100 ... */
/* 000  */V(4, 0, 3), /* 68 */
/* 001  */V(0, 3, 3),
/* 010  */V(3, 0, 2),
/* 011  */V(3, 0, 2),
/* 100  */V(1, 3, 1),
/* 101  */V(1, 3, 1),
/* 110  */V(1, 3, 1),
/* 111  */V(1, 3, 1),

/* 0101 ... */
/* 0    */V(3, 1, 1), /* 76 */
/* 1    */V(2, 2, 1),

/* 1000 ... */
/* 0    */V(0, 2, 1), /* 78 */
/* 1    */V(2, 0, 1),

/* 0000 0000 ... */
/* 00   */V(7, 7, 2), /* 80 */
/* 01   */V(6, 7, 2),
/* 10   */V(7, 6, 1),
/* 11   */V(7, 6, 1),

/* 0000 0001 ... */
/* 0    */V(5, 7, 1), /* 84 */
/* 1    */V(7, 5, 1),

/* 0000 0010 ... */
/* 0    */V(6, 6, 1), /* 86 */
/* 1    */V(4, 7, 1),

/* 0000 0011 ... */
/* 0    */V(7, 4, 1), /* 88 */
/* 1    */V(6, 5, 1),

/* 0000 0110 ... */
/* 0    */V(7, 3, 1), /* 90 */
/* 1    */V(5, 5, 1),

/* 0000 1101 ... */
/* 0    */V(0, 7, 1), /* 92 */
/* 1    */V(7, 0, 1),

/* 0001 0011 ... */
/* 0    */V(0, 6, 1), /* 94 */
/* 1    */V(0, 5, 1)];

var hufftab13 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */PTR(64, 2),
/* 0100 */V(1, 1, 4),
/* 0101 */V(0, 1, 4),
/* 0110 */V(1, 0, 3),
/* 0111 */V(1, 0, 3),
/* 1000 */V(0, 0, 1),
/* 1001 */V(0, 0, 1),
/* 1010 */V(0, 0, 1),
/* 1011 */V(0, 0, 1),
/* 1100 */V(0, 0, 1),
/* 1101 */V(0, 0, 1),
/* 1110 */V(0, 0, 1),
/* 1111 */V(0, 0, 1),

/* 0000 ... */
/* 0000 */PTR(68, 4), /* 16 */
/* 0001 */PTR(84, 4),
/* 0010 */PTR(100, 4),
/* 0011 */PTR(116, 4),
/* 0100 */PTR(132, 4),
/* 0101 */PTR(148, 4),
/* 0110 */PTR(164, 3),
/* 0111 */PTR(172, 3),
/* 1000 */PTR(180, 3),
/* 1001 */PTR(188, 3),
/* 1010 */PTR(196, 3),
/* 1011 */PTR(204, 3),
/* 1100 */PTR(212, 1),
/* 1101 */PTR(214, 2),
/* 1110 */PTR(218, 3),
/* 1111 */PTR(226, 1),

/* 0001 ... */
/* 0000 */PTR(228, 2), /* 32 */
/* 0001 */PTR(232, 2),
/* 0010 */PTR(236, 2),
/* 0011 */PTR(240, 2),
/* 0100 */V(8, 1, 4),
/* 0101 */PTR(244, 1),
/* 0110 */PTR(246, 1),
/* 0111 */PTR(248, 1),
/* 1000 */PTR(250, 2),
/* 1001 */PTR(254, 1),
/* 1010 */V(1, 5, 4),
/* 1011 */V(5, 1, 4),
/* 1100 */PTR(256, 1),
/* 1101 */PTR(258, 1),
/* 1110 */PTR(260, 1),
/* 1111 */V(1, 4, 4),

/* 0010 ... */
/* 0000 */V(4, 1, 3), /* 48 */
/* 0001 */V(4, 1, 3),
/* 0010 */V(0, 4, 4),
/* 0011 */V(4, 0, 4),
/* 0100 */V(2, 3, 4),
/* 0101 */V(3, 2, 4),
/* 0110 */V(1, 3, 3),
/* 0111 */V(1, 3, 3),
/* 1000 */V(3, 1, 3),
/* 1001 */V(3, 1, 3),
/* 1010 */V(0, 3, 3),
/* 1011 */V(0, 3, 3),
/* 1100 */V(3, 0, 3),
/* 1101 */V(3, 0, 3),
/* 1110 */V(2, 2, 3),
/* 1111 */V(2, 2, 3),

/* 0011 ... */
/* 00   */V(1, 2, 2), /* 64 */
/* 01   */V(2, 1, 2),
/* 10   */V(0, 2, 2),
/* 11   */V(2, 0, 2),

/* 0000 0000 ... */
/* 0000 */PTR(262, 4), /* 68 */
/* 0001 */PTR(278, 4),
/* 0010 */PTR(294, 4),
/* 0011 */PTR(310, 3),
/* 0100 */PTR(318, 2),
/* 0101 */PTR(322, 2),
/* 0110 */PTR(326, 3),
/* 0111 */PTR(334, 2),
/* 1000 */PTR(338, 1),
/* 1001 */PTR(340, 2),
/* 1010 */PTR(344, 2),
/* 1011 */PTR(348, 2),
/* 1100 */PTR(352, 2),
/* 1101 */PTR(356, 2),
/* 1110 */V(1, 15, 4),
/* 1111 */V(15, 1, 4),

/* 0000 0001 ... */
/* 0000 */V(15, 0, 4), /* 84 */
/* 0001 */PTR(360, 1),
/* 0010 */PTR(362, 1),
/* 0011 */PTR(364, 1),
/* 0100 */V(14, 2, 4),
/* 0101 */PTR(366, 1),
/* 0110 */V(1, 14, 4),
/* 0111 */V(14, 1, 4),
/* 1000 */PTR(368, 1),
/* 1001 */PTR(370, 1),
/* 1010 */PTR(372, 1),
/* 1011 */PTR(374, 1),
/* 1100 */PTR(376, 1),
/* 1101 */PTR(378, 1),
/* 1110 */V(12, 6, 4),
/* 1111 */V(3, 13, 4),

/* 0000 0010 ... */
/* 0000 */PTR(380, 1), /* 100 */
/* 0001 */V(2, 13, 4),
/* 0010 */V(13, 2, 4),
/* 0011 */V(1, 13, 4),
/* 0100 */V(11, 7, 4),
/* 0101 */PTR(382, 1),
/* 0110 */PTR(384, 1),
/* 0111 */V(12, 3, 4),
/* 1000 */PTR(386, 1),
/* 1001 */V(4, 11, 4),
/* 1010 */V(13, 1, 3),
/* 1011 */V(13, 1, 3),
/* 1100 */V(0, 13, 4),
/* 1101 */V(13, 0, 4),
/* 1110 */V(8, 10, 4),
/* 1111 */V(10, 8, 4),

/* 0000 0011 ... */
/* 0000 */V(4, 12, 4), /* 116 */
/* 0001 */V(12, 4, 4),
/* 0010 */V(6, 11, 4),
/* 0011 */V(11, 6, 4),
/* 0100 */V(3, 12, 3),
/* 0101 */V(3, 12, 3),
/* 0110 */V(2, 12, 3),
/* 0111 */V(2, 12, 3),
/* 1000 */V(12, 2, 3),
/* 1001 */V(12, 2, 3),
/* 1010 */V(5, 11, 3),
/* 1011 */V(5, 11, 3),
/* 1100 */V(11, 5, 4),
/* 1101 */V(8, 9, 4),
/* 1110 */V(1, 12, 3),
/* 1111 */V(1, 12, 3),

/* 0000 0100 ... */
/* 0000 */V(12, 1, 3), /* 132 */
/* 0001 */V(12, 1, 3),
/* 0010 */V(9, 8, 4),
/* 0011 */V(0, 12, 4),
/* 0100 */V(12, 0, 3),
/* 0101 */V(12, 0, 3),
/* 0110 */V(11, 4, 4),
/* 0111 */V(6, 10, 4),
/* 1000 */V(10, 6, 4),
/* 1001 */V(7, 9, 4),
/* 1010 */V(3, 11, 3),
/* 1011 */V(3, 11, 3),
/* 1100 */V(11, 3, 3),
/* 1101 */V(11, 3, 3),
/* 1110 */V(8, 8, 4),
/* 1111 */V(5, 10, 4),

/* 0000 0101 ... */
/* 0000 */V(2, 11, 3), /* 148 */
/* 0001 */V(2, 11, 3),
/* 0010 */V(10, 5, 4),
/* 0011 */V(6, 9, 4),
/* 0100 */V(10, 4, 3),
/* 0101 */V(10, 4, 3),
/* 0110 */V(7, 8, 4),
/* 0111 */V(8, 7, 4),
/* 1000 */V(9, 4, 3),
/* 1001 */V(9, 4, 3),
/* 1010 */V(7, 7, 4),
/* 1011 */V(7, 6, 4),
/* 1100 */V(11, 2, 2),
/* 1101 */V(11, 2, 2),
/* 1110 */V(11, 2, 2),
/* 1111 */V(11, 2, 2),

/* 0000 0110 ... */
/* 000  */V(1, 11, 2), /* 164 */
/* 001  */V(1, 11, 2),
/* 010  */V(11, 1, 2),
/* 011  */V(11, 1, 2),
/* 100  */V(0, 11, 3),
/* 101  */V(11, 0, 3),
/* 110  */V(9, 6, 3),
/* 111  */V(4, 10, 3),

/* 0000 0111 ... */
/* 000  */V(3, 10, 3), /* 172 */
/* 001  */V(10, 3, 3),
/* 010  */V(5, 9, 3),
/* 011  */V(9, 5, 3),
/* 100  */V(2, 10, 2),
/* 101  */V(2, 10, 2),
/* 110  */V(10, 2, 2),
/* 111  */V(10, 2, 2),

/* 0000 1000 ... */
/* 000  */V(1, 10, 2), /* 180 */
/* 001  */V(1, 10, 2),
/* 010  */V(10, 1, 2),
/* 011  */V(10, 1, 2),
/* 100  */V(0, 10, 3),
/* 101  */V(6, 8, 3),
/* 110  */V(10, 0, 2),
/* 111  */V(10, 0, 2),

/* 0000 1001 ... */
/* 000  */V(8, 6, 3), /* 188 */
/* 001  */V(4, 9, 3),
/* 010  */V(9, 3, 2),
/* 011  */V(9, 3, 2),
/* 100  */V(3, 9, 3),
/* 101  */V(5, 8, 3),
/* 110  */V(8, 5, 3),
/* 111  */V(6, 7, 3),

/* 0000 1010 ... */
/* 000  */V(2, 9, 2), /* 196 */
/* 001  */V(2, 9, 2),
/* 010  */V(9, 2, 2),
/* 011  */V(9, 2, 2),
/* 100  */V(5, 7, 3),
/* 101  */V(7, 5, 3),
/* 110  */V(3, 8, 2),
/* 111  */V(3, 8, 2),

/* 0000 1011 ... */
/* 000  */V(8, 3, 2), /* 204 */
/* 001  */V(8, 3, 2),
/* 010  */V(6, 6, 3),
/* 011  */V(4, 7, 3),
/* 100  */V(7, 4, 3),
/* 101  */V(5, 6, 3),
/* 110  */V(6, 5, 3),
/* 111  */V(7, 3, 3),

/* 0000 1100 ... */
/* 0    */V(1, 9, 1), /* 212 */
/* 1    */V(9, 1, 1),

/* 0000 1101 ... */
/* 00   */V(0, 9, 2), /* 214 */
/* 01   */V(9, 0, 2),
/* 10   */V(4, 8, 2),
/* 11   */V(8, 4, 2),

/* 0000 1110 ... */
/* 000  */V(7, 2, 2), /* 218 */
/* 001  */V(7, 2, 2),
/* 010  */V(4, 6, 3),
/* 011  */V(6, 4, 3),
/* 100  */V(2, 8, 1),
/* 101  */V(2, 8, 1),
/* 110  */V(2, 8, 1),
/* 111  */V(2, 8, 1),

/* 0000 1111 ... */
/* 0    */V(8, 2, 1), /* 226 */
/* 1    */V(1, 8, 1),

/* 0001 0000 ... */
/* 00   */V(3, 7, 2), /* 228 */
/* 01   */V(2, 7, 2),
/* 10   */V(1, 7, 1),
/* 11   */V(1, 7, 1),

/* 0001 0001 ... */
/* 00   */V(7, 1, 1), /* 232 */
/* 01   */V(7, 1, 1),
/* 10   */V(5, 5, 2),
/* 11   */V(0, 7, 2),

/* 0001 0010 ... */
/* 00   */V(7, 0, 2), /* 236 */
/* 01   */V(3, 6, 2),
/* 10   */V(6, 3, 2),
/* 11   */V(4, 5, 2),

/* 0001 0011 ... */
/* 00   */V(5, 4, 2), /* 240 */
/* 01   */V(2, 6, 2),
/* 10   */V(6, 2, 2),
/* 11   */V(3, 5, 2),

/* 0001 0101 ... */
/* 0    */V(0, 8, 1), /* 244 */
/* 1    */V(8, 0, 1),

/* 0001 0110 ... */
/* 0    */V(1, 6, 1), /* 246 */
/* 1    */V(6, 1, 1),

/* 0001 0111 ... */
/* 0    */V(0, 6, 1), /* 248 */
/* 1    */V(6, 0, 1),

/* 0001 1000 ... */
/* 00   */V(5, 3, 2), /* 250 */
/* 01   */V(4, 4, 2),
/* 10   */V(2, 5, 1),
/* 11   */V(2, 5, 1),

/* 0001 1001 ... */
/* 0    */V(5, 2, 1), /* 254 */
/* 1    */V(0, 5, 1),

/* 0001 1100 ... */
/* 0    */V(3, 4, 1), /* 256 */
/* 1    */V(4, 3, 1),

/* 0001 1101 ... */
/* 0    */V(5, 0, 1), /* 258 */
/* 1    */V(2, 4, 1),

/* 0001 1110 ... */
/* 0    */V(4, 2, 1), /* 260 */
/* 1    */V(3, 3, 1),

/* 0000 0000 0000 ... */
/* 0000 */PTR(388, 3), /* 262 */
/* 0001 */V(15, 15, 4),
/* 0010 */V(14, 15, 4),
/* 0011 */V(13, 15, 4),
/* 0100 */V(14, 14, 4),
/* 0101 */V(12, 15, 4),
/* 0110 */V(13, 14, 4),
/* 0111 */V(11, 15, 4),
/* 1000 */V(15, 11, 4),
/* 1001 */V(12, 14, 4),
/* 1010 */V(13, 12, 4),
/* 1011 */PTR(396, 1),
/* 1100 */V(14, 12, 3),
/* 1101 */V(14, 12, 3),
/* 1110 */V(13, 13, 3),
/* 1111 */V(13, 13, 3),

/* 0000 0000 0001 ... */
/* 0000 */V(15, 10, 4), /* 278 */
/* 0001 */V(12, 13, 4),
/* 0010 */V(11, 14, 3),
/* 0011 */V(11, 14, 3),
/* 0100 */V(14, 11, 3),
/* 0101 */V(14, 11, 3),
/* 0110 */V(9, 15, 3),
/* 0111 */V(9, 15, 3),
/* 1000 */V(15, 9, 3),
/* 1001 */V(15, 9, 3),
/* 1010 */V(14, 10, 3),
/* 1011 */V(14, 10, 3),
/* 1100 */V(11, 13, 3),
/* 1101 */V(11, 13, 3),
/* 1110 */V(13, 11, 3),
/* 1111 */V(13, 11, 3),

/* 0000 0000 0010 ... */
/* 0000 */V(8, 15, 3), /* 294 */
/* 0001 */V(8, 15, 3),
/* 0010 */V(15, 8, 3),
/* 0011 */V(15, 8, 3),
/* 0100 */V(12, 12, 3),
/* 0101 */V(12, 12, 3),
/* 0110 */V(10, 14, 4),
/* 0111 */V(9, 14, 4),
/* 1000 */V(8, 14, 3),
/* 1001 */V(8, 14, 3),
/* 1010 */V(7, 15, 4),
/* 1011 */V(7, 14, 4),
/* 1100 */V(15, 7, 2),
/* 1101 */V(15, 7, 2),
/* 1110 */V(15, 7, 2),
/* 1111 */V(15, 7, 2),

/* 0000 0000 0011 ... */
/* 000  */V(13, 10, 2), /* 310 */
/* 001  */V(13, 10, 2),
/* 010  */V(10, 13, 3),
/* 011  */V(11, 12, 3),
/* 100  */V(12, 11, 3),
/* 101  */V(15, 6, 3),
/* 110  */V(6, 15, 2),
/* 111  */V(6, 15, 2),

/* 0000 0000 0100 ... */
/* 00   */V(14, 8, 2), /* 318 */
/* 01   */V(5, 15, 2),
/* 10   */V(9, 13, 2),
/* 11   */V(13, 9, 2),

/* 0000 0000 0101 ... */
/* 00   */V(15, 5, 2), /* 322 */
/* 01   */V(14, 7, 2),
/* 10   */V(10, 12, 2),
/* 11   */V(11, 11, 2),

/* 0000 0000 0110 ... */
/* 000  */V(4, 15, 2), /* 326 */
/* 001  */V(4, 15, 2),
/* 010  */V(15, 4, 2),
/* 011  */V(15, 4, 2),
/* 100  */V(12, 10, 3),
/* 101  */V(14, 6, 3),
/* 110  */V(15, 3, 2),
/* 111  */V(15, 3, 2),

/* 0000 0000 0111 ... */
/* 00   */V(3, 15, 1), /* 334 */
/* 01   */V(3, 15, 1),
/* 10   */V(8, 13, 2),
/* 11   */V(13, 8, 2),

/* 0000 0000 1000 ... */
/* 0    */V(2, 15, 1), /* 338 */
/* 1    */V(15, 2, 1),

/* 0000 0000 1001 ... */
/* 00   */V(6, 14, 2), /* 340 */
/* 01   */V(9, 12, 2),
/* 10   */V(0, 15, 1),
/* 11   */V(0, 15, 1),

/* 0000 0000 1010 ... */
/* 00   */V(12, 9, 2), /* 344 */
/* 01   */V(5, 14, 2),
/* 10   */V(10, 11, 1),
/* 11   */V(10, 11, 1),

/* 0000 0000 1011 ... */
/* 00   */V(7, 13, 2), /* 348 */
/* 01   */V(13, 7, 2),
/* 10   */V(4, 14, 1),
/* 11   */V(4, 14, 1),

/* 0000 0000 1100 ... */
/* 00   */V(12, 8, 2), /* 352 */
/* 01   */V(13, 6, 2),
/* 10   */V(3, 14, 1),
/* 11   */V(3, 14, 1),

/* 0000 0000 1101 ... */
/* 00   */V(11, 9, 1), /* 356 */
/* 01   */V(11, 9, 1),
/* 10   */V(9, 11, 2),
/* 11   */V(10, 10, 2),

/* 0000 0001 0001 ... */
/* 0    */V(11, 10, 1), /* 360 */
/* 1    */V(14, 5, 1),

/* 0000 0001 0010 ... */
/* 0    */V(14, 4, 1), /* 362 */
/* 1    */V(8, 12, 1),

/* 0000 0001 0011 ... */
/* 0    */V(6, 13, 1), /* 364 */
/* 1    */V(14, 3, 1),

/* 0000 0001 0101 ... */
/* 0    */V(2, 14, 1), /* 366 */
/* 1    */V(0, 14, 1),

/* 0000 0001 1000 ... */
/* 0    */V(14, 0, 1), /* 368 */
/* 1    */V(5, 13, 1),

/* 0000 0001 1001 ... */
/* 0    */V(13, 5, 1), /* 370 */
/* 1    */V(7, 12, 1),

/* 0000 0001 1010 ... */
/* 0    */V(12, 7, 1), /* 372 */
/* 1    */V(4, 13, 1),

/* 0000 0001 1011 ... */
/* 0    */V(8, 11, 1), /* 374 */
/* 1    */V(11, 8, 1),

/* 0000 0001 1100 ... */
/* 0    */V(13, 4, 1), /* 376 */
/* 1    */V(9, 10, 1),

/* 0000 0001 1101 ... */
/* 0    */V(10, 9, 1), /* 378 */
/* 1    */V(6, 12, 1),

/* 0000 0010 0000 ... */
/* 0    */V(13, 3, 1), /* 380 */
/* 1    */V(7, 11, 1),

/* 0000 0010 0101 ... */
/* 0    */V(5, 12, 1), /* 382 */
/* 1    */V(12, 5, 1),

/* 0000 0010 0110 ... */
/* 0    */V(9, 9, 1), /* 384 */
/* 1    */V(7, 10, 1),

/* 0000 0010 1000 ... */
/* 0    */V(10, 7, 1), /* 386 */
/* 1    */V(9, 7, 1),

/* 0000 0000 0000 0000 ... */
/* 000  */V(15, 14, 3), /* 388 */
/* 001  */V(15, 12, 3),
/* 010  */V(15, 13, 2),
/* 011  */V(15, 13, 2),
/* 100  */V(14, 13, 1),
/* 101  */V(14, 13, 1),
/* 110  */V(14, 13, 1),
/* 111  */V(14, 13, 1),

/* 0000 0000 0000 1011 ... */
/* 0    */V(10, 15, 1), /* 396 */
/* 1    */V(14, 9, 1)];

var hufftab15 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */PTR(64, 4),
/* 0100 */PTR(80, 4),
/* 0101 */PTR(96, 3),
/* 0110 */PTR(104, 3),
/* 0111 */PTR(112, 2),
/* 1000 */PTR(116, 1),
/* 1001 */PTR(118, 1),
/* 1010 */V(1, 1, 3),
/* 1011 */V(1, 1, 3),
/* 1100 */V(0, 1, 4),
/* 1101 */V(1, 0, 4),
/* 1110 */V(0, 0, 3),
/* 1111 */V(0, 0, 3),

/* 0000 ... */
/* 0000 */PTR(120, 4), /* 16 */
/* 0001 */PTR(136, 4),
/* 0010 */PTR(152, 4),
/* 0011 */PTR(168, 4),
/* 0100 */PTR(184, 4),
/* 0101 */PTR(200, 3),
/* 0110 */PTR(208, 3),
/* 0111 */PTR(216, 4),
/* 1000 */PTR(232, 3),
/* 1001 */PTR(240, 3),
/* 1010 */PTR(248, 3),
/* 1011 */PTR(256, 3),
/* 1100 */PTR(264, 2),
/* 1101 */PTR(268, 3),
/* 1110 */PTR(276, 3),
/* 1111 */PTR(284, 2),

/* 0001 ... */
/* 0000 */PTR(288, 2), /* 32 */
/* 0001 */PTR(292, 2),
/* 0010 */PTR(296, 2),
/* 0011 */PTR(300, 2),
/* 0100 */PTR(304, 2),
/* 0101 */PTR(308, 2),
/* 0110 */PTR(312, 2),
/* 0111 */PTR(316, 2),
/* 1000 */PTR(320, 1),
/* 1001 */PTR(322, 1),
/* 1010 */PTR(324, 1),
/* 1011 */PTR(326, 2),
/* 1100 */PTR(330, 1),
/* 1101 */PTR(332, 1),
/* 1110 */PTR(334, 2),
/* 1111 */PTR(338, 1),

/* 0010 ... */
/* 0000 */PTR(340, 1), /* 48 */
/* 0001 */PTR(342, 1),
/* 0010 */V(9, 1, 4),
/* 0011 */PTR(344, 1),
/* 0100 */PTR(346, 1),
/* 0101 */PTR(348, 1),
/* 0110 */PTR(350, 1),
/* 0111 */PTR(352, 1),
/* 1000 */V(2, 8, 4),
/* 1001 */V(8, 2, 4),
/* 1010 */V(1, 8, 4),
/* 1011 */V(8, 1, 4),
/* 1100 */PTR(354, 1),
/* 1101 */PTR(356, 1),
/* 1110 */PTR(358, 1),
/* 1111 */PTR(360, 1),

/* 0011 ... */
/* 0000 */V(2, 7, 4), /* 64 */
/* 0001 */V(7, 2, 4),
/* 0010 */V(6, 4, 4),
/* 0011 */V(1, 7, 4),
/* 0100 */V(5, 5, 4),
/* 0101 */V(7, 1, 4),
/* 0110 */PTR(362, 1),
/* 0111 */V(3, 6, 4),
/* 1000 */V(6, 3, 4),
/* 1001 */V(4, 5, 4),
/* 1010 */V(5, 4, 4),
/* 1011 */V(2, 6, 4),
/* 1100 */V(6, 2, 4),
/* 1101 */V(1, 6, 4),
/* 1110 */PTR(364, 1),
/* 1111 */V(3, 5, 4),

/* 0100 ... */
/* 0000 */V(6, 1, 3), /* 80 */
/* 0001 */V(6, 1, 3),
/* 0010 */V(5, 3, 4),
/* 0011 */V(4, 4, 4),
/* 0100 */V(2, 5, 3),
/* 0101 */V(2, 5, 3),
/* 0110 */V(5, 2, 3),
/* 0111 */V(5, 2, 3),
/* 1000 */V(1, 5, 3),
/* 1001 */V(1, 5, 3),
/* 1010 */V(5, 1, 3),
/* 1011 */V(5, 1, 3),
/* 1100 */V(0, 5, 4),
/* 1101 */V(5, 0, 4),
/* 1110 */V(3, 4, 3),
/* 1111 */V(3, 4, 3),

/* 0101 ... */
/* 000  */V(4, 3, 3), /* 96 */
/* 001  */V(2, 4, 3),
/* 010  */V(4, 2, 3),
/* 011  */V(3, 3, 3),
/* 100  */V(4, 1, 2),
/* 101  */V(4, 1, 2),
/* 110  */V(1, 4, 3),
/* 111  */V(0, 4, 3),

/* 0110 ... */
/* 000  */V(2, 3, 2), /* 104 */
/* 001  */V(2, 3, 2),
/* 010  */V(3, 2, 2),
/* 011  */V(3, 2, 2),
/* 100  */V(4, 0, 3),
/* 101  */V(0, 3, 3),
/* 110  */V(1, 3, 2),
/* 111  */V(1, 3, 2),

/* 0111 ... */
/* 00   */V(3, 1, 2), /* 112 */
/* 01   */V(3, 0, 2),
/* 10   */V(2, 2, 1),
/* 11   */V(2, 2, 1),

/* 1000 ... */
/* 0    */V(1, 2, 1), /* 116 */
/* 1    */V(2, 1, 1),

/* 1001 ... */
/* 0    */V(0, 2, 1), /* 118 */
/* 1    */V(2, 0, 1),

/* 0000 0000 ... */
/* 0000 */PTR(366, 1), /* 120 */
/* 0001 */PTR(368, 1),
/* 0010 */V(14, 14, 4),
/* 0011 */PTR(370, 1),
/* 0100 */PTR(372, 1),
/* 0101 */PTR(374, 1),
/* 0110 */V(15, 11, 4),
/* 0111 */PTR(376, 1),
/* 1000 */V(13, 13, 4),
/* 1001 */V(10, 15, 4),
/* 1010 */V(15, 10, 4),
/* 1011 */V(11, 14, 4),
/* 1100 */V(14, 11, 4),
/* 1101 */V(12, 13, 4),
/* 1110 */V(13, 12, 4),
/* 1111 */V(9, 15, 4),

/* 0000 0001 ... */
/* 0000 */V(15, 9, 4), /* 136 */
/* 0001 */V(14, 10, 4),
/* 0010 */V(11, 13, 4),
/* 0011 */V(13, 11, 4),
/* 0100 */V(8, 15, 4),
/* 0101 */V(15, 8, 4),
/* 0110 */V(12, 12, 4),
/* 0111 */V(9, 14, 4),
/* 1000 */V(14, 9, 4),
/* 1001 */V(7, 15, 4),
/* 1010 */V(15, 7, 4),
/* 1011 */V(10, 13, 4),
/* 1100 */V(13, 10, 4),
/* 1101 */V(11, 12, 4),
/* 1110 */V(6, 15, 4),
/* 1111 */PTR(378, 1),

/* 0000 0010 ... */
/* 0000 */V(12, 11, 3), /* 152 */
/* 0001 */V(12, 11, 3),
/* 0010 */V(15, 6, 3),
/* 0011 */V(15, 6, 3),
/* 0100 */V(8, 14, 4),
/* 0101 */V(14, 8, 4),
/* 0110 */V(5, 15, 4),
/* 0111 */V(9, 13, 4),
/* 1000 */V(15, 5, 3),
/* 1001 */V(15, 5, 3),
/* 1010 */V(7, 14, 3),
/* 1011 */V(7, 14, 3),
/* 1100 */V(14, 7, 3),
/* 1101 */V(14, 7, 3),
/* 1110 */V(10, 12, 3),
/* 1111 */V(10, 12, 3),

/* 0000 0011 ... */
/* 0000 */V(12, 10, 3), /* 168 */
/* 0001 */V(12, 10, 3),
/* 0010 */V(11, 11, 3),
/* 0011 */V(11, 11, 3),
/* 0100 */V(13, 9, 4),
/* 0101 */V(8, 13, 4),
/* 0110 */V(4, 15, 3),
/* 0111 */V(4, 15, 3),
/* 1000 */V(15, 4, 3),
/* 1001 */V(15, 4, 3),
/* 1010 */V(3, 15, 3),
/* 1011 */V(3, 15, 3),
/* 1100 */V(15, 3, 3),
/* 1101 */V(15, 3, 3),
/* 1110 */V(13, 8, 3),
/* 1111 */V(13, 8, 3),

/* 0000 0100 ... */
/* 0000 */V(14, 6, 3), /* 184 */
/* 0001 */V(14, 6, 3),
/* 0010 */V(2, 15, 3),
/* 0011 */V(2, 15, 3),
/* 0100 */V(15, 2, 3),
/* 0101 */V(15, 2, 3),
/* 0110 */V(6, 14, 4),
/* 0111 */V(15, 0, 4),
/* 1000 */V(1, 15, 3),
/* 1001 */V(1, 15, 3),
/* 1010 */V(15, 1, 3),
/* 1011 */V(15, 1, 3),
/* 1100 */V(9, 12, 3),
/* 1101 */V(9, 12, 3),
/* 1110 */V(12, 9, 3),
/* 1111 */V(12, 9, 3),

/* 0000 0101 ... */
/* 000  */V(5, 14, 3), /* 200 */
/* 001  */V(10, 11, 3),
/* 010  */V(11, 10, 3),
/* 011  */V(14, 5, 3),
/* 100  */V(7, 13, 3),
/* 101  */V(13, 7, 3),
/* 110  */V(4, 14, 3),
/* 111  */V(14, 4, 3),

/* 0000 0110 ... */
/* 000  */V(8, 12, 3), /* 208 */
/* 001  */V(12, 8, 3),
/* 010  */V(3, 14, 3),
/* 011  */V(6, 13, 3),
/* 100  */V(13, 6, 3),
/* 101  */V(14, 3, 3),
/* 110  */V(9, 11, 3),
/* 111  */V(11, 9, 3),

/* 0000 0111 ... */
/* 0000 */V(2, 14, 3), /* 216 */
/* 0001 */V(2, 14, 3),
/* 0010 */V(10, 10, 3),
/* 0011 */V(10, 10, 3),
/* 0100 */V(14, 2, 3),
/* 0101 */V(14, 2, 3),
/* 0110 */V(1, 14, 3),
/* 0111 */V(1, 14, 3),
/* 1000 */V(14, 1, 3),
/* 1001 */V(14, 1, 3),
/* 1010 */V(0, 14, 4),
/* 1011 */V(14, 0, 4),
/* 1100 */V(5, 13, 3),
/* 1101 */V(5, 13, 3),
/* 1110 */V(13, 5, 3),
/* 1111 */V(13, 5, 3),

/* 0000 1000 ... */
/* 000  */V(7, 12, 3), /* 232 */
/* 001  */V(12, 7, 3),
/* 010  */V(4, 13, 3),
/* 011  */V(8, 11, 3),
/* 100  */V(13, 4, 2),
/* 101  */V(13, 4, 2),
/* 110  */V(11, 8, 3),
/* 111  */V(9, 10, 3),

/* 0000 1001 ... */
/* 000  */V(10, 9, 3), /* 240 */
/* 001  */V(6, 12, 3),
/* 010  */V(12, 6, 3),
/* 011  */V(3, 13, 3),
/* 100  */V(13, 3, 2),
/* 101  */V(13, 3, 2),
/* 110  */V(13, 2, 2),
/* 111  */V(13, 2, 2),

/* 0000 1010 ... */
/* 000  */V(2, 13, 3), /* 248 */
/* 001  */V(0, 13, 3),
/* 010  */V(1, 13, 2),
/* 011  */V(1, 13, 2),
/* 100  */V(7, 11, 2),
/* 101  */V(7, 11, 2),
/* 110  */V(11, 7, 2),
/* 111  */V(11, 7, 2),

/* 0000 1011 ... */
/* 000  */V(13, 1, 2), /* 256 */
/* 001  */V(13, 1, 2),
/* 010  */V(5, 12, 3),
/* 011  */V(13, 0, 3),
/* 100  */V(12, 5, 2),
/* 101  */V(12, 5, 2),
/* 110  */V(8, 10, 2),
/* 111  */V(8, 10, 2),

/* 0000 1100 ... */
/* 00   */V(10, 8, 2), /* 264 */
/* 01   */V(4, 12, 2),
/* 10   */V(12, 4, 2),
/* 11   */V(6, 11, 2),

/* 0000 1101 ... */
/* 000  */V(11, 6, 2), /* 268 */
/* 001  */V(11, 6, 2),
/* 010  */V(9, 9, 3),
/* 011  */V(0, 12, 3),
/* 100  */V(3, 12, 2),
/* 101  */V(3, 12, 2),
/* 110  */V(12, 3, 2),
/* 111  */V(12, 3, 2),

/* 0000 1110 ... */
/* 000  */V(7, 10, 2), /* 276 */
/* 001  */V(7, 10, 2),
/* 010  */V(10, 7, 2),
/* 011  */V(10, 7, 2),
/* 100  */V(10, 6, 2),
/* 101  */V(10, 6, 2),
/* 110  */V(12, 0, 3),
/* 111  */V(0, 11, 3),

/* 0000 1111 ... */
/* 00   */V(12, 2, 1), /* 284 */
/* 01   */V(12, 2, 1),
/* 10   */V(2, 12, 2),
/* 11   */V(5, 11, 2),

/* 0001 0000 ... */
/* 00   */V(11, 5, 2), /* 288 */
/* 01   */V(1, 12, 2),
/* 10   */V(8, 9, 2),
/* 11   */V(9, 8, 2),

/* 0001 0001 ... */
/* 00   */V(12, 1, 2), /* 292 */
/* 01   */V(4, 11, 2),
/* 10   */V(11, 4, 2),
/* 11   */V(6, 10, 2),

/* 0001 0010 ... */
/* 00   */V(3, 11, 2), /* 296 */
/* 01   */V(7, 9, 2),
/* 10   */V(11, 3, 1),
/* 11   */V(11, 3, 1),

/* 0001 0011 ... */
/* 00   */V(9, 7, 2), /* 300 */
/* 01   */V(8, 8, 2),
/* 10   */V(2, 11, 2),
/* 11   */V(5, 10, 2),

/* 0001 0100 ... */
/* 00   */V(11, 2, 1), /* 304 */
/* 01   */V(11, 2, 1),
/* 10   */V(10, 5, 2),
/* 11   */V(1, 11, 2),

/* 0001 0101 ... */
/* 00   */V(11, 1, 1), /* 308 */
/* 01   */V(11, 1, 1),
/* 10   */V(11, 0, 2),
/* 11   */V(6, 9, 2),

/* 0001 0110 ... */
/* 00   */V(9, 6, 2), /* 312 */
/* 01   */V(4, 10, 2),
/* 10   */V(10, 4, 2),
/* 11   */V(7, 8, 2),

/* 0001 0111 ... */
/* 00   */V(8, 7, 2), /* 316 */
/* 01   */V(3, 10, 2),
/* 10   */V(10, 3, 1),
/* 11   */V(10, 3, 1),

/* 0001 1000 ... */
/* 0    */V(5, 9, 1), /* 320 */
/* 1    */V(9, 5, 1),

/* 0001 1001 ... */
/* 0    */V(2, 10, 1), /* 322 */
/* 1    */V(10, 2, 1),

/* 0001 1010 ... */
/* 0    */V(1, 10, 1), /* 324 */
/* 1    */V(10, 1, 1),

/* 0001 1011 ... */
/* 00   */V(0, 10, 2), /* 326 */
/* 01   */V(10, 0, 2),
/* 10   */V(6, 8, 1),
/* 11   */V(6, 8, 1),

/* 0001 1100 ... */
/* 0    */V(8, 6, 1), /* 330 */
/* 1    */V(4, 9, 1),

/* 0001 1101 ... */
/* 0    */V(9, 4, 1), /* 332 */
/* 1    */V(3, 9, 1),

/* 0001 1110 ... */
/* 00   */V(9, 3, 1), /* 334 */
/* 01   */V(9, 3, 1),
/* 10   */V(7, 7, 2),
/* 11   */V(0, 9, 2),

/* 0001 1111 ... */
/* 0    */V(5, 8, 1), /* 338 */
/* 1    */V(8, 5, 1),

/* 0010 0000 ... */
/* 0    */V(2, 9, 1), /* 340 */
/* 1    */V(6, 7, 1),

/* 0010 0001 ... */
/* 0    */V(7, 6, 1), /* 342 */
/* 1    */V(9, 2, 1),

/* 0010 0011 ... */
/* 0    */V(1, 9, 1), /* 344 */
/* 1    */V(9, 0, 1),

/* 0010 0100 ... */
/* 0    */V(4, 8, 1), /* 346 */
/* 1    */V(8, 4, 1),

/* 0010 0101 ... */
/* 0    */V(5, 7, 1), /* 348 */
/* 1    */V(7, 5, 1),

/* 0010 0110 ... */
/* 0    */V(3, 8, 1), /* 350 */
/* 1    */V(8, 3, 1),

/* 0010 0111 ... */
/* 0    */V(6, 6, 1), /* 352 */
/* 1    */V(4, 7, 1),

/* 0010 1100 ... */
/* 0    */V(7, 4, 1), /* 354 */
/* 1    */V(0, 8, 1),

/* 0010 1101 ... */
/* 0    */V(8, 0, 1), /* 356 */
/* 1    */V(5, 6, 1),

/* 0010 1110 ... */
/* 0    */V(6, 5, 1), /* 358 */
/* 1    */V(3, 7, 1),

/* 0010 1111 ... */
/* 0    */V(7, 3, 1), /* 360 */
/* 1    */V(4, 6, 1),

/* 0011 0110 ... */
/* 0    */V(0, 7, 1), /* 362 */
/* 1    */V(7, 0, 1),

/* 0011 1110 ... */
/* 0    */V(0, 6, 1), /* 364 */
/* 1    */V(6, 0, 1),

/* 0000 0000 0000 ... */
/* 0    */V(15, 15, 1), /* 366 */
/* 1    */V(14, 15, 1),

/* 0000 0000 0001 ... */
/* 0    */V(15, 14, 1), /* 368 */
/* 1    */V(13, 15, 1),

/* 0000 0000 0011 ... */
/* 0    */V(15, 13, 1), /* 370 */
/* 1    */V(12, 15, 1),

/* 0000 0000 0100 ... */
/* 0    */V(15, 12, 1), /* 372 */
/* 1    */V(13, 14, 1),

/* 0000 0000 0101 ... */
/* 0    */V(14, 13, 1), /* 374 */
/* 1    */V(11, 15, 1),

/* 0000 0000 0111 ... */
/* 0    */V(12, 14, 1), /* 376 */
/* 1    */V(14, 12, 1),

/* 0000 0001 1111 ... */
/* 0    */V(10, 14, 1), /* 378 */
/* 1    */V(0, 15, 1)];

var hufftab16 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */PTR(64, 2),
/* 0100 */V(1, 1, 4),
/* 0101 */V(0, 1, 4),
/* 0110 */V(1, 0, 3),
/* 0111 */V(1, 0, 3),
/* 1000 */V(0, 0, 1),
/* 1001 */V(0, 0, 1),
/* 1010 */V(0, 0, 1),
/* 1011 */V(0, 0, 1),
/* 1100 */V(0, 0, 1),
/* 1101 */V(0, 0, 1),
/* 1110 */V(0, 0, 1),
/* 1111 */V(0, 0, 1),

/* 0000 ... */
/* 0000 */PTR(68, 3), /* 16 */
/* 0001 */PTR(76, 3),
/* 0010 */PTR(84, 2),
/* 0011 */V(15, 15, 4),
/* 0100 */PTR(88, 2),
/* 0101 */PTR(92, 1),
/* 0110 */PTR(94, 4),
/* 0111 */V(15, 2, 4),
/* 1000 */PTR(110, 1),
/* 1001 */V(1, 15, 4),
/* 1010 */V(15, 1, 4),
/* 1011 */PTR(112, 4),
/* 1100 */PTR(128, 4),
/* 1101 */PTR(144, 4),
/* 1110 */PTR(160, 4),
/* 1111 */PTR(176, 4),

/* 0001 ... */
/* 0000 */PTR(192, 4), /* 32 */
/* 0001 */PTR(208, 3),
/* 0010 */PTR(216, 3),
/* 0011 */PTR(224, 3),
/* 0100 */PTR(232, 3),
/* 0101 */PTR(240, 3),
/* 0110 */PTR(248, 3),
/* 0111 */PTR(256, 3),
/* 1000 */PTR(264, 2),
/* 1001 */PTR(268, 2),
/* 1010 */PTR(272, 1),
/* 1011 */PTR(274, 2),
/* 1100 */PTR(278, 2),
/* 1101 */PTR(282, 1),
/* 1110 */V(5, 1, 4),
/* 1111 */PTR(284, 1),

/* 0010 ... */
/* 0000 */PTR(286, 1), /* 48 */
/* 0001 */PTR(288, 1),
/* 0010 */PTR(290, 1),
/* 0011 */V(1, 4, 4),
/* 0100 */V(4, 1, 4),
/* 0101 */PTR(292, 1),
/* 0110 */V(2, 3, 4),
/* 0111 */V(3, 2, 4),
/* 1000 */V(1, 3, 3),
/* 1001 */V(1, 3, 3),
/* 1010 */V(3, 1, 3),
/* 1011 */V(3, 1, 3),
/* 1100 */V(0, 3, 4),
/* 1101 */V(3, 0, 4),
/* 1110 */V(2, 2, 3),
/* 1111 */V(2, 2, 3),

/* 0011 ... */
/* 00   */V(1, 2, 2), /* 64 */
/* 01   */V(2, 1, 2),
/* 10   */V(0, 2, 2),
/* 11   */V(2, 0, 2),

/* 0000 0000 ... */
/* 000  */V(14, 15, 3), /* 68 */
/* 001  */V(15, 14, 3),
/* 010  */V(13, 15, 3),
/* 011  */V(15, 13, 3),
/* 100  */V(12, 15, 3),
/* 101  */V(15, 12, 3),
/* 110  */V(11, 15, 3),
/* 111  */V(15, 11, 3),

/* 0000 0001 ... */
/* 000  */V(10, 15, 2), /* 76 */
/* 001  */V(10, 15, 2),
/* 010  */V(15, 10, 3),
/* 011  */V(9, 15, 3),
/* 100  */V(15, 9, 3),
/* 101  */V(15, 8, 3),
/* 110  */V(8, 15, 2),
/* 111  */V(8, 15, 2),

/* 0000 0010 ... */
/* 00   */V(7, 15, 2), /* 84 */
/* 01   */V(15, 7, 2),
/* 10   */V(6, 15, 2),
/* 11   */V(15, 6, 2),

/* 0000 0100 ... */
/* 00   */V(5, 15, 2), /* 88 */
/* 01   */V(15, 5, 2),
/* 10   */V(4, 15, 1),
/* 11   */V(4, 15, 1),

/* 0000 0101 ... */
/* 0    */V(15, 4, 1), /* 92 */
/* 1    */V(15, 3, 1),

/* 0000 0110 ... */
/* 0000 */V(15, 0, 1), /* 94 */
/* 0001 */V(15, 0, 1),
/* 0010 */V(15, 0, 1),
/* 0011 */V(15, 0, 1),
/* 0100 */V(15, 0, 1),
/* 0101 */V(15, 0, 1),
/* 0110 */V(15, 0, 1),
/* 0111 */V(15, 0, 1),
/* 1000 */V(3, 15, 2),
/* 1001 */V(3, 15, 2),
/* 1010 */V(3, 15, 2),
/* 1011 */V(3, 15, 2),
/* 1100 */PTR(294, 4),
/* 1101 */PTR(310, 3),
/* 1110 */PTR(318, 3),
/* 1111 */PTR(326, 3),

/* 0000 1000 ... */
/* 0    */V(2, 15, 1), /* 110 */
/* 1    */V(0, 15, 1),

/* 0000 1011 ... */
/* 0000 */PTR(334, 2), /* 112 */
/* 0001 */PTR(338, 2),
/* 0010 */PTR(342, 2),
/* 0011 */PTR(346, 1),
/* 0100 */PTR(348, 2),
/* 0101 */PTR(352, 2),
/* 0110 */PTR(356, 1),
/* 0111 */PTR(358, 2),
/* 1000 */PTR(362, 2),
/* 1001 */PTR(366, 2),
/* 1010 */PTR(370, 2),
/* 1011 */V(14, 3, 4),
/* 1100 */PTR(374, 1),
/* 1101 */PTR(376, 1),
/* 1110 */PTR(378, 1),
/* 1111 */PTR(380, 1),

/* 0000 1100 ... */
/* 0000 */PTR(382, 1), /* 128 */
/* 0001 */PTR(384, 1),
/* 0010 */PTR(386, 1),
/* 0011 */V(0, 13, 4),
/* 0100 */PTR(388, 1),
/* 0101 */PTR(390, 1),
/* 0110 */PTR(392, 1),
/* 0111 */V(3, 12, 4),
/* 1000 */PTR(394, 1),
/* 1001 */V(1, 12, 4),
/* 1010 */V(12, 0, 4),
/* 1011 */PTR(396, 1),
/* 1100 */V(14, 2, 3),
/* 1101 */V(14, 2, 3),
/* 1110 */V(2, 14, 4),
/* 1111 */V(1, 14, 4),

/* 0000 1101 ... */
/* 0000 */V(13, 3, 4), /* 144 */
/* 0001 */V(2, 13, 4),
/* 0010 */V(13, 2, 4),
/* 0011 */V(13, 1, 4),
/* 0100 */V(3, 11, 4),
/* 0101 */PTR(398, 1),
/* 0110 */V(1, 13, 3),
/* 0111 */V(1, 13, 3),
/* 1000 */V(12, 4, 4),
/* 1001 */V(6, 11, 4),
/* 1010 */V(12, 3, 4),
/* 1011 */V(10, 7, 4),
/* 1100 */V(2, 12, 3),
/* 1101 */V(2, 12, 3),
/* 1110 */V(12, 2, 4),
/* 1111 */V(11, 5, 4),

/* 0000 1110 ... */
/* 0000 */V(12, 1, 4), /* 160 */
/* 0001 */V(0, 12, 4),
/* 0010 */V(4, 11, 4),
/* 0011 */V(11, 4, 4),
/* 0100 */V(6, 10, 4),
/* 0101 */V(10, 6, 4),
/* 0110 */V(11, 3, 3),
/* 0111 */V(11, 3, 3),
/* 1000 */V(5, 10, 4),
/* 1001 */V(10, 5, 4),
/* 1010 */V(2, 11, 3),
/* 1011 */V(2, 11, 3),
/* 1100 */V(11, 2, 3),
/* 1101 */V(11, 2, 3),
/* 1110 */V(1, 11, 3),
/* 1111 */V(1, 11, 3),

/* 0000 1111 ... */
/* 0000 */V(11, 1, 3), /* 176 */
/* 0001 */V(11, 1, 3),
/* 0010 */V(0, 11, 4),
/* 0011 */V(11, 0, 4),
/* 0100 */V(6, 9, 4),
/* 0101 */V(9, 6, 4),
/* 0110 */V(4, 10, 4),
/* 0111 */V(10, 4, 4),
/* 1000 */V(7, 8, 4),
/* 1001 */V(8, 7, 4),
/* 1010 */V(10, 3, 3),
/* 1011 */V(10, 3, 3),
/* 1100 */V(3, 10, 4),
/* 1101 */V(5, 9, 4),
/* 1110 */V(2, 10, 3),
/* 1111 */V(2, 10, 3),

/* 0001 0000 ... */
/* 0000 */V(9, 5, 4), /* 192 */
/* 0001 */V(6, 8, 4),
/* 0010 */V(10, 1, 3),
/* 0011 */V(10, 1, 3),
/* 0100 */V(8, 6, 4),
/* 0101 */V(7, 7, 4),
/* 0110 */V(9, 4, 3),
/* 0111 */V(9, 4, 3),
/* 1000 */V(4, 9, 4),
/* 1001 */V(5, 7, 4),
/* 1010 */V(6, 7, 3),
/* 1011 */V(6, 7, 3),
/* 1100 */V(10, 2, 2),
/* 1101 */V(10, 2, 2),
/* 1110 */V(10, 2, 2),
/* 1111 */V(10, 2, 2),

/* 0001 0001 ... */
/* 000  */V(1, 10, 2), /* 208 */
/* 001  */V(1, 10, 2),
/* 010  */V(0, 10, 3),
/* 011  */V(10, 0, 3),
/* 100  */V(3, 9, 3),
/* 101  */V(9, 3, 3),
/* 110  */V(5, 8, 3),
/* 111  */V(8, 5, 3),

/* 0001 0010 ... */
/* 000  */V(2, 9, 2), /* 216 */
/* 001  */V(2, 9, 2),
/* 010  */V(9, 2, 2),
/* 011  */V(9, 2, 2),
/* 100  */V(7, 6, 3),
/* 101  */V(0, 9, 3),
/* 110  */V(1, 9, 2),
/* 111  */V(1, 9, 2),

/* 0001 0011 ... */
/* 000  */V(9, 1, 2), /* 224 */
/* 001  */V(9, 1, 2),
/* 010  */V(9, 0, 3),
/* 011  */V(4, 8, 3),
/* 100  */V(8, 4, 3),
/* 101  */V(7, 5, 3),
/* 110  */V(3, 8, 3),
/* 111  */V(8, 3, 3),

/* 0001 0100 ... */
/* 000  */V(6, 6, 3), /* 232 */
/* 001  */V(2, 8, 3),
/* 010  */V(8, 2, 2),
/* 011  */V(8, 2, 2),
/* 100  */V(4, 7, 3),
/* 101  */V(7, 4, 3),
/* 110  */V(1, 8, 2),
/* 111  */V(1, 8, 2),

/* 0001 0101 ... */
/* 000  */V(8, 1, 2), /* 240 */
/* 001  */V(8, 1, 2),
/* 010  */V(8, 0, 2),
/* 011  */V(8, 0, 2),
/* 100  */V(0, 8, 3),
/* 101  */V(5, 6, 3),
/* 110  */V(3, 7, 2),
/* 111  */V(3, 7, 2),

/* 0001 0110 ... */
/* 000  */V(7, 3, 2), /* 248 */
/* 001  */V(7, 3, 2),
/* 010  */V(6, 5, 3),
/* 011  */V(4, 6, 3),
/* 100  */V(2, 7, 2),
/* 101  */V(2, 7, 2),
/* 110  */V(7, 2, 2),
/* 111  */V(7, 2, 2),

/* 0001 0111 ... */
/* 000  */V(6, 4, 3), /* 256 */
/* 001  */V(5, 5, 3),
/* 010  */V(0, 7, 2),
/* 011  */V(0, 7, 2),
/* 100  */V(1, 7, 1),
/* 101  */V(1, 7, 1),
/* 110  */V(1, 7, 1),
/* 111  */V(1, 7, 1),

/* 0001 1000 ... */
/* 00   */V(7, 1, 1), /* 264  */
/* 01   */V(7, 1, 1),
/* 10   */V(7, 0, 2),
/* 11   */V(3, 6, 2),

/* 0001 1001 ... */
/* 00   */V(6, 3, 2), /* 268 */
/* 01   */V(4, 5, 2),
/* 10   */V(5, 4, 2),
/* 11   */V(2, 6, 2),

/* 0001 1010 ... */
/* 0    */V(6, 2, 1), /* 272 */
/* 1    */V(1, 6, 1),

/* 0001 1011 ... */
/* 00   */V(6, 1, 1), /* 274 */
/* 01   */V(6, 1, 1),
/* 10   */V(0, 6, 2),
/* 11   */V(6, 0, 2),

/* 0001 1100 ... */
/* 00   */V(5, 3, 1), /* 278 */
/* 01   */V(5, 3, 1),
/* 10   */V(3, 5, 2),
/* 11   */V(4, 4, 2),

/* 0001 1101 ... */
/* 0    */V(2, 5, 1), /* 282 */
/* 1    */V(5, 2, 1),

/* 0001 1111 ... */
/* 0    */V(1, 5, 1), /* 284 */
/* 1    */V(0, 5, 1),

/* 0010 0000 ... */
/* 0    */V(3, 4, 1), /* 286 */
/* 1    */V(4, 3, 1),

/* 0010 0001 ... */
/* 0    */V(5, 0, 1), /* 288 */
/* 1    */V(2, 4, 1),

/* 0010 0010 ... */
/* 0    */V(4, 2, 1), /* 290 */
/* 1    */V(3, 3, 1),

/* 0010 0101 ... */
/* 0    */V(0, 4, 1), /* 292 */
/* 1    */V(4, 0, 1),

/* 0000 0110 1100 ... */
/* 0000 */V(12, 14, 4), /* 294 */
/* 0001 */PTR(400, 1),
/* 0010 */V(13, 14, 3),
/* 0011 */V(13, 14, 3),
/* 0100 */V(14, 9, 3),
/* 0101 */V(14, 9, 3),
/* 0110 */V(14, 10, 4),
/* 0111 */V(13, 9, 4),
/* 1000 */V(14, 14, 2),
/* 1001 */V(14, 14, 2),
/* 1010 */V(14, 14, 2),
/* 1011 */V(14, 14, 2),
/* 1100 */V(14, 13, 3),
/* 1101 */V(14, 13, 3),
/* 1110 */V(14, 11, 3),
/* 1111 */V(14, 11, 3),

/* 0000 0110 1101 ... */
/* 000  */V(11, 14, 2), /* 310 */
/* 001  */V(11, 14, 2),
/* 010  */V(12, 13, 2),
/* 011  */V(12, 13, 2),
/* 100  */V(13, 12, 3),
/* 101  */V(13, 11, 3),
/* 110  */V(10, 14, 2),
/* 111  */V(10, 14, 2),

/* 0000 0110 1110 ... */
/* 000  */V(12, 12, 2), /* 318 */
/* 001  */V(12, 12, 2),
/* 010  */V(10, 13, 3),
/* 011  */V(13, 10, 3),
/* 100  */V(7, 14, 3),
/* 101  */V(10, 12, 3),
/* 110  */V(12, 10, 2),
/* 111  */V(12, 10, 2),

/* 0000 0110 1111 ... */
/* 000  */V(12, 9, 3), /* 326 */
/* 001  */V(7, 13, 3),
/* 010  */V(5, 14, 2),
/* 011  */V(5, 14, 2),
/* 100  */V(11, 13, 1),
/* 101  */V(11, 13, 1),
/* 110  */V(11, 13, 1),
/* 111  */V(11, 13, 1),

/* 0000 1011 0000 ... */
/* 00   */V(9, 14, 1), /* 334 */
/* 01   */V(9, 14, 1),
/* 10   */V(11, 12, 2),
/* 11   */V(12, 11, 2),

/* 0000 1011 0001 ... */
/* 00   */V(8, 14, 2), /* 338 */
/* 01   */V(14, 8, 2),
/* 10   */V(9, 13, 2),
/* 11   */V(14, 7, 2),

/* 0000 1011 0010 ... */
/* 00   */V(11, 11, 2), /* 342 */
/* 01   */V(8, 13, 2),
/* 10   */V(13, 8, 2),
/* 11   */V(6, 14, 2),

/* 0000 1011 0011 ... */
/* 0    */V(14, 6, 1), /* 346 */
/* 1    */V(9, 12, 1),

/* 0000 1011 0100 ... */
/* 00   */V(10, 11, 2), /* 348 */
/* 01   */V(11, 10, 2),
/* 10   */V(14, 5, 2),
/* 11   */V(13, 7, 2),

/* 0000 1011 0101 ... */
/* 00   */V(4, 14, 1), /* 352 */
/* 01   */V(4, 14, 1),
/* 10   */V(14, 4, 2),
/* 11   */V(8, 12, 2),

/* 0000 1011 0110 ... */
/* 0    */V(12, 8, 1), /* 356 */
/* 1    */V(3, 14, 1),

/* 0000 1011 0111 ... */
/* 00   */V(6, 13, 1), /* 358 */
/* 01   */V(6, 13, 1),
/* 10   */V(13, 6, 2),
/* 11   */V(9, 11, 2),

/* 0000 1011 1000 ... */
/* 00   */V(11, 9, 2), /* 362 */
/* 01   */V(10, 10, 2),
/* 10   */V(14, 1, 1),
/* 11   */V(14, 1, 1),

/* 0000 1011 1001 ... */
/* 00   */V(13, 4, 1), /* 366 */
/* 01   */V(13, 4, 1),
/* 10   */V(11, 8, 2),
/* 11   */V(10, 9, 2),

/* 0000 1011 1010 ... */
/* 00   */V(7, 11, 1), /* 370 */
/* 01   */V(7, 11, 1),
/* 10   */V(11, 7, 2),
/* 11   */V(13, 0, 2),

/* 0000 1011 1100 ... */
/* 0    */V(0, 14, 1), /* 374 */
/* 1    */V(14, 0, 1),

/* 0000 1011 1101 ... */
/* 0    */V(5, 13, 1), /* 376 */
/* 1    */V(13, 5, 1),

/* 0000 1011 1110 ... */
/* 0    */V(7, 12, 1), /* 378 */
/* 1    */V(12, 7, 1),

/* 0000 1011 1111 ... */
/* 0    */V(4, 13, 1), /* 380 */
/* 1    */V(8, 11, 1),

/* 0000 1100 0000 ... */
/* 0    */V(9, 10, 1), /* 382 */
/* 1    */V(6, 12, 1),

/* 0000 1100 0001 ... */
/* 0    */V(12, 6, 1), /* 384 */
/* 1    */V(3, 13, 1),

/* 0000 1100 0010 ... */
/* 0    */V(5, 12, 1), /* 386 */
/* 1    */V(12, 5, 1),

/* 0000 1100 0100 ... */
/* 0    */V(8, 10, 1), /* 388 */
/* 1    */V(10, 8, 1),

/* 0000 1100 0101 ... */
/* 0    */V(9, 9, 1), /* 390 */
/* 1    */V(4, 12, 1),

/* 0000 1100 0110 ... */
/* 0    */V(11, 6, 1), /* 392 */
/* 1    */V(7, 10, 1),

/* 0000 1100 1000 ... */
/* 0    */V(5, 11, 1), /* 394 */
/* 1    */V(8, 9, 1),

/* 0000 1100 1011 ... */
/* 0    */V(9, 8, 1), /* 396 */
/* 1    */V(7, 9, 1),

/* 0000 1101 0101 ... */
/* 0    */V(9, 7, 1), /* 398 */
/* 1    */V(8, 8, 1),

/* 0000 0110 1100 0001 ... */
/* 0    */V(14, 12, 1), /* 400 */
/* 1    */V(13, 13, 1)];

var hufftab24 = [
/* 0000 */PTR(16, 4),
/* 0001 */PTR(32, 4),
/* 0010 */PTR(48, 4),
/* 0011 */V(15, 15, 4),
/* 0100 */PTR(64, 4),
/* 0101 */PTR(80, 4),
/* 0110 */PTR(96, 4),
/* 0111 */PTR(112, 4),
/* 1000 */PTR(128, 4),
/* 1001 */PTR(144, 4),
/* 1010 */PTR(160, 3),
/* 1011 */PTR(168, 2),
/* 1100 */V(1, 1, 4),
/* 1101 */V(0, 1, 4),
/* 1110 */V(1, 0, 4),
/* 1111 */V(0, 0, 4),

/* 0000 ... */
/* 0000 */V(14, 15, 4), /* 16 */
/* 0001 */V(15, 14, 4),
/* 0010 */V(13, 15, 4),
/* 0011 */V(15, 13, 4),
/* 0100 */V(12, 15, 4),
/* 0101 */V(15, 12, 4),
/* 0110 */V(11, 15, 4),
/* 0111 */V(15, 11, 4),
/* 1000 */V(15, 10, 3),
/* 1001 */V(15, 10, 3),
/* 1010 */V(10, 15, 4),
/* 1011 */V(9, 15, 4),
/* 1100 */V(15, 9, 3),
/* 1101 */V(15, 9, 3),
/* 1110 */V(15, 8, 3),
/* 1111 */V(15, 8, 3),

/* 0001 ... */
/* 0000 */V(8, 15, 4), /* 32 */
/* 0001 */V(7, 15, 4),
/* 0010 */V(15, 7, 3),
/* 0011 */V(15, 7, 3),
/* 0100 */V(6, 15, 3),
/* 0101 */V(6, 15, 3),
/* 0110 */V(15, 6, 3),
/* 0111 */V(15, 6, 3),
/* 1000 */V(5, 15, 3),
/* 1001 */V(5, 15, 3),
/* 1010 */V(15, 5, 3),
/* 1011 */V(15, 5, 3),
/* 1100 */V(4, 15, 3),
/* 1101 */V(4, 15, 3),
/* 1110 */V(15, 4, 3),
/* 1111 */V(15, 4, 3),

/* 0010 ... */
/* 0000 */V(3, 15, 3), /* 48 */
/* 0001 */V(3, 15, 3),
/* 0010 */V(15, 3, 3),
/* 0011 */V(15, 3, 3),
/* 0100 */V(2, 15, 3),
/* 0101 */V(2, 15, 3),
/* 0110 */V(15, 2, 3),
/* 0111 */V(15, 2, 3),
/* 1000 */V(15, 1, 3),
/* 1001 */V(15, 1, 3),
/* 1010 */V(1, 15, 4),
/* 1011 */V(15, 0, 4),
/* 1100 */PTR(172, 3),
/* 1101 */PTR(180, 3),
/* 1110 */PTR(188, 3),
/* 1111 */PTR(196, 3),

/* 0100 ... */
/* 0000 */PTR(204, 4), /* 64 */
/* 0001 */PTR(220, 3),
/* 0010 */PTR(228, 3),
/* 0011 */PTR(236, 3),
/* 0100 */PTR(244, 2),
/* 0101 */PTR(248, 2),
/* 0110 */PTR(252, 2),
/* 0111 */PTR(256, 2),
/* 1000 */PTR(260, 2),
/* 1001 */PTR(264, 2),
/* 1010 */PTR(268, 2),
/* 1011 */PTR(272, 2),
/* 1100 */PTR(276, 2),
/* 1101 */PTR(280, 3),
/* 1110 */PTR(288, 2),
/* 1111 */PTR(292, 2),

/* 0101 ... */
/* 0000 */PTR(296, 2), /* 80 */
/* 0001 */PTR(300, 3),
/* 0010 */PTR(308, 2),
/* 0011 */PTR(312, 3),
/* 0100 */PTR(320, 1),
/* 0101 */PTR(322, 2),
/* 0110 */PTR(326, 2),
/* 0111 */PTR(330, 1),
/* 1000 */PTR(332, 2),
/* 1001 */PTR(336, 1),
/* 1010 */PTR(338, 1),
/* 1011 */PTR(340, 1),
/* 1100 */PTR(342, 1),
/* 1101 */PTR(344, 1),
/* 1110 */PTR(346, 1),
/* 1111 */PTR(348, 1),

/* 0110 ... */
/* 0000 */PTR(350, 1), /* 96 */
/* 0001 */PTR(352, 1),
/* 0010 */PTR(354, 1),
/* 0011 */PTR(356, 1),
/* 0100 */PTR(358, 1),
/* 0101 */PTR(360, 1),
/* 0110 */PTR(362, 1),
/* 0111 */PTR(364, 1),
/* 1000 */PTR(366, 1),
/* 1001 */PTR(368, 1),
/* 1010 */PTR(370, 2),
/* 1011 */PTR(374, 1),
/* 1100 */PTR(376, 2),
/* 1101 */V(7, 3, 4),
/* 1110 */PTR(380, 1),
/* 1111 */V(7, 2, 4),

/* 0111 ... */
/* 0000 */V(4, 6, 4), /* 112 */
/* 0001 */V(6, 4, 4),
/* 0010 */V(5, 5, 4),
/* 0011 */V(7, 1, 4),
/* 0100 */V(3, 6, 4),
/* 0101 */V(6, 3, 4),
/* 0110 */V(4, 5, 4),
/* 0111 */V(5, 4, 4),
/* 1000 */V(2, 6, 4),
/* 1001 */V(6, 2, 4),
/* 1010 */V(1, 6, 4),
/* 1011 */V(6, 1, 4),
/* 1100 */PTR(382, 1),
/* 1101 */V(3, 5, 4),
/* 1110 */V(5, 3, 4),
/* 1111 */V(4, 4, 4),

/* 1000 ... */
/* 0000 */V(2, 5, 4), /* 128 */
/* 0001 */V(5, 2, 4),
/* 0010 */V(1, 5, 4),
/* 0011 */PTR(384, 1),
/* 0100 */V(5, 1, 3),
/* 0101 */V(5, 1, 3),
/* 0110 */V(3, 4, 4),
/* 0111 */V(4, 3, 4),
/* 1000 */V(2, 4, 3),
/* 1001 */V(2, 4, 3),
/* 1010 */V(4, 2, 3),
/* 1011 */V(4, 2, 3),
/* 1100 */V(3, 3, 3),
/* 1101 */V(3, 3, 3),
/* 1110 */V(1, 4, 3),
/* 1111 */V(1, 4, 3),

/* 1001 ... */
/* 0000 */V(4, 1, 3), /* 144 */
/* 0001 */V(4, 1, 3),
/* 0010 */V(0, 4, 4),
/* 0011 */V(4, 0, 4),
/* 0100 */V(2, 3, 3),
/* 0101 */V(2, 3, 3),
/* 0110 */V(3, 2, 3),
/* 0111 */V(3, 2, 3),
/* 1000 */V(1, 3, 2),
/* 1001 */V(1, 3, 2),
/* 1010 */V(1, 3, 2),
/* 1011 */V(1, 3, 2),
/* 1100 */V(3, 1, 2),
/* 1101 */V(3, 1, 2),
/* 1110 */V(3, 1, 2),
/* 1111 */V(3, 1, 2),

/* 1010 ... */
/* 000  */V(0, 3, 3), /* 160 */
/* 001  */V(3, 0, 3),
/* 010  */V(2, 2, 2),
/* 011  */V(2, 2, 2),
/* 100  */V(1, 2, 1),
/* 101  */V(1, 2, 1),
/* 110  */V(1, 2, 1),
/* 111  */V(1, 2, 1),

/* 1011 ... */
/* 00   */V(2, 1, 1), /* 168 */
/* 01   */V(2, 1, 1),
/* 10   */V(0, 2, 2),
/* 11   */V(2, 0, 2),

/* 0010 1100 ... */
/* 000  */V(0, 15, 1), /* 172 */
/* 001  */V(0, 15, 1),
/* 010  */V(0, 15, 1),
/* 011  */V(0, 15, 1),
/* 100  */V(14, 14, 3),
/* 101  */V(13, 14, 3),
/* 110  */V(14, 13, 3),
/* 111  */V(12, 14, 3),

/* 0010 1101 ... */
/* 000  */V(14, 12, 3), /* 180 */
/* 001  */V(13, 13, 3),
/* 010  */V(11, 14, 3),
/* 011  */V(14, 11, 3),
/* 100  */V(12, 13, 3),
/* 101  */V(13, 12, 3),
/* 110  */V(10, 14, 3),
/* 111  */V(14, 10, 3),

/* 0010 1110 ... */
/* 000  */V(11, 13, 3), /* 188 */
/* 001  */V(13, 11, 3),
/* 010  */V(12, 12, 3),
/* 011  */V(9, 14, 3),
/* 100  */V(14, 9, 3),
/* 101  */V(10, 13, 3),
/* 110  */V(13, 10, 3),
/* 111  */V(11, 12, 3),

/* 0010 1111 ... */
/* 000  */V(12, 11, 3), /* 196 */
/* 001  */V(8, 14, 3),
/* 010  */V(14, 8, 3),
/* 011  */V(9, 13, 3),
/* 100  */V(13, 9, 3),
/* 101  */V(7, 14, 3),
/* 110  */V(14, 7, 3),
/* 111  */V(10, 12, 3),

/* 0100 0000 ... */
/* 0000 */V(12, 10, 3), /* 204 */
/* 0001 */V(12, 10, 3),
/* 0010 */V(11, 11, 3),
/* 0011 */V(11, 11, 3),
/* 0100 */V(8, 13, 3),
/* 0101 */V(8, 13, 3),
/* 0110 */V(13, 8, 3),
/* 0111 */V(13, 8, 3),
/* 1000 */V(0, 14, 4),
/* 1001 */V(14, 0, 4),
/* 1010 */V(0, 13, 3),
/* 1011 */V(0, 13, 3),
/* 1100 */V(14, 6, 2),
/* 1101 */V(14, 6, 2),
/* 1110 */V(14, 6, 2),
/* 1111 */V(14, 6, 2),

/* 0100 0001 ... */
/* 000  */V(6, 14, 3), /* 220 */
/* 001  */V(9, 12, 3),
/* 010  */V(12, 9, 2),
/* 011  */V(12, 9, 2),
/* 100  */V(5, 14, 2),
/* 101  */V(5, 14, 2),
/* 110  */V(11, 10, 2),
/* 111  */V(11, 10, 2),

/* 0100 0010 ... */
/* 000  */V(14, 5, 2), /* 228 */
/* 001  */V(14, 5, 2),
/* 010  */V(10, 11, 3),
/* 011  */V(7, 13, 3),
/* 100  */V(13, 7, 2),
/* 101  */V(13, 7, 2),
/* 110  */V(14, 4, 2),
/* 111  */V(14, 4, 2),

/* 0100 0011 ... */
/* 000  */V(8, 12, 2), /* 236 */
/* 001  */V(8, 12, 2),
/* 010  */V(12, 8, 2),
/* 011  */V(12, 8, 2),
/* 100  */V(4, 14, 3),
/* 101  */V(2, 14, 3),
/* 110  */V(3, 14, 2),
/* 111  */V(3, 14, 2),

/* 0100 0100 ... */
/* 00   */V(6, 13, 2), /* 244 */
/* 01   */V(13, 6, 2),
/* 10   */V(14, 3, 2),
/* 11   */V(9, 11, 2),

/* 0100 0101 ... */
/* 00   */V(11, 9, 2), /* 248 */
/* 01   */V(10, 10, 2),
/* 10   */V(14, 2, 2),
/* 11   */V(1, 14, 2),

/* 0100 0110 ... */
/* 00   */V(14, 1, 2), /* 252 */
/* 01   */V(5, 13, 2),
/* 10   */V(13, 5, 2),
/* 11   */V(7, 12, 2),

/* 0100 0111 ... */
/* 00   */V(12, 7, 2), /* 256 */
/* 01   */V(4, 13, 2),
/* 10   */V(8, 11, 2),
/* 11   */V(11, 8, 2),

/* 0100 1000 ... */
/* 00   */V(13, 4, 2), /* 260 */
/* 01   */V(9, 10, 2),
/* 10   */V(10, 9, 2),
/* 11   */V(6, 12, 2),

/* 0100 1001 ... */
/* 00   */V(12, 6, 2), /* 264 */
/* 01   */V(3, 13, 2),
/* 10   */V(13, 3, 2),
/* 11   */V(2, 13, 2),

/* 0100 1010 ... */
/* 00   */V(13, 2, 2), /* 268 */
/* 01   */V(1, 13, 2),
/* 10   */V(7, 11, 2),
/* 11   */V(11, 7, 2),

/* 0100 1011 ... */
/* 00   */V(13, 1, 2), /* 272 */
/* 01   */V(5, 12, 2),
/* 10   */V(12, 5, 2),
/* 11   */V(8, 10, 2),

/* 0100 1100 ... */
/* 00   */V(10, 8, 2), /* 276 */
/* 01   */V(9, 9, 2),
/* 10   */V(4, 12, 2),
/* 11   */V(12, 4, 2),

/* 0100 1101 ... */
/* 000  */V(6, 11, 2), /* 280 */
/* 001  */V(6, 11, 2),
/* 010  */V(11, 6, 2),
/* 011  */V(11, 6, 2),
/* 100  */V(13, 0, 3),
/* 101  */V(0, 12, 3),
/* 110  */V(3, 12, 2),
/* 111  */V(3, 12, 2),

/* 0100 1110 ... */
/* 00   */V(12, 3, 2), /* 288 */
/* 01   */V(7, 10, 2),
/* 10   */V(10, 7, 2),
/* 11   */V(2, 12, 2),

/* 0100 1111 ... */
/* 00   */V(12, 2, 2), /* 292 */
/* 01   */V(5, 11, 2),
/* 10   */V(11, 5, 2),
/* 11   */V(1, 12, 2),

/* 0101 0000 ... */
/* 00   */V(8, 9, 2), /* 296 */
/* 01   */V(9, 8, 2),
/* 10   */V(12, 1, 2),
/* 11   */V(4, 11, 2),

/* 0101 0001 ... */
/* 000  */V(12, 0, 3), /* 300 */
/* 001  */V(0, 11, 3),
/* 010  */V(3, 11, 2),
/* 011  */V(3, 11, 2),
/* 100  */V(11, 0, 3),
/* 101  */V(0, 10, 3),
/* 110  */V(1, 10, 2),
/* 111  */V(1, 10, 2),

/* 0101 0010 ... */
/* 00   */V(11, 4, 1), /* 308 */
/* 01   */V(11, 4, 1),
/* 10   */V(6, 10, 2),
/* 11   */V(10, 6, 2),

/* 0101 0011 ... */
/* 000  */V(7, 9, 2), /* 312 */
/* 001  */V(7, 9, 2),
/* 010  */V(9, 7, 2),
/* 011  */V(9, 7, 2),
/* 100  */V(10, 0, 3),
/* 101  */V(0, 9, 3),
/* 110  */V(9, 0, 2),
/* 111  */V(9, 0, 2),

/* 0101 0100 ... */
/* 0    */V(11, 3, 1), /* 320 */
/* 1    */V(8, 8, 1),

/* 0101 0101 ... */
/* 00   */V(2, 11, 2), /* 322 */
/* 01   */V(5, 10, 2),
/* 10   */V(11, 2, 1),
/* 11   */V(11, 2, 1),

/* 0101 0110 ... */
/* 00   */V(10, 5, 2), /* 326 */
/* 01   */V(1, 11, 2),
/* 10   */V(11, 1, 2),
/* 11   */V(6, 9, 2),

/* 0101 0111 ... */
/* 0    */V(9, 6, 1), /* 330 */
/* 1    */V(10, 4, 1),

/* 0101 1000 ... */
/* 00   */V(4, 10, 2), /* 332 */
/* 01   */V(7, 8, 2),
/* 10   */V(8, 7, 1),
/* 11   */V(8, 7, 1),

/* 0101 1001 ... */
/* 0    */V(3, 10, 1), /* 336 */
/* 1    */V(10, 3, 1),

/* 0101 1010 ... */
/* 0    */V(5, 9, 1), /* 338 */
/* 1    */V(9, 5, 1),

/* 0101 1011 ... */
/* 0    */V(2, 10, 1), /* 340 */
/* 1    */V(10, 2, 1),

/* 0101 1100 ... */
/* 0    */V(10, 1, 1), /* 342 */
/* 1    */V(6, 8, 1),

/* 0101 1101 ... */
/* 0    */V(8, 6, 1), /* 344 */
/* 1    */V(7, 7, 1),

/* 0101 1110 ... */
/* 0    */V(4, 9, 1), /* 346 */
/* 1    */V(9, 4, 1),

/* 0101 1111 ... */
/* 0    */V(3, 9, 1), /* 348 */
/* 1    */V(9, 3, 1),

/* 0110 0000 ... */
/* 0    */V(5, 8, 1), /* 350 */
/* 1    */V(8, 5, 1),

/* 0110 0001 ... */
/* 0    */V(2, 9, 1), /* 352 */
/* 1    */V(6, 7, 1),

/* 0110 0010 ... */
/* 0    */V(7, 6, 1), /* 354 */
/* 1    */V(9, 2, 1),

/* 0110 0011 ... */
/* 0    */V(1, 9, 1), /* 356 */
/* 1    */V(9, 1, 1),

/* 0110 0100 ... */
/* 0    */V(4, 8, 1), /* 358 */
/* 1    */V(8, 4, 1),

/* 0110 0101 ... */
/* 0    */V(5, 7, 1), /* 360 */
/* 1    */V(7, 5, 1),

/* 0110 0110 ... */
/* 0    */V(3, 8, 1), /* 362 */
/* 1    */V(8, 3, 1),

/* 0110 0111 ... */
/* 0    */V(6, 6, 1), /* 364 */
/* 1    */V(2, 8, 1),

/* 0110 1000 ... */
/* 0    */V(8, 2, 1), /* 366 */
/* 1    */V(1, 8, 1),

/* 0110 1001 ... */
/* 0    */V(4, 7, 1), /* 368 */
/* 1    */V(7, 4, 1),

/* 0110 1010 ... */
/* 00   */V(8, 1, 1), /* 370 */
/* 01   */V(8, 1, 1),
/* 10   */V(0, 8, 2),
/* 11   */V(8, 0, 2),

/* 0110 1011 ... */
/* 0    */V(5, 6, 1), /* 374 */
/* 1    */V(6, 5, 1),

/* 0110 1100 ... */
/* 00   */V(1, 7, 1), /* 376 */
/* 01   */V(1, 7, 1),
/* 10   */V(0, 7, 2),
/* 11   */V(7, 0, 2),

/* 0110 1110 ... */
/* 0    */V(3, 7, 1), /* 380  */
/* 1    */V(2, 7, 1),

/* 0111 1100 ... */
/* 0    */V(0, 6, 1), /* 382 */
/* 1    */V(6, 0, 1),

/* 1000 0011 ... */
/* 0    */V(0, 5, 1), /* 384 */
/* 1    */V(5, 0, 1)];

/* hufftable constructor */
var Hufftable = function (table, linbits, startbits) {
  this.table = table;
  this.linbits = linbits;
  this.startbits = startbits;
};

/* external tables */
const huff_quad_table = [hufftabA, hufftabB];
/* harmony export (immutable) */ __webpack_exports__["b"] = huff_quad_table;


const huff_pair_table = [
/*  0 */new Hufftable(hufftab0, 0, 0),
/*  1 */new Hufftable(hufftab1, 0, 3),
/*  2 */new Hufftable(hufftab2, 0, 3),
/*  3 */new Hufftable(hufftab3, 0, 3),
/*  4 */null, //new Hufftable(0 /* not used */),
/*  5 */new Hufftable(hufftab5, 0, 3),
/*  6 */new Hufftable(hufftab6, 0, 4),
/*  7 */new Hufftable(hufftab7, 0, 4),
/*  8 */new Hufftable(hufftab8, 0, 4),
/*  9 */new Hufftable(hufftab9, 0, 4),
/* 10 */new Hufftable(hufftab10, 0, 4),
/* 11 */new Hufftable(hufftab11, 0, 4),
/* 12 */new Hufftable(hufftab12, 0, 4),
/* 13 */new Hufftable(hufftab13, 0, 4),
/* 14 */null, //new Hufftable(0 /* not used */),
/* 15 */new Hufftable(hufftab15, 0, 4),
/* 16 */new Hufftable(hufftab16, 1, 4),
/* 17 */new Hufftable(hufftab16, 2, 4),
/* 18 */new Hufftable(hufftab16, 3, 4),
/* 19 */new Hufftable(hufftab16, 4, 4),
/* 20 */new Hufftable(hufftab16, 6, 4),
/* 21 */new Hufftable(hufftab16, 8, 4),
/* 22 */new Hufftable(hufftab16, 10, 4),
/* 23 */new Hufftable(hufftab16, 13, 4),
/* 24 */new Hufftable(hufftab24, 4, 4),
/* 25 */new Hufftable(hufftab24, 5, 4),
/* 26 */new Hufftable(hufftab24, 6, 4),
/* 27 */new Hufftable(hufftab24, 7, 4),
/* 28 */new Hufftable(hufftab24, 8, 4),
/* 29 */new Hufftable(hufftab24, 9, 4),
/* 30 */new Hufftable(hufftab24, 11, 4),
/* 31 */new Hufftable(hufftab24, 13, 4)];
/* harmony export (immutable) */ __webpack_exports__["a"] = huff_pair_table;


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var imdct_s = [
/*  0 */[0.608761429, -0.923879533, -0.130526192, 0.991444861, -0.382683432, -0.793353340],

/*  6 */[-0.793353340, 0.382683432, 0.991444861, 0.130526192, -0.923879533, -0.608761429],

/*  1 */[0.382683432, -0.923879533, 0.923879533, -0.382683432, -0.382683432, 0.923879533],

/*  7 */[-0.923879533, -0.382683432, 0.382683432, 0.923879533, 0.923879533, 0.382683432],

/*  2 */[0.130526192, -0.382683432, 0.608761429, -0.793353340, 0.923879533, -0.991444861],

/*  8 */[-0.991444861, -0.923879533, -0.793353340, -0.608761429, -0.382683432, -0.130526192]];

/* harmony default export */ __webpack_exports__["a"] = (imdct_s);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
 * NAME:    synth.init()
 * DESCRIPTION: initialize synth struct
 */
var Synth = function () {
    this.filter = [];
    this.mute();
    this.phase = 0;

    this.pcm = {
        samplerate: 0,
        channels: 0,
        length: 0,
        samples: [
        // new Float64Array(new ArrayBuffer(8 * 1152)),
        // new Float64Array(new ArrayBuffer(8 * 1152))
        [], []]
    };

    // this.pcm.clone = function() {
    //     var copy = {};
    //     copy.samplerate = this.samplerate;
    //     copy.channels = this.channels;
    //     copy.length = this.length;
    //     copy.samples = [
    //         // new Float64Array(new ArrayBuffer(8 * 1152)),
    //         // new Float64Array(new ArrayBuffer(8 * 1152))
    //         [],
    //         []
    //     ];
    //     copy.samples[0].set(this.samples[0]);
    //     copy.samples[1].set(this.samples[1]);
    //     return copy;
    // }; 
};

/*
 * NAME:    synth.mute()
 * DESCRIPTION: zero all polyphase filterbank values, resetting synthesis
 */
Synth.prototype.mute = function () {
    for (var ch = 0; ch < 2; ++ch) {
        this.filter[ch] = [[[], []], [[], []]];

        for (var s = 0; s < 16; ++s) {
            this.filter[ch][0][0][s] = [];
            this.filter[ch][0][1][s] = [];
            this.filter[ch][1][0][s] = [];
            this.filter[ch][1][1][s] = [];

            for (var v = 0; v < 8; ++v) {
                this.filter[ch][0][0][s][v] = 0;
                this.filter[ch][0][1][s][v] = 0;
                this.filter[ch][1][0][s][v] = 0;
                this.filter[ch][1][1][s][v] = 0;
            }
        }
    }
};

/* costab[i] = cos(PI / (2 * 32) * i) */
var costab1 = 0.998795456;
var costab2 = 0.995184727;
var costab3 = 0.989176510;
var costab4 = 0.980785280;
var costab5 = 0.970031253;
var costab6 = 0.956940336;
var costab7 = 0.941544065;
var costab8 = 0.923879533;
var costab9 = 0.903989293;
var costab10 = 0.881921264;
var costab11 = 0.857728610;
var costab12 = 0.831469612;
var costab13 = 0.803207531;
var costab14 = 0.773010453;
var costab15 = 0.740951125;
var costab16 = 0.707106781;
var costab17 = 0.671558955;
var costab18 = 0.634393284;
var costab19 = 0.595699304;
var costab20 = 0.555570233;
var costab21 = 0.514102744;
var costab22 = 0.471396737;
var costab23 = 0.427555093;
var costab24 = 0.382683432;
var costab25 = 0.336889853;
var costab26 = 0.290284677;
var costab27 = 0.242980180;
var costab28 = 0.195090322;
var costab29 = 0.146730474;
var costab30 = 0.098017140;
var costab31 = 0.049067674;

/*
 * NAME:    dct32()
 * DESCRIPTION: perform fast in[32].out[32] DCT
 */
Synth.dct32 = function (_in /* [32] */, slot, lo /* [16][8] */, hi /* [16][8] */) {
    var t0, t1, t2, t3, t4, t5, t6, t7;
    var t8, t9, t10, t11, t12, t13, t14, t15;
    var t16, t17, t18, t19, t20, t21, t22, t23;
    var t24, t25, t26, t27, t28, t29, t30, t31;
    var t32, t33, t34, t35, t36, t37, t38, t39;
    var t40, t41, t42, t43, t44, t45, t46, t47;
    var t48, t49, t50, t51, t52, t53, t54, t55;
    var t56, t57, t58, t59, t60, t61, t62, t63;
    var t64, t65, t66, t67, t68, t69, t70, t71;
    var t72, t73, t74, t75, t76, t77, t78, t79;
    var t80, t81, t82, t83, t84, t85, t86, t87;
    var t88, t89, t90, t91, t92, t93, t94, t95;
    var t96, t97, t98, t99, t100, t101, t102, t103;
    var t104, t105, t106, t107, t108, t109, t110, t111;
    var t112, t113, t114, t115, t116, t117, t118, t119;
    var t120, t121, t122, t123, t124, t125, t126, t127;
    var t128, t129, t130, t131, t132, t133, t134, t135;
    var t136, t137, t138, t139, t140, t141, t142, t143;
    var t144, t145, t146, t147, t148, t149, t150, t151;
    var t152, t153, t154, t155, t156, t157, t158, t159;
    var t160, t161, t162, t163, t164, t165, t166, t167;
    var t168, t169, t170, t171, t172, t173, t174, t175;
    var t176;

    // var sys = require('sys');
    // for (i = 0; i < 32; i++) {
    //     sys.print(_in[i].toFixed(8) + "\t");
    //     if (i % 8 == 7) sys.print("\n");
    // }

    t0 = _in[0] + _in[31];t16 = (_in[0] - _in[31]) * costab1;
    t1 = _in[15] + _in[16];t17 = (_in[15] - _in[16]) * costab31;

    t41 = t16 + t17;
    t59 = (t16 - t17) * costab2;
    t33 = t0 + t1;
    t50 = (t0 - t1) * costab2;

    t2 = _in[7] + _in[24];t18 = (_in[7] - _in[24]) * costab15;
    t3 = _in[8] + _in[23];t19 = (_in[8] - _in[23]) * costab17;

    t42 = t18 + t19;
    t60 = (t18 - t19) * costab30;
    t34 = t2 + t3;
    t51 = (t2 - t3) * costab30;

    t4 = _in[3] + _in[28];t20 = (_in[3] - _in[28]) * costab7;
    t5 = _in[12] + _in[19];t21 = (_in[12] - _in[19]) * costab25;

    t43 = t20 + t21;
    t61 = (t20 - t21) * costab14;
    t35 = t4 + t5;
    t52 = (t4 - t5) * costab14;

    t6 = _in[4] + _in[27];t22 = (_in[4] - _in[27]) * costab9;
    t7 = _in[11] + _in[20];t23 = (_in[11] - _in[20]) * costab23;

    t44 = t22 + t23;
    t62 = (t22 - t23) * costab18;
    t36 = t6 + t7;
    t53 = (t6 - t7) * costab18;

    t8 = _in[1] + _in[30];t24 = (_in[1] - _in[30]) * costab3;
    t9 = _in[14] + _in[17];t25 = (_in[14] - _in[17]) * costab29;

    t45 = t24 + t25;
    t63 = (t24 - t25) * costab6;
    t37 = t8 + t9;
    t54 = (t8 - t9) * costab6;

    t10 = _in[6] + _in[25];t26 = (_in[6] - _in[25]) * costab13;
    t11 = _in[9] + _in[22];t27 = (_in[9] - _in[22]) * costab19;

    t46 = t26 + t27;
    t64 = (t26 - t27) * costab26;
    t38 = t10 + t11;
    t55 = (t10 - t11) * costab26;

    t12 = _in[2] + _in[29];t28 = (_in[2] - _in[29]) * costab5;
    t13 = _in[13] + _in[18];t29 = (_in[13] - _in[18]) * costab27;

    t47 = t28 + t29;
    t65 = (t28 - t29) * costab10;
    t39 = t12 + t13;
    t56 = (t12 - t13) * costab10;

    t14 = _in[5] + _in[26];t30 = (_in[5] - _in[26]) * costab11;
    t15 = _in[10] + _in[21];t31 = (_in[10] - _in[21]) * costab21;

    t48 = t30 + t31;
    t66 = (t30 - t31) * costab22;
    t40 = t14 + t15;
    t57 = (t14 - t15) * costab22;

    t69 = t33 + t34;t89 = (t33 - t34) * costab4;
    t70 = t35 + t36;t90 = (t35 - t36) * costab28;
    t71 = t37 + t38;t91 = (t37 - t38) * costab12;
    t72 = t39 + t40;t92 = (t39 - t40) * costab20;
    t73 = t41 + t42;t94 = (t41 - t42) * costab4;
    t74 = t43 + t44;t95 = (t43 - t44) * costab28;
    t75 = t45 + t46;t96 = (t45 - t46) * costab12;
    t76 = t47 + t48;t97 = (t47 - t48) * costab20;

    t78 = t50 + t51;t100 = (t50 - t51) * costab4;
    t79 = t52 + t53;t101 = (t52 - t53) * costab28;
    t80 = t54 + t55;t102 = (t54 - t55) * costab12;
    t81 = t56 + t57;t103 = (t56 - t57) * costab20;

    t83 = t59 + t60;t106 = (t59 - t60) * costab4;
    t84 = t61 + t62;t107 = (t61 - t62) * costab28;
    t85 = t63 + t64;t108 = (t63 - t64) * costab12;
    t86 = t65 + t66;t109 = (t65 - t66) * costab20;

    t113 = t69 + t70;
    t114 = t71 + t72;

    /*  0 */hi[15][slot] = t113 + t114;
    /* 16 */lo[0][slot] = (t113 - t114) * costab16;

    t115 = t73 + t74;
    t116 = t75 + t76;

    t32 = t115 + t116;

    /*  1 */hi[14][slot] = t32;

    t118 = t78 + t79;
    t119 = t80 + t81;

    t58 = t118 + t119;

    /*  2 */hi[13][slot] = t58;

    t121 = t83 + t84;
    t122 = t85 + t86;

    t67 = t121 + t122;

    t49 = t67 * 2 - t32;

    /*  3 */hi[12][slot] = t49;

    t125 = t89 + t90;
    t126 = t91 + t92;

    t93 = t125 + t126;

    /*  4 */hi[11][slot] = t93;

    t128 = t94 + t95;
    t129 = t96 + t97;

    t98 = t128 + t129;

    t68 = t98 * 2 - t49;

    /*  5 */hi[10][slot] = t68;

    t132 = t100 + t101;
    t133 = t102 + t103;

    t104 = t132 + t133;

    t82 = t104 * 2 - t58;

    /*  6 */hi[9][slot] = t82;

    t136 = t106 + t107;
    t137 = t108 + t109;

    t110 = t136 + t137;

    t87 = t110 * 2 - t67;

    t77 = t87 * 2 - t68;

    /*  7 */hi[8][slot] = t77;

    t141 = (t69 - t70) * costab8;
    t142 = (t71 - t72) * costab24;
    t143 = t141 + t142;

    /*  8 */hi[7][slot] = t143;
    /* 24 */lo[8][slot] = (t141 - t142) * costab16 * 2 - t143;

    t144 = (t73 - t74) * costab8;
    t145 = (t75 - t76) * costab24;
    t146 = t144 + t145;

    t88 = t146 * 2 - t77;

    /*  9 */hi[6][slot] = t88;

    t148 = (t78 - t79) * costab8;
    t149 = (t80 - t81) * costab24;
    t150 = t148 + t149;

    t105 = t150 * 2 - t82;

    /* 10 */hi[5][slot] = t105;

    t152 = (t83 - t84) * costab8;
    t153 = (t85 - t86) * costab24;
    t154 = t152 + t153;

    t111 = t154 * 2 - t87;

    t99 = t111 * 2 - t88;

    /* 11 */hi[4][slot] = t99;

    t157 = (t89 - t90) * costab8;
    t158 = (t91 - t92) * costab24;
    t159 = t157 + t158;

    t127 = t159 * 2 - t93;

    /* 12 */hi[3][slot] = t127;

    t160 = (t125 - t126) * costab16 * 2 - t127;

    /* 20 */lo[4][slot] = t160;
    /* 28 */lo[12][slot] = ((t157 - t158) * costab16 * 2 - t159) * 2 - t160;

    t161 = (t94 - t95) * costab8;
    t162 = (t96 - t97) * costab24;
    t163 = t161 + t162;

    t130 = t163 * 2 - t98;

    t112 = t130 * 2 - t99;

    /* 13 */hi[2][slot] = t112;

    t164 = (t128 - t129) * costab16 * 2 - t130;

    t166 = (t100 - t101) * costab8;
    t167 = (t102 - t103) * costab24;
    t168 = t166 + t167;

    t134 = t168 * 2 - t104;

    t120 = t134 * 2 - t105;

    /* 14 */hi[1][slot] = t120;

    t135 = (t118 - t119) * costab16 * 2 - t120;

    /* 18 */lo[2][slot] = t135;

    t169 = (t132 - t133) * costab16 * 2 - t134;

    t151 = t169 * 2 - t135;

    /* 22 */lo[6][slot] = t151;

    t170 = ((t148 - t149) * costab16 * 2 - t150) * 2 - t151;

    /* 26 */lo[10][slot] = t170;
    /* 30 */lo[14][slot] = (((t166 - t167) * costab16 * 2 - t168) * 2 - t169) * 2 - t170;

    t171 = (t106 - t107) * costab8;
    t172 = (t108 - t109) * costab24;
    t173 = t171 + t172;

    t138 = t173 * 2 - t110;

    t123 = t138 * 2 - t111;

    t139 = (t121 - t122) * costab16 * 2 - t123;

    t117 = t123 * 2 - t112;

    /* 15 */hi[0][slot] = t117;

    t124 = (t115 - t116) * costab16 * 2 - t117;

    /* 17 */lo[1][slot] = t124;

    t131 = t139 * 2 - t124;

    /* 19 */lo[3][slot] = t131;

    t140 = t164 * 2 - t131;

    /* 21 */lo[5][slot] = t140;

    t174 = (t136 - t137) * costab16 * 2 - t138;

    t155 = t174 * 2 - t139;

    t147 = t155 * 2 - t140;

    /* 23 */lo[7][slot] = t147;

    t156 = ((t144 - t145) * costab16 * 2 - t146) * 2 - t147;

    /* 25 */lo[9][slot] = t156;

    t175 = ((t152 - t153) * costab16 * 2 - t154) * 2 - t155;

    t165 = t175 * 2 - t156;

    /* 27 */lo[11][slot] = t165;

    t176 = (((t161 - t162) * costab16 * 2 - t163) * 2 - t164) * 2 - t165;

    /* 29 */lo[13][slot] = t176;
    /* 31 */lo[15][slot] = ((((t171 - t172) * costab16 * 2 - t173) * 2 - t174) * 2 - t175) * 2 - t176;

    /*
     * Totals:
     *  80 multiplies
     *  80 additions
     * 119 subtractions
     *  49 shifts (not counting SSO)
     */
};

var D /* [17][32] */ = [
/*
 * These are the coefficients for the subband synthesis window. This is a
 * reordered version of Table B.3 from ISO/IEC 11172-3.
 */
[0.000000000, /*  0 */
-0.000442505, 0.003250122, -0.007003784, 0.031082153, -0.078628540, 0.100311279, -0.572036743, 1.144989014, 0.572036743, 0.100311279, 0.078628540, 0.031082153, 0.007003784, 0.003250122, 0.000442505, 0.000000000, -0.000442505, 0.003250122, -0.007003784, 0.031082153, -0.078628540, 0.100311279, -0.572036743, 1.144989014, 0.572036743, 0.100311279, 0.078628540, 0.031082153, 0.007003784, 0.003250122, 0.000442505], [-0.000015259, /*  1 */
-0.000473022, 0.003326416, -0.007919312, 0.030517578, -0.084182739, 0.090927124, -0.600219727, 1.144287109, 0.543823242, 0.108856201, 0.073059082, 0.031478882, 0.006118774, 0.003173828, 0.000396729, -0.000015259, -0.000473022, 0.003326416, -0.007919312, 0.030517578, -0.084182739, 0.090927124, -0.600219727, 1.144287109, 0.543823242, 0.108856201, 0.073059082, 0.031478882, 0.006118774, 0.003173828, 0.000396729], [-0.000015259, /*  2 */
-0.000534058, 0.003387451, -0.008865356, 0.029785156, -0.089706421, 0.080688477, -0.628295898, 1.142211914, 0.515609741, 0.116577148, 0.067520142, 0.031738281, 0.005294800, 0.003082275, 0.000366211, -0.000015259, -0.000534058, 0.003387451, -0.008865356, 0.029785156, -0.089706421, 0.080688477, -0.628295898, 1.142211914, 0.515609741, 0.116577148, 0.067520142, 0.031738281, 0.005294800, 0.003082275, 0.000366211], [-0.000015259, /*  3 */
-0.000579834, 0.003433228, -0.009841919, 0.028884888, -0.095169067, 0.069595337, -0.656219482, 1.138763428, 0.487472534, 0.123474121, 0.061996460, 0.031845093, 0.004486084, 0.002990723, 0.000320435, -0.000015259, -0.000579834, 0.003433228, -0.009841919, 0.028884888, -0.095169067, 0.069595337, -0.656219482, 1.138763428, 0.487472534, 0.123474121, 0.061996460, 0.031845093, 0.004486084, 0.002990723, 0.000320435], [-0.000015259, /*  4 */
-0.000625610, 0.003463745, -0.010848999, 0.027801514, -0.100540161, 0.057617187, -0.683914185, 1.133926392, 0.459472656, 0.129577637, 0.056533813, 0.031814575, 0.003723145, 0.002899170, 0.000289917, -0.000015259, -0.000625610, 0.003463745, -0.010848999, 0.027801514, -0.100540161, 0.057617187, -0.683914185, 1.133926392, 0.459472656, 0.129577637, 0.056533813, 0.031814575, 0.003723145, 0.002899170, 0.000289917], [-0.000015259, /*  5 */
-0.000686646, 0.003479004, -0.011886597, 0.026535034, -0.105819702, 0.044784546, -0.711318970, 1.127746582, 0.431655884, 0.134887695, 0.051132202, 0.031661987, 0.003005981, 0.002792358, 0.000259399, -0.000015259, -0.000686646, 0.003479004, -0.011886597, 0.026535034, -0.105819702, 0.044784546, -0.711318970, 1.127746582, 0.431655884, 0.134887695, 0.051132202, 0.031661987, 0.003005981, 0.002792358, 0.000259399], [-0.000015259, /*  6 */
-0.000747681, 0.003479004, -0.012939453, 0.025085449, -0.110946655, 0.031082153, -0.738372803, 1.120223999, 0.404083252, 0.139450073, 0.045837402, 0.031387329, 0.002334595, 0.002685547, 0.000244141, -0.000015259, -0.000747681, 0.003479004, -0.012939453, 0.025085449, -0.110946655, 0.031082153, -0.738372803, 1.120223999, 0.404083252, 0.139450073, 0.045837402, 0.031387329, 0.002334595, 0.002685547, 0.000244141], [-0.000030518, /*  7 */
-0.000808716, 0.003463745, -0.014022827, 0.023422241, -0.115921021, 0.016510010, -0.765029907, 1.111373901, 0.376800537, 0.143264771, 0.040634155, 0.031005859, 0.001693726, 0.002578735, 0.000213623, -0.000030518, -0.000808716, 0.003463745, -0.014022827, 0.023422241, -0.115921021, 0.016510010, -0.765029907, 1.111373901, 0.376800537, 0.143264771, 0.040634155, 0.031005859, 0.001693726, 0.002578735, 0.000213623], [-0.000030518, /*  8 */
-0.000885010, 0.003417969, -0.015121460, 0.021575928, -0.120697021, 0.001068115, -0.791213989, 1.101211548, 0.349868774, 0.146362305, 0.035552979, 0.030532837, 0.001098633, 0.002456665, 0.000198364, -0.000030518, -0.000885010, 0.003417969, -0.015121460, 0.021575928, -0.120697021, 0.001068115, -0.791213989, 1.101211548, 0.349868774, 0.146362305, 0.035552979, 0.030532837, 0.001098633, 0.002456665, 0.000198364], [-0.000030518, /*  9 */
-0.000961304, 0.003372192, -0.016235352, 0.019531250, -0.125259399, -0.015228271, -0.816864014, 1.089782715, 0.323318481, 0.148773193, 0.030609131, 0.029937744, 0.000549316, 0.002349854, 0.000167847, -0.000030518, -0.000961304, 0.003372192, -0.016235352, 0.019531250, -0.125259399, -0.015228271, -0.816864014, 1.089782715, 0.323318481, 0.148773193, 0.030609131, 0.029937744, 0.000549316, 0.002349854, 0.000167847], [-0.000030518, /* 10 */
-0.001037598, 0.003280640, -0.017349243, 0.017257690, -0.129562378, -0.032379150, -0.841949463, 1.077117920, 0.297210693, 0.150497437, 0.025817871, 0.029281616, 0.000030518, 0.002243042, 0.000152588, -0.000030518, -0.001037598, 0.003280640, -0.017349243, 0.017257690, -0.129562378, -0.032379150, -0.841949463, 1.077117920, 0.297210693, 0.150497437, 0.025817871, 0.029281616, 0.000030518, 0.002243042, 0.000152588], [-0.000045776, /* 11 */
-0.001113892, 0.003173828, -0.018463135, 0.014801025, -0.133590698, -0.050354004, -0.866363525, 1.063217163, 0.271591187, 0.151596069, 0.021179199, 0.028533936, -0.000442505, 0.002120972, 0.000137329, -0.000045776, -0.001113892, 0.003173828, -0.018463135, 0.014801025, -0.133590698, -0.050354004, -0.866363525, 1.063217163, 0.271591187, 0.151596069, 0.021179199, 0.028533936, -0.000442505, 0.002120972, 0.000137329], [-0.000045776, /* 12 */
-0.001205444, 0.003051758, -0.019577026, 0.012115479, -0.137298584, -0.069168091, -0.890090942, 1.048156738, 0.246505737, 0.152069092, 0.016708374, 0.027725220, -0.000869751, 0.002014160, 0.000122070, -0.000045776, -0.001205444, 0.003051758, -0.019577026, 0.012115479, -0.137298584, -0.069168091, -0.890090942, 1.048156738, 0.246505737, 0.152069092, 0.016708374, 0.027725220, -0.000869751, 0.002014160, 0.000122070], [-0.000061035, /* 13 */
-0.001296997, 0.002883911, -0.020690918, 0.009231567, -0.140670776, -0.088775635, -0.913055420, 1.031936646, 0.221984863, 0.151962280, 0.012420654, 0.026840210, -0.001266479, 0.001907349, 0.000106812, -0.000061035, -0.001296997, 0.002883911, -0.020690918, 0.009231567, -0.140670776, -0.088775635, -0.913055420, 1.031936646, 0.221984863, 0.151962280, 0.012420654, 0.026840210, -0.001266479, 0.001907349, 0.000106812], [-0.000061035, /* 14 */
-0.001388550, 0.002700806, -0.021789551, 0.006134033, -0.143676758, -0.109161377, -0.935195923, 1.014617920, 0.198059082, 0.151306152, 0.008316040, 0.025909424, -0.001617432, 0.001785278, 0.000106812, -0.000061035, -0.001388550, 0.002700806, -0.021789551, 0.006134033, -0.143676758, -0.109161377, -0.935195923, 1.014617920, 0.198059082, 0.151306152, 0.008316040, 0.025909424, -0.001617432, 0.001785278, 0.000106812], [-0.000076294, /* 15 */
-0.001480103, 0.002487183, -0.022857666, 0.002822876, -0.146255493, -0.130310059, -0.956481934, 0.996246338, 0.174789429, 0.150115967, 0.004394531, 0.024932861, -0.001937866, 0.001693726, 0.000091553, -0.000076294, -0.001480103, 0.002487183, -0.022857666, 0.002822876, -0.146255493, -0.130310059, -0.956481934, 0.996246338, 0.174789429, 0.150115967, 0.004394531, 0.024932861, -0.001937866, 0.001693726, 0.000091553], [-0.000076294, /* 16 */
-0.001586914, 0.002227783, -0.023910522, -0.000686646, -0.148422241, -0.152206421, -0.976852417, 0.976852417, 0.152206421, 0.148422241, 0.000686646, 0.023910522, -0.002227783, 0.001586914, 0.000076294, -0.000076294, -0.001586914, 0.002227783, -0.023910522, -0.000686646, -0.148422241, -0.152206421, -0.976852417, 0.976852417, 0.152206421, 0.148422241, 0.000686646, 0.023910522, -0.002227783, 0.001586914, 0.000076294]];

/*
 * NAME:    synth.full()
 * DESCRIPTION: perform full frequency PCM synthesis
 */
Synth.prototype.full = function (frame, nch, ns) {
    var Dptr, hi, lo, ptr, _fx, _fe, _fo;

    for (var ch = 0; ch < nch; ++ch) {
        var sbsample /* [36][32] */ = frame.sbsample[ch];
        var filter = this.filter[ch] /* [2][2][16][8] */;
        var phase = this.phase;
        var pcm = this.pcm.samples[ch];
        var pcm1Ptr = 0;
        var pcm2Ptr = 0;

        for (var s = 0; s < ns; ++s) {
            Synth.dct32(sbsample[s], phase >> 1, filter[0][phase & 1], filter[1][phase & 1]);

            var pe = phase & ~1;
            var po = phase - 1 & 0xf | 1;

            /* calculate 32 samples */
            var fe = filter[0][phase & 1];
            var fx = filter[0][~phase & 1];
            var fo = filter[1][~phase & 1];

            var fePtr = 0;
            var fxPtr = 0;
            var foPtr = 0;

            Dptr = 0;

            ptr = D[Dptr];
            _fx = fx[fxPtr];
            _fe = fe[fePtr];

            lo = _fx[0] * ptr[po + 0];
            lo += _fx[1] * ptr[po + 14];
            lo += _fx[2] * ptr[po + 12];
            lo += _fx[3] * ptr[po + 10];
            lo += _fx[4] * ptr[po + 8];
            lo += _fx[5] * ptr[po + 6];
            lo += _fx[6] * ptr[po + 4];
            lo += _fx[7] * ptr[po + 2];
            lo = -lo;

            lo += _fe[0] * ptr[pe + 0];
            lo += _fe[1] * ptr[pe + 14];
            lo += _fe[2] * ptr[pe + 12];
            lo += _fe[3] * ptr[pe + 10];
            lo += _fe[4] * ptr[pe + 8];
            lo += _fe[5] * ptr[pe + 6];
            lo += _fe[6] * ptr[pe + 4];
            lo += _fe[7] * ptr[pe + 2];

            pcm[pcm1Ptr++] = lo;
            pcm2Ptr = pcm1Ptr + 30;

            for (var sb = 1; sb < 16; ++sb) {
                ++fePtr;
                ++Dptr;

                /* D[32 - sb][i] == -D[sb][31 - i] */

                ptr = D[Dptr];
                _fo = fo[foPtr];
                _fe = fe[fePtr];

                lo = _fo[0] * ptr[po + 0];
                lo += _fo[1] * ptr[po + 14];
                lo += _fo[2] * ptr[po + 12];
                lo += _fo[3] * ptr[po + 10];
                lo += _fo[4] * ptr[po + 8];
                lo += _fo[5] * ptr[po + 6];
                lo += _fo[6] * ptr[po + 4];
                lo += _fo[7] * ptr[po + 2];
                lo = -lo;

                lo += _fe[7] * ptr[pe + 2];
                lo += _fe[6] * ptr[pe + 4];
                lo += _fe[5] * ptr[pe + 6];
                lo += _fe[4] * ptr[pe + 8];
                lo += _fe[3] * ptr[pe + 10];
                lo += _fe[2] * ptr[pe + 12];
                lo += _fe[1] * ptr[pe + 14];
                lo += _fe[0] * ptr[pe + 0];

                pcm[pcm1Ptr++] = lo;

                lo = _fe[0] * ptr[-pe + 31 - 16];
                lo += _fe[1] * ptr[-pe + 31 - 14];
                lo += _fe[2] * ptr[-pe + 31 - 12];
                lo += _fe[3] * ptr[-pe + 31 - 10];
                lo += _fe[4] * ptr[-pe + 31 - 8];
                lo += _fe[5] * ptr[-pe + 31 - 6];
                lo += _fe[6] * ptr[-pe + 31 - 4];
                lo += _fe[7] * ptr[-pe + 31 - 2];

                lo += _fo[7] * ptr[-po + 31 - 2];
                lo += _fo[6] * ptr[-po + 31 - 4];
                lo += _fo[5] * ptr[-po + 31 - 6];
                lo += _fo[4] * ptr[-po + 31 - 8];
                lo += _fo[3] * ptr[-po + 31 - 10];
                lo += _fo[2] * ptr[-po + 31 - 12];
                lo += _fo[1] * ptr[-po + 31 - 14];
                lo += _fo[0] * ptr[-po + 31 - 16];

                pcm[pcm2Ptr--] = lo;
                ++foPtr;
            }

            ++Dptr;

            ptr = D[Dptr];
            _fo = fo[foPtr];

            lo = _fo[0] * ptr[po + 0];
            lo += _fo[1] * ptr[po + 14];
            lo += _fo[2] * ptr[po + 12];
            lo += _fo[3] * ptr[po + 10];
            lo += _fo[4] * ptr[po + 8];
            lo += _fo[5] * ptr[po + 6];
            lo += _fo[6] * ptr[po + 4];
            lo += _fo[7] * ptr[po + 2];

            pcm[pcm1Ptr] = -lo;
            pcm1Ptr += 16;
            phase = (phase + 1) % 16;
        }
    }
};

/*
 * NAME:    synth.half()
 * DESCRIPTION: perform half frequency PCM synthesis
 */

// Yeah, I don't think so

//static
//void synth_half(struct mad_synth *synth, struct mad_frame const *frame,
//      unsigned int nch, unsigned int ns)
//{
//  unsigned int phase, ch, s, sb, pe, po;
//  mad_fixed_t *pcm1, *pcm2, filter[2][2][16][8];
//  mad_fixed_t const (*sbsample)[36][32];
//  register mad_fixed_t (*fe)[8], (*fx)[8], (*fo)[8];
//  register mad_fixed_t const (*Dptr)[32], *ptr;
//  register mad_fixed64hi_t hi;
//  register mad_fixed64lo_t lo;
//
//  for (ch = 0; ch < nch; ++ch) {
//    sbsample = &frame.sbsample[ch];
//    filter   = &synth.filter[ch];
//    phase    = synth.phase;
//    pcm1     = synth.pcm.samples[ch];
//
//    for (s = 0; s < ns; ++s) {
//      dct32((*sbsample)[s], phase >> 1,
//      filter[0][phase & 1], filter[1][phase & 1]);
//
//      pe = phase & ~1;
//      po = ((phase - 1) & 0xf) | 1;
//
//      /* calculate 16 samples */
//
//      fe = &filter[0][ phase & 1][0];
//      fx = &filter[0][~phase & 1][0];
//      fo = &filter[1][~phase & 1][0];
//
//      Dptr = &D[0];
//
//      ptr = *Dptr + po;
//      ML0(hi, lo, (*fx)[0], ptr[ 0]);
//      MLA(hi, lo, (*fx)[1], ptr[14]);
//      MLA(hi, lo, (*fx)[2], ptr[12]);
//      MLA(hi, lo, (*fx)[3], ptr[10]);
//      MLA(hi, lo, (*fx)[4], ptr[ 8]);
//      MLA(hi, lo, (*fx)[5], ptr[ 6]);
//      MLA(hi, lo, (*fx)[6], ptr[ 4]);
//      MLA(hi, lo, (*fx)[7], ptr[ 2]);
//      MLN(hi, lo);
//
//      ptr = *Dptr + pe;
//      MLA(hi, lo, (*fe)[0], ptr[ 0]);
//      MLA(hi, lo, (*fe)[1], ptr[14]);
//      MLA(hi, lo, (*fe)[2], ptr[12]);
//      MLA(hi, lo, (*fe)[3], ptr[10]);
//      MLA(hi, lo, (*fe)[4], ptr[ 8]);
//      MLA(hi, lo, (*fe)[5], ptr[ 6]);
//      MLA(hi, lo, (*fe)[6], ptr[ 4]);
//      MLA(hi, lo, (*fe)[7], ptr[ 2]);
//
//      *pcm1++ = MLZ(hi, lo);
//
//      pcm2 = pcm1 + 14;
//
//      for (sb = 1; sb < 16; ++sb) {
//  ++fe;
//  ++Dptr;
//
//  /* D[32 - sb][i] == -D[sb][31 - i] */
//
//  if (!(sb & 1)) {
//    ptr = *Dptr + po;
//    ML0(hi, lo, (*fo)[0], ptr[ 0]);
//    MLA(hi, lo, (*fo)[1], ptr[14]);
//    MLA(hi, lo, (*fo)[2], ptr[12]);
//    MLA(hi, lo, (*fo)[3], ptr[10]);
//    MLA(hi, lo, (*fo)[4], ptr[ 8]);
//    MLA(hi, lo, (*fo)[5], ptr[ 6]);
//    MLA(hi, lo, (*fo)[6], ptr[ 4]);
//    MLA(hi, lo, (*fo)[7], ptr[ 2]);
//    MLN(hi, lo);
//
//    ptr = *Dptr + pe;
//    MLA(hi, lo, (*fe)[7], ptr[ 2]);
//    MLA(hi, lo, (*fe)[6], ptr[ 4]);
//    MLA(hi, lo, (*fe)[5], ptr[ 6]);
//    MLA(hi, lo, (*fe)[4], ptr[ 8]);
//    MLA(hi, lo, (*fe)[3], ptr[10]);
//    MLA(hi, lo, (*fe)[2], ptr[12]);
//    MLA(hi, lo, (*fe)[1], ptr[14]);
//    MLA(hi, lo, (*fe)[0], ptr[ 0]);
//
//    *pcm1++ = MLZ(hi, lo);
//
//    ptr = *Dptr - po;
//    ML0(hi, lo, (*fo)[7], ptr[31 -  2]);
//    MLA(hi, lo, (*fo)[6], ptr[31 -  4]);
//    MLA(hi, lo, (*fo)[5], ptr[31 -  6]);
//    MLA(hi, lo, (*fo)[4], ptr[31 -  8]);
//    MLA(hi, lo, (*fo)[3], ptr[31 - 10]);
//    MLA(hi, lo, (*fo)[2], ptr[31 - 12]);
//    MLA(hi, lo, (*fo)[1], ptr[31 - 14]);
//    MLA(hi, lo, (*fo)[0], ptr[31 - 16]);
//
//    ptr = *Dptr - pe;
//    MLA(hi, lo, (*fe)[0], ptr[31 - 16]);
//    MLA(hi, lo, (*fe)[1], ptr[31 - 14]);
//    MLA(hi, lo, (*fe)[2], ptr[31 - 12]);
//    MLA(hi, lo, (*fe)[3], ptr[31 - 10]);
//    MLA(hi, lo, (*fe)[4], ptr[31 -  8]);
//    MLA(hi, lo, (*fe)[5], ptr[31 -  6]);
//    MLA(hi, lo, (*fe)[6], ptr[31 -  4]);
//    MLA(hi, lo, (*fe)[7], ptr[31 -  2]);
//
//    *pcm2-- = MLZ(hi, lo);
//  }
//
//  ++fo;
//      }
//
//      ++Dptr;
//
//      ptr = *Dptr + po;
//      ML0(hi, lo, (*fo)[0], ptr[ 0]);
//      MLA(hi, lo, (*fo)[1], ptr[14]);
//      MLA(hi, lo, (*fo)[2], ptr[12]);
//      MLA(hi, lo, (*fo)[3], ptr[10]);
//      MLA(hi, lo, (*fo)[4], ptr[ 8]);
//      MLA(hi, lo, (*fo)[5], ptr[ 6]);
//      MLA(hi, lo, (*fo)[6], ptr[ 4]);
//      MLA(hi, lo, (*fo)[7], ptr[ 2]);
//
//      *pcm1 = -MLZ(hi, lo);
//      pcm1 += 8;
//
//      phase = (phase + 1) % 16;
//    }
//  }
//}

/*
 * NAME:    synth.frame()
 * DESCRIPTION: perform PCM synthesis of frame subband samples
 */
Synth.prototype.frame = function (frame) {
    var nch = frame.header.nchannels();
    var ns = frame.header.nbsamples();

    this.pcm.samplerate = frame.header.samplerate;
    this.pcm.channels = nch;
    this.pcm.length = 32 * ns;

    // console.log("ns: " + ns);

    /*
     if (frame.options & Mad.Option.HALFSAMPLERATE) {
     this.pcm.samplerate /= 2;
     this.pcm.length     /= 2;
       throw new Error("HALFSAMPLERATE is not supported. What do you think? As if I have the time for this");
     }
     */

    this.full(frame, nch, ns);
    this.phase = (this.phase + ns) % 16;
};

/* harmony default export */ __webpack_exports__["a"] = (Synth);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bit__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__global__ = __webpack_require__(0);



var Stream = function (stream) {
    this.stream = stream; /* actual buffer (js doesn't have pointers!) */
    this.buffer = 0; /* input bitstream buffer */
    this.bufend = stream.length; /* input bitstream buffer */
    this.skiplen = 0; /* bytes to skip before next frame */

    this.sync = 0; /* stream sync found */
    this.freerate = 0; /* free bitrate (fixed) */

    this.this_frame = 0; /* start of current frame */
    this.next_frame = 0; /* start of next frame */

    this.ptr = new __WEBPACK_IMPORTED_MODULE_0__bit__["a" /* default */](this.stream, this.buffer); /* current processing bit pointer */

    this.anc_ptr = /* MadBit */null; /* ancillary bits pointer */
    this.anc_bitlen = 0; /* number of ancillary bits */

    this.main_data = /* string */__WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].mul("\0", __WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].BUFFER_MDLEN); /* Layer III main_data() */
    this.md_len = 0; /* bytes in main_data */

    var options = 0; /* decoding options (see below) */
    var error = __WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].Error.NONE; /* error code (see above) */
};

Stream.fromFile = function (file, callback) {
    var reader = new FileReader();
    reader.onloadend = function (evt) {
        callback(new Stream(evt.target.result));
    };
    reader.readAsBinaryString(file);
};

Stream.prototype.readShort = function (bBigEndian) {
    return this.stream.readU16(bBigEndian);
};

Stream.prototype.readSShort = function (bBigEndian) {
    return this.stream.readI16(bBigEndian);
};

Stream.prototype.getU8 = function (index) {
    return this.stream.getU8(index);
};

Stream.prototype.readU8 = function () {
    return this.stream.readU8(index);
};

Stream.prototype.readChars = function (length) {
    return this.stream.read(length);
};

Stream.prototype.peekChars = function (length) {
    return this.stream.peek(length);
};

/*
 * NAME:        stream->sync()
 * DESCRIPTION: locate the next stream sync word
 */
Stream.prototype.doSync = function () {
    var ptr = this.ptr.nextbyte();
    var end = this.bufend;

    while (ptr < end - 1 && !(this.getU8(ptr) == 0xff && (this.getU8(ptr + 1) & 0xe0) == 0xe0)) {
        ++ptr;
    }

    if (end - ptr < __WEBPACK_IMPORTED_MODULE_1__global__["a" /* default */].BUFFER_GUARD) {
        return -1;
    }

    this.ptr = new __WEBPACK_IMPORTED_MODULE_0__bit__["a" /* default */](this.stream, ptr);

    return 0;
};

/* harmony default export */ __webpack_exports__["a"] = (Stream);

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bytestream__ = __webpack_require__(5);


var BufferStream = function (arrayBuffer) {
    this.state = {};
    this.state['arrayBuffer'] = arrayBuffer;
    this.state['byteBuffer'] = new Uint8Array(arrayBuffer);
    this.state['amountRead'] = arrayBuffer.byteLength;
};

BufferStream.prototype = new __WEBPACK_IMPORTED_MODULE_0__bytestream__["a" /* default */]();

BufferStream.prototype.absoluteAvailable = function (n) {
    if (n > this.state['amountRead']) {
        throw new Error("buffer underflow with absoluteAvailable!");
    } else {
        return true;
    }
};

BufferStream.prototype.seek = function (n) {
    this.state['offset'] += n;
};

BufferStream.prototype.read = function (n) {
    var result = this.peek(n);

    this.seek(n);

    return result;
};

BufferStream.prototype.peek = function (n) {
    if (this.available(n)) {
        var offset = this.state['offset'];

        var result = this.get(offset, n);

        return result;
    } else {
        throw new Error("buffer underflow with peek!");
    }
};

BufferStream.prototype.get = function (offset, length) {
    if (this.absoluteAvailable(offset + length)) {
        var tmpbuffer = "";
        for (var i = offset; i < offset + length; i += 1) {
            tmpbuffer = tmpbuffer + String.fromCharCode(this.state['byteBuffer'][i]);
        }
        return tmpbuffer;
    } else {
        throw new Error("buffer underflow with get!");
    }
};

__WEBPACK_IMPORTED_MODULE_0__bytestream__["a" /* default */].prototype.getU8 = function (offset, bigEndian) {
    if (this.state['byteBuffer']) {
        return this.state['byteBuffer'][offset];
    }

    return this.get(offset, 1).charCodeAt(0);
};

BufferStream.prototype.requestAbsolute = function (n, callback) {
    if (n < this.state['amountRead']) {
        callback();
    } else {
        this.state['callbacks'].push([n, callback]);
    }
};

BufferStream.prototype.request = function (n, callback) {
    this.requestAbsolute(this.state['offset'] + n, callback);
};

/* harmony default export */ __webpack_exports__["a"] = (BufferStream);

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bytestream__ = __webpack_require__(5);


var SubStream = function (stream, offset, length) {
    this.state = { 'offset': 0 };

    this.state['start'] = offset;

    this.parentStream = stream;

    this.length = length;
};

SubStream.prototype = new __WEBPACK_IMPORTED_MODULE_0__bytestream__["a" /* default */]();

SubStream.prototype.absoluteAvailable = function (n) {
    return this.parentStream.absoluteAvailable(this.state['start'] + n);
};

SubStream.prototype.seek = function (n) {
    this.state['offset'] += n;
};

SubStream.prototype.read = function (n) {
    var result = this.peek(n);

    this.seek(n);

    return result;
};

SubStream.prototype.peek = function (n) {
    return this.get(this.state['offset'], n);
};

SubStream.prototype.get = function (offset, length) {
    return this.parentStream.get(this.state['start'] + offset, length);
};

SubStream.prototype.slice = function (start, end) {
    return this.parentStream.get(this.state['start'] + start, end - start);
};

SubStream.prototype.requestAbsolute = function (n, callback) {
    this.parentStream.requestAbsolute(this.state['start'] + n);
};

SubStream.prototype.request = function (n, callback) {
    this.parentStream.requestAbsolute(this.state['start'] + this.state['offset'] + n);
};

/* harmony default export */ __webpack_exports__["a"] = (SubStream);

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_bitstream__ = __webpack_require__(1);
/**
 * MP3音频帧头信息模块
 * http://www.docin.com/p-1261649617.html
 * https://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header
 */



//比特率对应表(bit/s) MEPG1.0 LayerIII
var bitRateMap = {
    '1': 32000,
    '10': 40000,
    '11': 48000,
    '100': 56000,
    '101': 64000,
    '110': 80000,
    '111': 96000,
    '1000': 112000,
    '1001': 128000,
    '1010': 160000,
    '1011': 192000,
    '1100': 224000,
    '1101': 256000,
    '1110': 320000
    //采样率对应表(Hz) MEPG1.0 LayerIII
};var sampleRateMap = {
    '0': 44100,
    '1': 48000,
    '10': 32000
};

var HEADER_MASK = 0xffe0 >> 5; //同步头
var MPEG1 = 3;
var LAYER3 = 1;
var MAX_TAG_OFF = 10 * 1024; //查找帧头，最多查找10K

var hasParseVbr = false;

function Header(_bitStream) {
    this.init(_bitStream);
}

var _proto_ = Header.prototype;

/**
 * 初始化
 * @param  {object} arrayBuffer 二进制数组
 */
_proto_.init = function (_bitStream) {
    this.bitStream = _bitStream;
};
/**
 * 解析帧头信息
 * @return object 比特流
 */
_proto_.parseHeader = function () {
    var mask = 0;
    var beginPos = this.bitStream.getBytePos();
    do {
        mask = this.bitStream.getBits(11); //获取11位同步头
        if (mask != HEADER_MASK) {
            if (this.bitStream.isEnd()) {
                break;
            }
            this.bitStream.rewindBits(3);
            continue;
        }
        this.verID = this.bitStream.getBits(2); //MPEG版本
        this.layer = this.bitStream.getBits(2); //MPEG层数
        this.protectionBit = this.bitStream.getBits(1); //保护位
        if (!this.frameSync) {
            this.bitStream.rewindBytes(2);
            this.frameSync = this.bitStream.getBits(8).toString(16) + ',' + this.bitStream.getBits(8).toString(16);
            this.frameSync = this.frameSync.toUpperCase(); //同步头
        }
        this.bitrateIndex = this.bitStream.getBitsStr(4);
        this.bitRate = bitRateMap[this.bitrateIndex]; //比特率
        this.sampleRateIndex = this.bitStream.getBitsStr(2);
        this.sampleRate = sampleRateMap[this.sampleRateIndex]; //采样路索引
        this.paddingBit = this.bitStream.getBits(1); //填充位
        this.privateBit = this.bitStream.getBits(1); //私有位
        this.channelMode = this.bitStream.getBits(2); //声道模式
        this.channelModeExtension = this.bitStream.getBits(2); //声道扩展模式
        this.copyright = this.bitStream.getBits(1); //版权
        this.original = this.bitStream.getBits(1); //填充位
        this.emphasis = this.bitStream.getBits(2); //强调

        if (this.verID != MPEG1 || this.layer != LAYER3) {
            return false;
        }

        this.frameSize = bitRateMap[this.bitrateIndex] * 1152 / 8;
        this.frameSize /= sampleRateMap[this.sampleRateIndex];
        this.frameSize += this.paddingBit; //帧长度
        this.sideInfoSize = this.channelMode == 3 ? 17 : 32; //帧边信息长度
        this.duration = 1152 / sampleRateMap[this.sampleRateIndex]; //本帧时长

        //计算主数据长度
        this.mainDataSize = this.frameSize - 4 - this.sideInfoSize >> 0; //主数据长度
        if (this.protectionBit == 0) this.mainDataSize -= 2; //CRC
        break;
    } while (this.bitStream.getBytePos() - beginPos < MAX_TAG_OFF);

    if (this.bitStream.getBytePos() - beginPos >= MAX_TAG_OFF || this.bitStream.isEnd()) {
        return false;
    }

    this.endBytePos = this.bitStream.getBytePos();
    if (!hasParseVbr) {
        hasParseVbr = true;
        this.parseVbr();
        if (this.toc) {
            this.totalDuration = this.totalFrames * 1152 / sampleRateMap[this.sampleRateIndex]; //总时长
        }
    }
    return this.bitStream;
};
/**
 * 解析vbr信息
 */
_proto_.parseVbr = function () {
    var flags = 0;
    var tag = '';

    do {
        tag = String.fromCharCode(this.bitStream.getByte(), this.bitStream.getByte(), this.bitStream.getByte(), this.bitStream.getByte());
        if (tag == 'Xing' || tag == 'Info') {
            //Xing，Info头
            this.tocSize = 100; //vbr索引表长度
            flags = this.bitStream.getBits(32);
            if (flags & 1) {
                this.totalFrames = this.bitStream.getBits(32); //总帧数
            }
            if (flags & 2) {
                this.totalBytes = this.bitStream.getBits(32); //总长度
            }
            if (flags & 4) {
                this.toc = []; //vbr索引表
                for (var i = 0; i < this.tocSize; i++) {
                    this.toc[i] = this.bitStream.getByte();
                }
            }
            this.bitStream.setBytePos(this.endBytePos);
            return this.bitStream;
        } else if (tag == 'VBRI') {
            //VBRI头
            this.bitStream.skipBytes(6);
            this.totalBytes = this.bitStream.getBits(32);
            this.totalFrames = this.bitStream.getBits(32);
            this.tocSize = this.bitStream.getBits(16);
            this.bitStream.skipBytes(6);
            this.toc = [];
            for (var i = 0; i < tocSize; i++) {
                this.toc[i] = this.bitStream.getByte();
            }
            this.bitStream.setBytePos(this.endBytePos);
            return this.bitStream;
        } else {
            if (this.bitStream.isEnd()) {
                break;
            }
            this.bitStream.rewindBytes(3);
        }
    } while (tag != 'Xing' && tag != 'Info' && tag != 'VBRI' && this.bitStream.getBytePos() < MAX_TAG_OFF);

    this.bitStream.setBytePos(this.endBytePos);

    return false;
};

/* harmony default export */ __webpack_exports__["a"] = (Header);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_bitstream__ = __webpack_require__(1);
/**
 * MP3音频ID3标签信息模块
 * http://wiki.hydrogenaud.io/index.php?this.title=Ape_Tags_Flags
 */



var MAX_TAG_OFF = 10 * 1024; //查找标签头时，最多查找10K
var TEXT_ENCODING = []; //字符解码器
TEXT_ENCODING[0] = new TextDecoder('GBK');
TEXT_ENCODING[1] = new TextDecoder('UTF-16');
TEXT_ENCODING[2] = new TextDecoder('UTF-16BE');
TEXT_ENCODING[3] = new TextDecoder('UTF-8');

var gbkDecoder = TEXT_ENCODING[0];
var utf8Decoder = TEXT_ENCODING[3];

function Id3Tag(arrayBuffer) {
    this.bitStream = new __WEBPACK_IMPORTED_MODULE_0__common_bitstream__["a" /* default */](arrayBuffer);
}

var _proto_ = Id3Tag.prototype;

/**
 * 判断是否为ID3V1标签
 */
_proto_.checkId3V1 = function () {
    if (this.bitStream.getSize() < 128) {
        return false;
    }
    var tag = '';
    do {
        tag = String.fromCharCode(this.bitStream.getByte(), this.bitStream.getByte(), this.bitStream.getByte());
        if (this.bitStream.isEnd()) {
            break;
        }
        if (tag != 'TAG') {
            this.bitStream.rewindBytes(2);
        }
    } while (tag != 'TAG' && this.bitStream.getBytePos() < MAX_TAG_OFF);

    if (tag != 'TAG') {
        return false;
    }

    this.tagSize = 128; //标签长度
    return true;
};
/**
 * 判断是否为ID3V2标签
 */
_proto_.checkId3V2 = function () {
    var tag = '';
    do {
        tag = String.fromCharCode(this.bitStream.getByte(), this.bitStream.getByte(), this.bitStream.getByte());
        if (this.bitStream.isEnd()) {
            break;
        }
        if (tag != 'ID3') {
            this.bitStream.rewindBytes(2);
        }
    } while (tag != 'ID3' && this.bitStream.getBytePos() < MAX_TAG_OFF);

    if (tag != 'ID3') {
        return false;
    }
    return true;
};
/**
 * 判断是否为APE标签
 */
_proto_.checkApe = function () {
    var bytes = [];
    var tag = '';
    do {
        for (var i = 0; i < 8; i++) {
            bytes[i] = this.bitStream.getByte();
        }
        tag = String.fromCharCode.apply(null, bytes);
        if (this.bitStream.isEnd()) {
            break;
        }
        if (tag != 'APETAGEX') {
            this.bitStream.rewindBytes(7);
        }
    } while (tag != 'APETAGEX' && this.bitStream.getBytePos() < MAX_TAG_OFF);

    if (tag != 'APETAGEX') {
        return false;
    }
    return true;
};
/**
 * 解析ID3V1标签
 * @return number this.tagSize
 */
_proto_.parseId3V1 = function () {
    this.bitStream.reset();
    if (this.checkId3V1() == false) return 0;
    var i = 0;
    var bytes = new Uint8Array(30);
    if (this.bitStream.getSize() < 128) {
        return this.tagSize;
    }
    for (i = 0; i < 30; i++) {
        bytes[i] = this.bitStream.getByte();
    }
    this.title = gbkDecoder.decode(bytes); //标题

    for (i = 0; i < 30; i++) {
        bytes[i] = this.bitStream.getByte();
    }
    this.artist = gbkDecoder.decode(bytes); //艺术家

    for (i = 0; i < 30; i++) {
        bytes[i] = this.bitStream.getByte();
    }
    this.album = gbkDecoder.decode(bytes); //专辑

    for (i = 0; i < 4; i++) {
        bytes[i] = this.bitStream.getByte();
    }
    this.year = gbkDecoder.decode(bytes); //年份

    for (i = 0; i < 30; i++) {
        bytes[i] = this.bitStream.getByte();
    }
    this.comment = gbkDecoder.decode(bytes); //注释

    this.genre = this.bitStream.getByte(); //风格

    return this.tagSize;
};
/**
 * 解析ID3V2标签
 * @return number this.tagSize
 */
_proto_.parseId3V2 = function () {
    var self = this;
    this.bitStream.reset();
    if (this.checkId3V2() == false) return 0;
    this.bitStream.skipBytes(3);
    this.tagSize = ((this.bitStream.getByte() & 0x7F) << 21 | (this.bitStream.getByte() & 0x7F) << 14 | (this.bitStream.getByte() & 0x7F) << 7 | this.bitStream.getByte() & 0x7F) + 10;

    if (this.bitStream.getSize() < this.tagSize) {
        return this.tagSize;
    }

    while (this.bitStream.getBytePos() < this.tagSize && !this.bitStream.isEnd()) {
        _getItem();
    }

    function _getItem() {
        var key = String.fromCharCode(self.bitStream.getByte(), self.bitStream.getByte(), self.bitStream.getByte(), self.bitStream.getByte());
        var len = self.bitStream.getBits(32);
        var cont = '';
        var bytes = new Uint8Array(len);
        var strCode = 0; //字符编码索引

        if (!(key.charAt(0) <= 'z' && key.charAt(0) >= 'a') && !(key.charAt(0) <= 'Z' && key.charAt(0) >= 'A')) {
            //信息已读取完毕，后面为垃圾数据
            self.bitStream.setBytePos(self.tagSize);
            self.bitStream.setBitPos(0);
            return;
        }

        self.bitStream.skipBytes(2);
        strCode = self.bitStream.getByte();
        if (strCode > 3) {
            strCode = 3;
        }
        for (var i = 0; i < len - 1; i++) {
            bytes[i] = self.bitStream.getByte();
        }

        cont = TEXT_ENCODING[strCode].decode(bytes);

        // if(strCode>0){
        //  cont = cont.replace(/[^\u4e00-\u9fa5]/g, "");
        // }

        switch (key) {
            case 'TIT2':
                self.title = cont;
                break;
            case 'TPE1':
                self.artist = cont;
                break;
            case 'TALB':
                self.album = cont;
                break;
            case 'TYER':
                self.year = cont;
                break;
            case 'COMM':
                self.comment = cont;
                break;
            case 'TCON':
                self.genre = cont;
                break;
        }
    }
    return this.tagSize;
};
/**
 * 解析APE标签
 */
_proto_.parseApe = function () {
    var self = this;
    var itemSize = 0;
    var isApeHeader = 0;
    var isHeader = 0;
    this.bitStream.reset();
    if (this.checkApe() == false) return 0;
    this.bitStream.skipBytes(4);
    //低位在前
    this.tagSize = this.bitStream.getByte() | this.bitStream.getByte() << 8 | this.bitStream.getByte() << 16 | this.bitStream.getByte() << 24;
    itemSize = this.bitStream.getByte() | this.bitStream.getByte() << 8 | this.bitStream.getByte() << 16 | this.bitStream.getByte() << 24;
    this.bitStream.skipBits(2);
    if (this.bitStream.getBits1()) {
        //是ApeHeader
        this.tagSize += 32;
        isHeader = 1;
    }
    this.bitStream.skipBits(32 - 3);
    this.bitStream.skipBytes(8);
    if (this.bitStream.getBytePos() < this.tagSize || this.bitStream.getSize() < this.tagSize) {
        return this.tagSize;
    }
    if (!isHeader) {
        this.bitStream.rewindBytes(this.tagSize);
    }
    for (var i = 0; i < itemSize && this.bitStream.getBytePos() < this.tagSize && !this.bitStream.isEnd(); i++) {
        _getItem();
    }

    function _getItem() {
        var key = '';
        var cont = '';
        var byte = 0;
        //低位在前
        var len = self.bitStream.getByte() | self.bitStream.getByte() << 8 | self.bitStream.getByte() << 16 | self.bitStream.getByte() << 24;
        var bytes = new Uint8Array(len);
        self.bitStream.skipBytes(4);
        byte = self.bitStream.getByte();

        while (byte != 0 && self.bitStream.getBytePos() < self.tagSize) {
            key += String.fromCharCode(byte);
            byte = self.bitStream.getByte();
        }

        for (var i = 0; i < len; i++) {
            bytes[i] = self.bitStream.getByte();
        }
        cont = utf8Decoder.decode(bytes);
        switch (key) {
            case 'Title':
                self.title = cont;
                break;
            case 'Artist':
                self.artist = cont;
                break;
            case 'Album':
                self.album = cont;
                break;
            case 'Year':
                self.year = cont;
                break;
            case 'Comment':
                self.comment = cont;
                break;
            case 'Genre':
                self.genre = cont;
                break;
        }
    }
    return this.tagSize;
};

/* harmony default export */ __webpack_exports__["a"] = (Id3Tag);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__audio_index__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_range__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mp3info_mp3info__ = __webpack_require__(6);




var player = {
    /**
     * 初始化播放器
     * @param  {Object} opt 参数对象
     * @param  {String} opt.url 音频文件地址
     * @param  {Object} opt.audioInfo 音频信息对象
     * @param  {Audio} opt.audio audio文档对象
     */
    _init: function (opt) {
        this.url = opt.url; //mp3文件地址
        this.audioInfo = opt.audioInfo; //mp3文件信息
        this.audio = opt.audio;
        this.onbeforedecode = opt.onbeforedecode || function () {}; //解密函数
        this.fileSize = this.audioInfo.fileSize; //文件总大小
        this.blockSize = 1024 * 1024; //每次加载1M
        this.end = -1; //上个片段的末尾偏移量
        this.mimeCodec = 'audio/mpeg';
        this._generateBlob();
    },
    //生成blob对象
    _generateBlob: function () {
        var self = this;
        this.mediaSource = new MediaSource();
        this.audio.src = URL.createObjectURL(this.mediaSource);
        this.mediaSource.addEventListener('sourceopen', function () {
            if (self.mediaSource.readyState == 'open') {
                self.sourceBuffer = self.mediaSource.addSourceBuffer(self.mimeCodec);
                self.sourceBuffer.addEventListener('updateend', function () {
                    if (self.end >= self.fileSize - 1) {
                        self.mediaSource.endOfStream();
                    } else {
                        self._loadNext();
                    }
                });
                self._loadNext();
            }
        });
    },
    //下载下一个音频片段数据
    _loadNext: function () {
        var self = this;
        this.begin = this.end + 1;
        this.end = this.begin + this.blockSize;
        if (this.begin == 0) {
            this.end += this.audioInfo.audioDataOffset;
        }
        if (this.end >= this.fileSize) {
            this.end = this.fileSize - 1;
        }
        Object(__WEBPACK_IMPORTED_MODULE_1__common_range__["a" /* default */])(this.url, this.begin, this.end, {
            onsuccess: function (request) {
                var buffer = request.response;
                //数据解密
                self.onbeforedecode(buffer);
                self.sourceBuffer.appendBuffer(buffer);
            }
        });
    }
};

function Mp3Player(url, opt) {
    this.url = url;
    opt.audio = new window.Audio();
    this._init(opt);
    return new __WEBPACK_IMPORTED_MODULE_0__audio_index__["a" /* default */](opt);
}

Mp3Player.prototype._init = function (opt) {
    var onloadedmetadata = opt.onloadedmetadata;
    var self = this;
    //on使用mediasource方式，Aduio对象的loadedmetadata事件可能获取不到时长，因此使用AudioInfo去回调loadedmetadata
    opt.onloadedmetadata = null;
    __WEBPACK_IMPORTED_MODULE_2__mp3info_mp3info__["a" /* default */].init(this.url, {
        onloadedmetadata: onloadedmetadata,
        onbeforedecode: opt.onbeforedecode
    }).then(function (audioInfo) {
        player._init({
            url: self.url,
            audioInfo: audioInfo,
            audio: opt.audio,
            onbeforedecode: opt.onbeforedecode
        });
        if (!audioInfo) {
            opt.errorCb && errorCb('parse audioInfo failed');
        }
    }).catch(function (e) {
        console.log(e);
        opt.errorCb && errorCb('load audioInfo failed');
    });
};

/* harmony default export */ __webpack_exports__["a"] = (Mp3Player);

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function Audio(options) {
    var emptyFn = function () {};
    var onloadstart = null;
    var onloadedmetadata = null; //更新总时长回调
    var ontimeupdate = null; //更新时间回调
    var onupdateBar = null; // 更新进度条回调
    var onwaiting = null; //开始播放或播放过程中由于缓冲暂停时回调
    var onplaying = null; //开始播放或播放过程中缓冲完成回调
    var oncanplay = null; //当前位置可播放时回调
    var onseeking = null; //寻址中回调
    var onplay = null; //播放回调
    var onended = null; //播放完成
    var onpause = null; //暂停回调
    var onerror = null; //错误回调
    var audio = null; //音频对象
    var playBtn = null; //播放按钮
    var pauseBtn = null; //暂停按钮
    var forceSeek = false; //是否强制移动播放位置
    var currentTime = 0; //当前播放位置
    var seekTimeoutId = null; //寻址超时计时器
    var seekMaxTime = 30000; //最大寻址时长
    var seeking = false; //是否正在寻址中
    var canplay = false; //是否就绪
    var canUpdateTime = true; //是否可更新时长
    var allListener = [];
    var AudioObj = {
        init: function (options) {
            ontimeupdate = options.ontimeupdate || emptyFn;
            onseeking = options.onseeking || emptyFn;
            onwaiting = options.onwaiting || emptyFn;
            onplaying = options.onplaying || emptyFn;
            oncanplay = options.oncanplay || emptyFn;
            onloadstart = options.onloadstart || emptyFn;
            onplay = options.onplay || emptyFn;
            onended = options.onended || emptyFn;
            onpause = options.onpause || emptyFn;
            onupdateBar = options.onupdateBar || emptyFn;
            onloadedmetadata = options.onloadedmetadata || emptyFn;
            onerror = options.onerror || emptyFn;
            audio = options.audio;
            forceSeek = options.forceSeek || false;
            playBtn = options.playBtn;
            pauseBtn = options.pauseBtn;
            if (!audio) {
                return;
            }
            this.audio = audio;
            this._bindAudioEvent();
            this._bindClickEvent();
        },
        destroy: function () {
            this._removeAllEvent();
        },
        /**
         * [seek 设置播放位置,对外接口]
         * @param  {Number}  percent [百分比或时间]
         * @param  {Boolean} isTime  [是否是时间]
         * @param  {Boolean} ifStop  [是否停止]
         */
        seek: function (percent, isTime, ifStop) {
            if (!audio.duration) {
                if (!isTime) onupdateBar(percent);
                return;
            }
            var self = this;
            if (!ifStop) {
                this.play();
            } else {
                this.pause();
            }
            if (!isTime) {
                percent = percent > 100 ? 100 : percent;
                percent = percent < 0 ? 0 : percent;
                currentTime = percent * audio.duration / 100;
            } else {
                currentTime = percent;
                percent = currentTime / audio.duration * 100;
            }
            if (!this._ifSeekable(currentTime)) {
                console.log('can not seek');
                onupdateBar(percent);
                return;
            }
            ontimeupdate(currentTime);
            onupdateBar(percent);
            audio.currentTime = currentTime;
            if (forceSeek) {
                seeking = true;
                self.pause();
                seekTimeoutId = setTimeout(function () {
                    seeking = false;
                    self._setNearCurrentTime();
                    if (!ifStop) {
                        self.play(audio);
                    }
                }, seekMaxTime);
            }
        },
        /**
         * @todo [更新时间，对外接口]
         * @param    {[Number]}   percent [百分比或时长]
         * @param    {Boolean}  isTime  [是否是时长]
         */
        updateTime: function (percent, isTime) {
            if (isTime) {
                ontimeupdate(percent);
                return;
            } else if (!audio.duration || !audio.seekable.length) {
                return;
            } else {
                percent = percent > 100 ? 100 : percent;
                percent = percent < 0 ? 0 : percent;
                ontimeupdate(percent * audio.duration / 100);
            }
        },
        /**
         * [play 播放，对外接口]
         */
        play: function () {
            if (audio.paused) {
                audio.play();
            }
        },
        /**
         * [play 暂停播放，对外接口]
         */
        pause: function () {
            if (!audio.paused) {
                audio.pause();
            }
        },
        /**
         * [stopUpdateTime 停止内部更新时间，对外接口]
         */
        stopUpdateTime: function () {
            canUpdateTime = false;
        },
        /**
         * [startUpdateTime 开始内部更新时间，对外接口]
         */
        startUpdateTime: function () {
            canUpdateTime = true;
        },
        removeAllEvent: function () {
            this._removeAllEvent();
        },
        getSource: function () {
            return audio;
        },
        _bindAudioEvent: function () {
            var self = this;
            this._addEvent(audio, 'loadstart', function () {
                onloadstart();
                console.log('loadstart');
            });
            this._addEvent(audio, 'play', function () {
                onplay();
                console.log('play');
            });
            this._addEvent(audio, 'ended', function () {
                onended();
                console.log('ended');
            });
            this._addEvent(audio, 'pause', function () {
                onpause();
                console.log('puase');
            });
            this._addEvent(audio, 'waiting', function () {
                onwaiting();
                console.log('waiting');
            });
            this._addEvent(audio, 'playing', function () {
                if (this.readyState == 4) {
                    onplaying();
                }
                console.log('playing');
            });
            this._addEvent(audio, 'seeking', function () {
                onseeking();
                console.log('seeking');
            });
            if (forceSeek) {
                this._addEvent(audio, 'seeked', function () {
                    if (seeking) {
                        seeking = false;
                        clearTimeout(seekTimeoutId);
                        self.play();
                    }
                    console.log('seeked');
                });
            }
            this._addEvent(audio, 'loadedmetadata', function () {
                onloadedmetadata(audio.duration);
                //兼容ios首次必须交互触发canplay事件
                oncanplay();
                canplay = true;
                console.log('loadedmetadata');
            });
            this._addEvent(audio, 'canplay', function () {
                oncanplay();
                canplay = true;
                console.log('canplay');
            });
            this._addEvent(audio, 'timeupdate', function () {
                if (!canUpdateTime) return;
                var percent = 0;
                var time = audio.currentTime;
                if (Math.abs(time - currentTime) > 0.05 && !audio.seeking) {
                    ontimeupdate(time, true);
                } else {
                    ontimeupdate(time);
                }
                if (audio.duration) {
                    percent = time / audio.duration * 100;
                }
                onupdateBar(percent);
            });
            this._addEvent(audio, 'stalled', function (e) {
                console.log('stalled');
            });
            this._addEvent(audio, 'error', function (e) {
                onerror();
                console.log('error');
            });
            this._addEvent(audio, 'abort', function (e) {
                console.log('abort');
            });
        },
        _bindClickEvent: function () {
            var self = this;
            if (playBtn) {
                this._addEvent(playBtn, 'click', function (event) {
                    self._stopPropagation(event);
                    self.play();
                });
            }
            if (pauseBtn) {
                this._addEvent(pauseBtn, 'click', function (event) {
                    self._stopPropagation(event);
                    self.pause();
                });
            }
        },
        /**
         * @todo [播放位置是否可寻址]
         * @param    {[Number]}   time [时长]
         * @return   {[Boolean]}       [结果]
         */
        _ifSeekable: function (time) {
            var seekable = audio.seekable;
            var canSeek = false;
            for (var i = 0; i < seekable.length; i++) {
                var start = seekable.start(i);
                var end = seekable.end(i);
                if (time >= start && time <= end) {
                    canSeek = true;
                    break;
                }
            }
            return canSeek;
        },
        /**
         * [_setNearCurrentTime 设置最接近的播放位置]
         */
        _setNearCurrentTime: function () {
            var bufferd = audio.bufferd;
            var distance = 0;
            var preTime = 0;
            for (var i = 0; i < bufferd.length; i++) {
                var start = bufferd.start(i);
                var end = bufferd.end(i);
                if (Math.abs(start - currentTime) < distance || distance == 0) {
                    distance = Math.abs(start - currentTime);
                    preTime = start;
                }
                if (Math.abs(end - currentTime) < distance || distance == 0) {
                    distance = Math.abs(end - currentTime);
                    preTime = end;
                }
            }
            currentTime = preTime;
            audio.currentTime = currentTime;
        },
        _addEvent: function (ele, event_name, func) {
            if (window.attachEvent) {
                ele.attachEvent('on' + event_name, func);
            } else {
                ele.addEventListener(event_name, func, false); //默认事件是冒泡
            }
            allListener[allListener.length] = {
                ele: ele,
                func: func,
                event: event_name
            };
        },
        _removeEvent: function (ele, event_name, func) {
            if (window.attachEvent) {
                ele.detachEvent('on' + event_name, func);
            } else {
                ele.removeEventListener(event_name, func, false);
            }
        },
        _removeAllEvent: function () {
            for (var i = 0; i < allListener.length; i++) {
                var listener = allListener[i];
                this._removeEvent(listener.ele, listener.event, listener.func);
            }
        },
        _stopPropagation: function (e) {
            if (e && e.stopPropagation) {
                //非IE   
                e.stopPropagation();
            } else {
                //IE   
                window.event.cancelBubble = true;
            }
        },
        _preventDefault: function (e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = false;
        }
    };
    if (options) {
        AudioObj.init(options);
    }
    return AudioObj;
}

/* harmony default export */ __webpack_exports__["a"] = (Audio);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_util__ = __webpack_require__(3);



var totalTime = 0;
var myRange = document.getElementById("myRange");
window.mp3 = new __WEBPACK_IMPORTED_MODULE_0__index__["a" /* default */]('res/test.mp3', {
    emptyUrl: 'res/empty.mp3',
    onloadedmetadata: function (duration) {
        var data = '';
        totalTime = duration;
        if (validateDuration(totalTime)) {
            data = __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].formatCountDown(totalTime);
            data = data.hours + ':' + data.minutes + ':' + data.seconds;
            document.getElementById("right_time").innerHTML = data;
        }
    },
    ontimeupdate: function (seconds) {
        if (seconds > totalTime || !validateDuration(totalTime)) {
            onloadedmetadata(audio.duration);
            return;
        }
        var date = __WEBPACK_IMPORTED_MODULE_1__common_util__["a" /* default */].formatCountDown(seconds);
        date = date.hours + ':' + date.minutes + ':' + date.seconds;
        document.getElementById("left_time").innerHTML = date;
        myRange.value = Math.round(seconds / totalTime * 100) || 0;
    },
    onplay: function () {
        console.log('开始播放');
    },
    onpause: function () {
        console.log('播放暂停');
    },
    onwaiting: function () {
        console.log('加载中');
    },
    onplaying: function () {
        console.log('缓冲结束');
    },
    onend: function () {
        myRange.value = 0;
        document.getElementById("left_time").innerHTML = '00:00:00';
        console.log('播放结束');
    },
    //可对数据进行二次处理，例如解密等工作
    onbeforedecode: function (arrayBuffer) {
        // var arr = new Uint8Array(arrayBuffer);
        // for (var i = 0; i < arr.length; i++) {
        //     arr[i] = arr[i] ^ 255;
        // }
    }
});

function validateDuration(duration) {
    if (duration <= 0 || duration == Infinity || isNaN(duration)) {
        return false;
    }
    return true;
}

document.getElementById("myRange").onchange = function () {
    var percent = myRange.value;
    mp3.seek(parseInt(percent));
};

document.querySelector('.play').addEventListener('click', function () {
    mp3.play();
});

document.querySelector('.pause').addEventListener('click', function () {
    mp3.pause();
});

/***/ })
/******/ ]);
//# sourceMappingURL=demo1.min.js.map